% $Id$
%==============================================================================
\section{Test--Driven Component Development}
\label{TestDrivenComponentDevelopment}
%==============================================================================

As we have seen from the Hello World example, components can be implemented in
a parallel task.
While system design describes the structure and interactions between 
components, component implementation constitutes the components behavior.

%------------------------------------------------------------------------------
\subsection{Component development process}
%------------------------------------------------------------------------------
The component development process defines activities needed to 
implement a component's business logic embedded in a generated 
component logic in a test--driven approach. 
Fig.~\ref{ProcessComponentDevelopment} shows the {\it write the test first}
paradigm used in test--driven component development.

\begin{figure}[htbp]
    \begin{center}
    \includegraphics [width=4.5cm,angle=0] {figures/ProcessComponentDevelopment.eps}
    \caption{A test--driven component development process.}
    \label{ProcessComponentDevelopment}            
    \end{center}
\end{figure}

\noindent
Two nested iteration cycles are shown in the diagram 
(Fig.~\ref{ProcessComponentDevelopment}). 
The inner iteration cycle 
is concerned with implementing and testing business logic to pass a particular 
test case.
The outer iteration cycle is started with every new test case derived from a 
functional requirement analysis.

\newpage
\noindent
The presented component development process contains the following activities: 
\begin{itemize}
\item {\bf Generate component.}
Based on component descriptions, tools can be used to 
generate platform specific component logic which can host the implemented 
business logic.

\item {\bf Analyze requirements.}
A component has to satisfy a set of functional requirements. The description 
of these requirements can be formally specified, modeled or written in prosa.

\item {\bf Implement test cases.}
From the requirements specifications, test cases can be implemented. 
These test cases express a component's usage in a particular programming 
language.
There will be a test case for every postulated aspect of the component's 
functionality.
Each executable test case augments the set of automated tests that can be
run again later for regression testing too.

\item {\bf Implement business logic.}
The business logic must be implemented in a way that the implemented test cases
can run without a failure. 
There is no need for a component developer to know the overall goal of the 
software system. 
The business logic is only determined by requirements expressed by executable
test cases.

\item {\bf Run test case.}
At every time in development, the business logic of a component can be checked
by running all implemented test cases.
Thus, there is a well defined end to component development - as soon as all 
test cases, that represents the functional requirements, are
running, the work is done.
\end{itemize}

\noindent
The fact, that each implementation of a component's functionality starts by 
writing a test case, automatically leads to testable business logic.
Another benefit of executable test cases is that - after a change in 
business code - the whole test suite can be run to ensure the functional 
integrity of the component's implementation. 


%------------------------------------------------------------------------------
\subsubsection{Component development roles}
%------------------------------------------------------------------------------
The test--driven component development process defines two development roles 
which are usually performed by the same person:

\begin{itemize}
\item {\bf Test developer.}
A test developer analyzes the functional requirements for a component's 
business logic and implements test cases that can verify these requirements 
automatically.
 
\item {\bf Component developer.}
A component developer implements a component's business logic in respect to the
given test cases. His work is done, when all tests run through. 
\end{itemize}


\newpage
%------------------------------------------------------------------------------
\subsection{Car rental example}
%------------------------------------------------------------------------------

As a simple example, we define a car rental component that can handle customers
and miles. For each customer we can evaluate driven miles and costs incurred. 
We will store all created IDL files in a {\tt CarRental} directory
\footnote
{
You can find this example source code in the 
{\tt ccmtools/test/tutorial/CarRental} directory.}:
\begin{small}
\begin{verbatim}
        CarRental/
        |-- Exceptions.idl
        |-- Customer.idl
        |-- CustomerMaintenance.idl
        |-- CustomerBusiness.idl
        `-- CarRental.idl
\end{verbatim}
\end{small}

Keep in mind that IDL files contain no specification of what exact action will 
be performed.
The component developer bears the responsibility of filling in the functionality
after the component logic has been generated.

\begin{small}
\begin{verbatim}
#ifndef __EXCEPTIONS_IDL__
#define __EXCEPTIONS_IDL__

module BigBusiness {
  exception CreateCustomerException{};
  exception RemoveCustomerException{};
  exception NoCustomerException{};
}; // End of module BigBusiness
#endif
\end{verbatim}
\end{small}
This first code snippet shows the definition of three IDL exceptions.
In order to get a namespace, we envelop these definitions using a module called 
{\tt BigBusiness}. 
To prevent IDL files from multiple including, we define {\it include guards} 
within each source file.



 
\begin{small}
\begin{verbatim}
#ifndef __CUSTOMER_IDL__
#define __CUSTOMER_IDL__

module BigBusiness {
  struct Customer {
    long id;
    string first_name;
    string last_name;
    double mileage;
  };
  typedef sequence<Customer> CustomerList;
}; // End of module BigBusiness
#endif
\end{verbatim}
\end{small}

In {\tt Customer.idl}, we define a structure of basic data types and a sequence 
of this structure type.
Again, there is a {\tt BigBusiness} module and an include guard.

\begin{small}
\begin{verbatim}
#ifndef __CUSTOMER_MAINTENANCE_IDL__
#define __CUSTOMER_MAINTENANCE_IDL__

#include"Exceptions.idl"
#include"Customer.idl"

module BigBusiness {
  interface CustomerMaintenance
  {
    void createCustomer(in Customer person) 
      raises (CreateCustomerException);
    Customer retrieveCustomer(in long id)  
      raises (NoCustomerException);
    CustomerList retrieveAllCustomers()  
      raises (NoCustomerException);
    void updateCustomer(in Customer person)  
      raises (NoCustomerException);
    void deleteCustomer(in long id)  
      raises (RemoveCustomerException);
  };
}; // End of module BigBusiness
#endif
\end{verbatim}
\end{small}
Customers must be handled in a database like way. 
Thus, {\tt CustomerMaintenance.idl} contains a 
{\it Create, Retrieve, Update and Delete} (CRUD) interface. 
To pick a particular {\tt Customer}, we use a customer id that is realized by 
an IDL long type.
Methods can throw exceptions in the case of illegal customer ids, create or 
remove problems. 


\begin{small}
\begin{verbatim}
#ifndef __CUSTOMER_BUSINESS_IDL__
#define __CUSTOMER_BUSINESS_IDL__

#include "Exceptions.idl"

module BigBusiness {
  interface CustomerBusiness
  {
    attribute double dollars_per_mile;
    void addCustomerMiles(in long id, in double miles) 
      raises(NoCustomerException);
    void resetCustomerMiles(in long id) 
      raises(NoCustomerException);
    double getCustomerMiles(in long id) 
      raises(NoCustomerException);
    double getCustomerDollars(in long id) 
      raises(NoCustomerException);
  };
}; // End of module BigBusiness
#endif
\end{verbatim}
\end{small}

Beside the pure data manipulation, we also need an interface that defines a
business functionality.
{\tt CustomerBusiness.idl} defines an attribute and some methods that operate
on the given customer data. 
If a parameter represents a wrong customer id, the {\tt NoCustomerException}
will be thrown.

\begin{small}
\begin{verbatim}
#ifndef __CAR_RENTAL_IDL__
#define __CAR_RENTAL_IDL__

#include "CustomerMaintenance.idl"
#include "CustomerBusiness.idl"

module BigBusiness {

  component CarRental 
  { 
    provides CustomerMaintenance maintenance;
    provides CustomerBusiness business;
  };
  
  home CarRentalHome manages CarRental 
  { };

}; // End of module BigBusiness
#endif
\end{verbatim}
\end{small}

Finally, we collect the included interfaces to a {\tt CarRental} component and 
define a {\tt CarRentalHome} that will be used to create component instances at
runtime.

Well done! We have defined our component in terms of IDL.


\vspace{10mm}
%------------------------------------------------------------------------------
\subsubsection{Generate component}
%------------------------------------------------------------------------------

In this step, we bring the IDL3 files in a proper structure that implies 
the separation between interface and component definitions. 
\begin{small}
\begin{verbatim}
> ccmtools idl3 -o server/idl3 *.idl
\end{verbatim}
\end{small}
A result of this CCM Tools call is the following file structure.
The separation between interface and component related files reflects the
fact that interfaces are used to defined components but are not owned by
these components.
\begin{small}
\begin{verbatim}
server
`-- idl3
    |-- component
    |   `-- BigBusiness
    |       |-- CarRental.idl
    |       `-- CarRentalHome.idl
    `-- interface
        `-- BigBusiness
            |-- CreateCustomerException.idl
            |-- Customer.idl
            |-- CustomerBusiness.idl
            |-- CustomerList.idl
            |-- CustomerMaintenance.idl
            |-- NoCustomerException.idl
            `-- RemoveCustomerException.idl
\end{verbatim}
\end{small}


To generate C++ source code from IDL3 we have to call the CCM Tools generator
twice, once for the interfaces and once for the component:
\begin{small}
\begin{verbatim}
> ccmtools c++local -o server/interface \
                    -Iserver/idl3/interface \
                     server/idl3/interface/BigBusiness/*.idl
> ccmtools c++local -a -o server/component/CarRental \
                    -Iserver/idl3/component \
                    -Iserver/idl3/interface \
                     server/idl3/component/BigBusiness/CarRental*.idl 
\end{verbatim}
\end{small}

Now, the {\tt server} directory contains the component's source code. 
(To get a description of all {\tt ccmtools} options consult the 
CCM Tools commands section in the tutorial's appendix).
\begin{small}
\begin{verbatim}
server
|-- idl3
|-- component
|   `-- CarRental
|       |-- CCM_Local_BigBusiness_CCM_Session_CarRental
|       |-- CCM_Local_BigBusiness_CCM_Session_CarRental_share
|       `-- impl
|           |-- CarRentalHome_entry.h
|           |-- CarRentalHome_impl.cc
|           |-- CarRentalHome_impl.h
|           |-- CarRental_business_impl.cc
|           |-- CarRental_business_impl.h
|           |-- CarRental_impl.cc
|           |-- CarRental_impl.h
|           |-- CarRental_maintenance_impl.cc
|           |-- CarRental_maintenance_impl.h
|           `-- Makefile.py
`-- interface
    `-- CCM_Local_BigBusiness
        |   |-- CreateCustomerException.h
        |   |-- Customer.h
        |   |-- CustomerBusiness.h
        |   |-- CustomerList.h
        |   |-- CustomerMaintenance.h
        |   |-- Makefile.py
        |   |-- NoCustomerException.h
        |   `-- RemoveCustomerException.h
        `-- Makefile.py
\end{verbatim}
\end{small}

The component developer really ought not to care about the generated 
{\tt CCM\_Local\_*} subdirectories (if you don't believe us, though, feel free 
to read through it; just don't edit anything). 
The interesting files are listed in the {\tt impl} directory. 
These files contain skeleton code (that are empty methods) of the component's 
business logic.

\begin{itemize}
\item {\tt CarRentalHome\_entry.h} \\
This file is the business logic's entry point and declares an extern ``C'' 
function that returns a component home instance.
The generated implementation of this function is hosted in the 
{\tt CarRentalHome\_impl.cc} file.

\item {\tt CarRentalHome\_impl.[h,cc]} \\
These files contain the factory methods for component instantiation. 
While user defined factory methods must be implemented manually, the default 
{\tt create} method is already generated.

\item {\tt CarRental\_impl.[h,cc]} \\
These files contain the implementation of supported interfaces as well as the
implementation of component attributes.

\item {\tt CarRental\_business\_impl.[h,cc]} \\
{\tt CarRental\_maintenance\_impl.[h,cc]} \\
These files contain the implementation of defined facets and builds
the component's business logic
(grep for {\tt // TODO : IMPLEMENT ME HERE !}).

\item {\tt Makefile.py} \\
This file is a Confix marker that denotes a directory as 'to compile'.
\end{itemize}

Files in the {\tt impl} directory are protected from overwriting.
Running the generator again results in a bunch of warnings. 
Instead of overwriting, the generator stores the new files with an extension 
({\tt *.new}) into the same directory.
You can make a {\tt diff} to figure out changes. 

\vspace{3mm}
The generated business logic skeletons contains enough code to be compilable.
Confix, our build tool, needs some informations about the package to build.
The following content must be placed in the {\tt server/Makefile.py} file:
\begin{small}
\begin{verbatim}
# server/Makefile.py
PACKAGE_NAME('CarRental')
PACKAGE_VERSION('1.0.0')
\end{verbatim}
\end{small}
Additionally, some empty {\tt Makefile.py} files must be placed in
source directories to force {\tt Confix} to build them:
\begin{small}
\begin{verbatim}
> touch server/interface/Makefile.py
> touch server/component/Makefile.py
> touch server/component/CarRental/Makefile.py
\end{verbatim}
\end{small}

Finally, to build the generated {\tt Carrental} component, type:
\begin{small}
\begin{verbatim}
> confix.py --packageroot=`pwd`/server --bootstrap --configure --make
\end{verbatim}
\end{small}



%------------------------------------------------------------------------------
\subsubsection{Mirror Component Concept (MCC)}
%------------------------------------------------------------------------------

Software development is an iterative process. Kent Beck
has proposed a {\it Test Driven Development} (TDD) methodology 
\cite{Beck2003TDD} that starts by
implementing the test~-- before implementing the business logic!

As shown in Fig.~\ref{fig:test-driven-development}, the CCM Tools make use of
the TDD idea in the context of components. For every component $C$, we
generate a mirror component $\overline{C}$. Each input port (receptacle)
of $C$ corresponds to an output port (facet) of $\overline{C}$, and vice versa.

\begin{figure}[htb]
    \begin{center}
    \includegraphics [width=5cm,angle=0] {figures/TestArchitecture.eps}
    \caption{A Component test architecture consists of a 
      $(C, \overline{C})$ pair that is managed by a test client.}
    \label{fig:test-driven-development}
    \end{center}
\end{figure}

Fig.~\ref{TestClientSequenceDiagramm} shows the sequence diagram for this 
automatic test concept.
Basically, a mirror component test is made up of three execution phases:

\begin{itemize}
\item Setup phase (step 1 to 10): \\
Before a test case can be executed, the mirror component test environment must
be established.
First, both components must be created and configured by their attributes.
$C$ and $C\_mirror$ hold the same attribute set,
thus, both components can be configured in the same way. 
Then, $C$ and $C\_mirror$ are connected with each other.

Calling {\tt configuration\_complete} finishes this build--up phase.

\item Testing phase (step 11):\\
In this phase all test cases implemented in $C\_mirror$ are executed.
Remember, after a {\tt configuration\_complete} call from a client, the 
container calls a component's {\tt ccm\_activate} callback method.
Test cases can be implemented in or called from this callback
method. 
As all test cases are implemented within a component, a test 
developer can use the same programming paradigm as a component developer. 

\item Tear down phase (step 12 to 15): \\
After all test cases have finished, the mirror component test environment must 
be destroyed.
All connections between $C$ and $C\_mirror$ must be disconnected and both
components must be removed. 
\end{itemize}

\begin{figure}[htb]
    \begin{center}
      \includegraphics [width=9.5cm,angle=0] 
		       {figures/TestClientSequenceDiagram.eps}
    \caption{Automatic test procedure based on the mirror component 
      test concept.}
    \label{TestClientSequenceDiagramm}            
    \end{center}
\end{figure}

\noindent
A component test spans from component creation to component destruction.
Thus, we have implemented a full component life cycle test environment that
is the assumption to implement components in a test driven way.

Because a mirror component can be used as an executable semantic description of 
a component's business logic, component development can stop as soon as all 
mirror component test cases run through. 

To create a mirror component $\overline{C}$ definition from existing
IDL3 files, type:
\begin{small}
\begin{verbatim}
> ccmtools idl3mirror -o server/idl3 \
                      -Iserver/idl3/interface \
                      -Iserver/idl3/component \
                      server/idl3/component/BigBusiness/CarRental*.idl
\end{verbatim}
\end{small}

From the generated IDL3 files you can see that both $\overline{C}$ and $C$ 
uses the same interfaces.
\begin{small}
\begin{verbatim}
server
`-- idl3
    |-- component
    |   `-- BigBusiness
    |       |-- CarRental.idl
    |       |-- CarRentalHome.idl
    |       |-- CarRentalHome_mirror.idl    // new
    |       `-- CarRental_mirror.idl        // new
    `-- interface
        `-- BigBusiness
            |-- CreateCustomerException.idl
            |-- Customer.idl
            |-- CustomerBusiness.idl
            |-- CustomerList.idl
            |-- CustomerMaintenance.idl
            |-- NoCustomerException.idl
            `-- RemoveCustomerException.idl
\end{verbatim}
\end{small}

Now we can use the regular {\tt c++local} generator to create C++ component 
logic from the IDL3 mirror files.
\begin{small}
\begin{verbatim}
> ccmtools c++local -a -o server/component/CarRental_mirror \
                       -Iserver/idl3/interface \
                       -Iserver/idl3/component \
                       server/idl3/component/BigBusiness/CarRental*_mirror.idl
\end{verbatim}
\end{small}
This results in the following file structure:
\begin{small}
\begin{verbatim}
server
|-- component
|   |-- CarRental
|   `-- CarRental_mirror
|       |-- CCM_Local_BigBusiness_CCM_Session_CarRental_mirror
|       |-- CCM_Local_BigBusiness_CCM_Session_CarRental_mirror_share
|       `-- impl
|           |-- CarRentalHome_mirror_entry.h
|           |-- CarRentalHome_mirror_impl.cc
|           |-- CarRentalHome_mirror_impl.h
|           |-- CarRental_mirror_impl.cc
|           |-- CarRental_mirror_impl.h
|           `-- Makefile.py
\end{verbatim}
\end{small}

The {\tt impl} directory contains generated files of the mirror
component's business logic that can host component test cases.
In the next sections of this tutorial, we will implement test cases as well
as business logic. 


Finally, a test client that coordinates creation and connecting of 
component $C$ and mirror component $\overline{C}$ must be added.
To generate this test client, we type:
\begin{small}
\begin{verbatim}
> ccmtools c++local-test -o server/component/CarRental_mirror \
                         -Iserver/idl3/interface \
                         -Iserver/idl3/component \
                         server/idl3/component/BigBusiness/CarRental.idl
\end{verbatim}
\end{small}

The generated files are stored in the following way:
\begin{small}
\begin{verbatim}
server
|-- component
|   |-- CarRental
|   `-- CarRental_mirror
|       |-- CCM_Local_BigBusiness_CCM_Session_CarRental_mirror
|       |-- CCM_Local_BigBusiness_CCM_Session_CarRental_mirror_share
|       |-- impl
|       `-- test
|           |-- Makefile.py
|           `-- _check_CCM_Local_BigBusiness_CCM_Session_CarRental.cc
\end{verbatim}
\end{small}

The {\tt test} directory contains a generated {\tt \_check\_*} file that 
contains the test client and is also protected from overwriting.

Before we can use {\tt Confix} to build the mirror component and run the
test case, a {\tt Makefile.py} file must sign the new component directory:
\begin{small}
\begin{verbatim}
> touch server/component/CarRental_mirror/Makefile.py

> confix.py --packageroot=`pwd`/server --bootstrap --configure 
            --make --targets=check 
\end{verbatim}
\end{small}


\newpage
%------------------------------------------------------------------------------
\subsubsection{Implement test cases}
%------------------------------------------------------------------------------

Now is a good time to start the development of business code. First, we have to
define the behavior of the business code in an executable semantic. 
In other words, we write a test case in the mirror component 
({\tt CarRental\_mirror\_impl.cc}):

\begin{small}
\begin{verbatim}
void CCM_CarRental_mirror_impl::ccm_activate()
    throw (LocalComponents::CCMException)
{
    try {
      {
          CCM_Local::BigBusiness::Customer person;
          person.id = 1;
          person.first_name = "Franz";
          person.last_name = "Kafka";
          ctx->get_connection_maintenance_mirror()->
              createCustomer(person);
      }
      {
          CCM_Local::BigBusiness::Customer person;
          long id = 1;
          person = ctx->get_connection_maintenance_mirror()->
              retrieveCustomer(id);
          assert(person.id == 1);
          assert(person.first_name == "Franz");
          assert(person.last_name == "Kafka");
      }
  }
  catch(CCM_Local::BigBusiness::CreateCustomerException) {
      cerr << "MAINTENANCE ERROR: Can't create customer!" << endl;
  }
  catch(CCM_Local::BigBusiness::NoCustomerException) {
      cerr << "MAINTENANCE ERROR: no customer found!" << endl;
  }
}
\end{verbatim}
\end{small}
The test case is implemented in the {\tt ccm\_activate()} callback method of the
mirror component because this method is called after creating and connecting $C$
and $\overline{C}$ from the component logic. 

First, we create a valid {\tt Customer} record and  
use the context object ({\tt ctx}) to get a smart pointer
to $\overline{C}$'s receptacle (which is connected with $C$'s facet) 
before we call the {\tt createCustomer} operation. 
After that, we retrieve the record from the receptacle and compare the stored 
items.

To compile and run the test, we call {\tt Confix} as before:
\begin{small}
\begin{verbatim}
> confix.py --packageroot=`pwd`/server --bootstrap --configure 
            --make --targets=check 
\end{verbatim}
\end{small}
The test failed! 
That's fine because there is no business code to work with...






%------------------------------------------------------------------------------
\subsubsection{Implement business logic}
%------------------------------------------------------------------------------

Now we are ready to implement the business logic that satisfies the written 
test case. 
First, we implement the customer database - no panic - we 
simple put a C++ {\tt std::vector<>} into the {\tt CarRental\_impl.h} file,
to hold {\tt Customer} entities.

\begin{small}
\begin{verbatim}
class CCM_CarRental_impl : virtual public CCM_CarRental
{
  public:
    std::vector<CCM_Local::BigBusiness::Customer> CustomerDB;
    //...
};
\end{verbatim}
\end{small}

Next, we open {\tt CarRental\_maintenance\_impl.cc} and add the following 
lines:
\begin{small}
\begin{verbatim}
void
maintenance_impl::createCustomer ( const Customer& person )
  throw (LocalComponents::CCMException, CreateCustomerException)
{
  component->CustomerDB.push_back(person);
}

Customer
maintenance_impl::retrieveCustomer ( const long id )
  throw (LocalComponents::CCMException, NoCustomerException)
{
  std::vector<CCM_Local::BigBusiness::Customer>::iterator pos;
  for(pos = component->CustomerDB.begin(); 
      pos != component->CustomerDB.end(); ++pos) {
    if(pos->id == id) {
      return *pos;
    }
  }
  throw NoCustomerException();
}
\end{verbatim}
\end{small}

Instead of a database, we simply use a {\tt std::vector<>} to implement
the {\tt createCustomer} and {\tt retrieveCustomer} methods - that's it! 

We'll run the test again to see if it's working:
\begin{small}
\begin{verbatim}
> confix.py --packageroot=`pwd`/server --make --targets=check
\end{verbatim}
\end{small}

Yay, the test passed!



%------------------------------------------------------------------------------
\subsubsection{Implement test case, implement business logic, run test case...}
%------------------------------------------------------------------------------

The idea of test driven development is to run short cycles of test and
implementation until all required functionality is implemented.
For the {\tt CarRental} component, this section goes through all these 
development steps. 
To keep the tutorial clean, we implement only simple tests that show the
functionality of {\tt CarRental}'s business logic.
In practice, these white box tests must be much more substantial.

\begin{small}
\begin{verbatim}
    {
      CCM_Local::BigBusiness::Customer person;

      person.id = 2;
      person.first_name = "Thomas";
      person.last_name = "Bernhard";
      ctx->get_connection_maintenance_mirror()->
           createCustomer(person);

      person.id = 3;
      person.first_name = "Karl";
      person.last_name = "Kraus";
      ctx->get_connection_maintenance_mirror()->
           createCustomer(person);
    }
\end{verbatim}
\end{small}

To test the {\tt retrieveAllCustomers} method, we add two other customers before
we call the method. All retrieved records are compared with their initial values
to validate the query results. 

\begin{small}
\begin{verbatim}
    {
      CCM_Local::BigBusiness::CustomerList person_list;

      person_list = ctx->get_connection_maintenance_mirror()->
                         retrieveAllCustomers();
      assert(person_list.at(2).id == 3);
      assert(person_list.at(2).first_name == "Karl");
      assert(person_list.at(2).last_name == "Kraus");

      assert(person_list.at(1).id == 2);
      assert(person_list.at(1).first_name == "Thomas");
      assert(person_list.at(1).last_name == "Bernhard");

      assert(person_list.at(0).id == 1);
      assert(person_list.at(0).first_name == "Franz");
      assert(person_list.at(0).last_name == "Kafka");
    }      
\end{verbatim}
\end{small}

The method's implementation creates a new {\tt CustomerList} which
is returned by value.
In the case of an empty list the {\tt NoCustomerException} is thrown.

\begin{small}
\begin{verbatim}
CustomerList maintenance_impl::retrieveAllCustomers (  )
  throw (LocalComponents::CCMException, NoCustomerException )
{
  if(component->CustomerDB.size() == 0)
      throw NoCustomerException();
  CCM_Local::BigBusiness::CustomerList customer_list;
  std::vector<CCM_Local::BigBusiness::Customer>::iterator pos;
  for(pos = component->CustomerDB.begin(); 
      pos != component->CustomerDB.end(); ++pos) {
    customer_list.push_back(*pos);
  }
  return customer_list;
}
\end{verbatim}
\end{small}

Next, we implement a test case for {\tt updateCustomer}.
A new {\tt Customer} record is created and used as parameter.
To check the update procedure, we use {\tt retrieveCustomer} 
and compare the result record with the new values.

\begin{small}
\begin{verbatim}
    {
      CCM_Local::BigBusiness::Customer person;
      person.id = 1;
      person.first_name = "Werner";
      person.last_name = "Schwab";
      double mileage = 0.0;
      ctx->get_connection_maintenance_mirror()->
           updateCustomer(person);      

      CCM_Local::BigBusiness::Customer another_person;
      another_person = 
        ctx->get_connection_maintenance_mirror()->
             retrieveCustomer(person.id);
      assert(another_person.id == 1);
      assert(another_person.first_name == "Werner");
      assert(another_person.last_name == "Schwab");
    }
\end{verbatim}
\end{small}



To implement {\tt updateCustomers} we simply iterate through the {\tt Customer}
vector and compare each item with the given person.
If person matches, we overwrite the vector item and return.
If person does not match, {\tt NoCustomerException} is thrown.

\begin{small}
\begin{verbatim}
void maintenance_impl::updateCustomer ( const Customer& person )
  throw (LocalComponents::CCMException, NoCustomerException )
{
  std::vector<CCM_Local::BigBusiness::Customer>::iterator pos;
  for(pos = component->CustomerDB.begin(); 
      pos != component->CustomerDB.end(); ++pos) {
    if(pos->id == person.id) {
      *pos = person;
      return;
    }
  }
  throw NoCustomerException();  
}
\end{verbatim}
\end{small}


In the following test case, we delete a {\tt Customer} and try to retrieve the 
deleted record.
If this works, we break the test ({\tt assert(false)}) because this would be an
incorrect behavior. 
Instead, the {\tt RemoveCustomerException} must be thrown.
\begin{small}
\begin{verbatim}
    {
      long id = 1;
      ctx->get_connection_maintenance_mirror()->
           deleteCustomer(id);
      CCM_Local::BigBusiness::Customer person;
      person = ctx->get_connection_maintenance_mirror()->
                    retrieveCustomer(id);
      assert(false); // Customer found => error
    }
\end{verbatim}
\end{small}

\begin{small}
\begin{verbatim}
void maintenance_impl::deleteCustomer ( const long id )
  throw (LocalComponents::CCMException, RemoveCustomerException)
{
  std::vector<CCM_Local::BigBusiness::Customer>::iterator pos;
  for(pos = component->CustomerDB.begin(); 
      pos != component->CustomerDB.end(); ++pos) {
    if(pos->id == id) {
      component->CustomerDB.erase(pos);
      return;
    }
  }
  throw RemoveCustomerException();  
}
\end{verbatim}
\end{small}

We iterate through the {\tt Customer} vector and compare 
each item with the given id.
If the given record is found, we will remove it from the {\tt Customer} vector.
If the given id can't be found in the{\tt Customer} vector, 
{\tt RemoveCustomerException} is thrown.
In conclusion, we have implemented the whole {\tt maintenance} facet hand in 
hand with its test cases. 

\vspace{3mm}
A great benefit of test driven development is that testing is not longer a 
separated part at the end of a software development process.
In practice, most projects are running out of time before testing can start. 
Thus, lots of functionality is implemented but test cases are skipped 
frequently.
With a test driven approach, one can scale the functionality of a project when 
time is running out, but ensure software quality by having automatic tests.

Another benefit of automatic tests appear in context of code refactoring. 
After making some changes in a component's implementation, we can run all test 
cases to ensure that its functionality is still available.


In order to implement the second facet, we start with a new test case in 
$\overline{C}$.
For {\tt business} facet tests, we create a new try/catch block that catches
only {\tt NoCustomerException}s.
 
The test adds some miles to an existing customer, retrieves the current miles 
value from the same customer and verifies their equality. 

\begin{small}
\begin{verbatim}
  try {
    {
      long id = 2;
      double miles = 197.7;

      ctx->get_connection_business_mirror()->
           addCustomerMiles(id, miles); 

      double other_miles;
      other_miles = 
        ctx->get_connection_business_mirror()->
             getCustomerMiles(id); 
      assert( abs(other_miles - miles) < 0.001);
    }
  }
  catch(CCM_Local::BigBusiness::NoCustomerException) {
    cerr << "MAINTENANCE ERROR: no customer found!" << endl;
    assert(false);
  }
\end{verbatim}
\end{small}


To make the test run, we have to implement two facet methods.
{\tt addCustomerMiles} iterates through the {\tt Customer} vector
and compares the id values.
If the given {\tt Customer} id is found, the miles value is added to
its current status.
If the given id does not match, a {\tt NoCustomerException} is thrown.
\begin{small}
\begin{verbatim}
void business_impl::addCustomerMiles(const long id, 
                                     const double miles)
  throw (LocalComponents::CCMException, NoCustomerException )
{
  std::vector<CCM_Local::BigBusiness::Customer>::iterator pos;

  for(pos = component->CustomerDB.begin(); 
      pos != component->CustomerDB.end(); ++pos) {
    if(pos->id == id) {
      pos->mileage += miles;
      return;
    }
  }
  throw NoCustomerException();    
}
\end{verbatim}
\end{small}

After adding miles to an existing {\tt Customer} we have to implement a method
that get the current value of a {\tt Customer}'s mileage member.

\begin{small}
\begin{verbatim}
double business_impl::getCustomerMiles ( const long id )
  throw (LocalComponents::CCMException, NoCustomerException )
{
  std::vector<CCM_Local::BigBusiness::Customer>::iterator pos;

  for(pos = component->CustomerDB.begin(); 
      pos != component->CustomerDB.end(); ++pos) {
    if(pos->id == id) {
      return pos->mileage;
    }
  }
  throw NoCustomerException(); 
}
\end{verbatim}
\end{small}

Again, we iterate through the {\tt Customer} vector and compare the id values.
If we find a {\tt Customer} with the right id, we read its mileage value and
return it to the caller.
In the other case, as usual, the {\tt NoCustomerException} is thrown.


The following test case sets the facet's {\tt dollars\_per\_mile} attribute
and retrieves the current mileage and Dollar status of a particular 
{\tt Customer} determined by its id.
Thus, the component's calculation can be verified.

\begin{small}
\begin{verbatim}
    {
      long id = 2;
      double dollars, miles;
      double factor = 5.3;
      ctx->get_connection_business_mirror()->
           dollars_per_mile(factor);
      miles = ctx->get_connection_business_mirror()->
                   getCustomerMiles(id);
      dollars = ctx->get_connection_business_mirror()->
                     getCustomerDollars(id); 
      assert( abs(dollars - miles*factor) < 0.001);
    }
\end{verbatim}
\end{small}

Note that a standard implementation of a facet's attribute will be
generated by CCM Tools.

The following code implements the {\tt getCustomerDollars()} method:
\begin{small}
\begin{verbatim}
double business_impl::getCustomerDollars ( const long id )
  throw (LocalComponents::CCMException, NoCustomerException )
{
  return getCustomerMiles(id) * _dollars_per_mile;
}
\end{verbatim}
\end{small}

Life would be pretty ease if all business logic would be as simple to implement 
as this method ;-)


\newpage
Finally, the last test case resets a {\tt Customer}'s mileage value and 
retrieves its Dollar status. Of course, it has to be null.

\begin{small}
\begin{verbatim}
    {
      long id = 2;
      double dollars;
      ctx->get_connection_business_mirror()->
           resetCustomerMiles(id);
      dollars = 
        ctx->get_connection_business_mirror()->
             getCustomerDollars(id); 
      assert( abs(dollars) < 0.001);
    }
\end{verbatim}
\end{small}

{\tt resetCustomerMiles()} searches in the {\tt Customer}
vector for the given id and set the mileage value to null.
If no {\tt Customer} id matches, the {\tt NoCustomerException} is thrown.

\begin{small}
\begin{verbatim}
void business_impl::resetCustomerMiles ( const long id )
  throw (LocalComponents::CCMException, NoCustomerException )
{
  std::vector<CCM_Local::BigBusiness::Customer>::iterator pos;
  for(pos = component->CustomerDB.begin(); 
      pos != component->CustomerDB.end(); ++pos) {
    if(pos->id == id) {
      pos->mileage = 0.0;
      return;
    }
  }
  throw NoCustomerException(); 
}
\end{verbatim}
\end{small}

Well done! You have implemented the whole component in a test--driven
way using CCM Tools.



%------------------------------------------------------------------------------
\subsubsection{Install the {\tt CarRental} component}
%------------------------------------------------------------------------------

Installing a component means that the component's libraries and header files 
will be stored in a component repository, which is simply a directory on your 
computer (specified by {\tt PREFIX} in {\tt ~/.confix}).

Component installation is performed by Confix:
\begin{small}
\begin{verbatim}
> confix.py --packageroot=`pwd`/server/component \
            --make --targets=install
\end{verbatim}
\end{small}

\newpage
After installing a component, the component repository contains the following
file structures:
\begin{small}
\begin{verbatim}
include/
|-- CCM_Local
|   |-- BigBusiness
|   |   |-- CCM_Session_CarRental/
|   |   |-- CCM_Session_CarRental_mirror/
|   |   |-- CreateCustomerException.h
|   |   |-- Customer.h
|   |   |-- CustomerBusiness.h
|   |   |-- CustomerList.h
|   |   |-- CustomerMaintenance.h
|   |   |-- NoCustomerException.h
|   |   `-- RemoveCustomerException.h
\end{verbatim}
\end{small}

\begin{tiny}
\begin{verbatim}
lib/
|-- libCarRental_component_CarRental_CCM_Local_BigBusiness_CCM_Session_CarRental.a
|-- libCarRental_component_CarRental_impl.a
|-- libCarRental_component_CarRental_mirror_CCM_Local_BigBusiness_CCM_Session_CarRental_mirror.a
`-- libCarRental_component_CarRental_mirror_impl.a
\end{verbatim}
\end{tiny}


%------------------------------------------------------------------------------
\subsubsection{Implement a {\tt CarRental} client}
%------------------------------------------------------------------------------

A component based application builds up component assemblies using installed
components. In this section we will show this using a simple client that
instantiates the {\tt CarRental} component and calls the component's operations.

First, we add a {\tt client} directory to our project and implement
the client code in the {\tt src} subdirectory:
\begin{small}
\begin{verbatim}
CarRental/
|-- server/
`-- client
    |-- Makefile.py
    `-- CarRentalClient.cc
\end{verbatim}
\end{small}

Don't forget to implement the {\tt client/Makefile.py} file:
\begin{small}
\begin{verbatim}
PACKAGE_NAME('CarRentalClient')
PACKAGE_VERSION('1.0.0')
\end{verbatim}
\end{small}

First, a client needs a bunch of included header files that are generated by 
the CCM Tools.
There are different namespaces defined in the header files that we are using 
in the client code.

Second, the client's main function contains all the necessary code to use
the local {\tt CarRental} component. 
\begin{itemize}
\item Client's bootstrap and tear--down code.\\
Before a component can be used, a component home must be instantiated and 
registered by the {\tt HomeFinder}.
After using a component, the component home instance must be removed from 
memory and from the {\tt HomeFinder}'s list.
\item Component's instantiation code. \\
A client gets a home reference from the {\tt HomeFinder}, creates a component 
instance and asks for the component's facets.
To denote the end of this instantiation phase, the client calls 
{\tt configuration\_complete()}.
After all business calls, the client has to remove its component instance.

\item Client's application code. \\
Here the client calls some component operations to make its business work.
We have implemented a simple use case known from our mirror component test 
cases.
\end{itemize}

\begin{small}
\begin{verbatim}
#include <LocalComponents/CCM.h>
#include <CCM_Local/HomeFinder.h>
#include <WX/Utils/debug.h>
#include <WX/Utils/smartptr.h>

#include <CCM_Local/BigBusiness/CCM_Session_CarRental/CarRentalHome_gen.h>
#include <CCM_Local/BigBusiness/CCM_Session_CarRental/CarRental_gen.h>

using namespace std;
using namespace WX::Utils;
using namespace CCM_Local;
using namespace BigBusiness;
using namespace CCM_Session_CarRental;

int main(int argc, char *argv[])
{
  int error = 0;
  LocalComponents::HomeFinder* homeFinder;

  // Component deployment
  homeFinder = HomeFinder::Instance (  );
  error  = deploy_CCM_Local_BigBusiness_CarRentalHome("CarRentalHome");
  if(error) {
    cerr << "BOOTSTRAP ERROR: Can't deploy component homes!" << endl;
    return(error);
  }

  // Component instantiation
  try {
    SmartPtr<CarRentalHome> 
        myCarRentalHome(dynamic_cast<CarRentalHome*>
           (homeFinder->find_home_by_name("CarRentalHome").ptr()));

    SmartPtr<CarRental> myCarRental = myCarRentalHome->create();

    SmartPtr<CCM_Local::BigBusiness::CustomerMaintenance> 
      maintenance = myCarRental->provide_maintenance();    
    SmartPtr<CCM_Local::BigBusiness::CustomerBusiness> 
      business = myCarRental->provide_business();

    myCarRental->configuration_complete();

    // Use component
    CCM_Local::BigBusiness::Customer person;
    person.id = 1;
    person.first_name = "Franz";
    person.last_name = "Kafka";
    maintenance->createCustomer(person);

    business->addCustomerMiles(1, 120.0); 
    person = maintenance->retrieveCustomer(1);
    double dollars = business->getCustomerDollars(1); 

    cout << " Customer: " << person.first_name 
         << " " << person.last_name << endl;
    cout << " Miles: " <<  person.mileage << endl;
    cout << " to pay: " << dollars << " Dollars" << endl;

    // Destroy component instance
    myCarRental->remove();
  } 
  catch ( ... )  {
    cout << "Client: there is something wrong!" << endl;
    error = -1;
  }

  // Component tear down:
  error += undeploy_CCM_Local_BigBusiness_CarRentalHome("CarRentalHome");
  if(error) {
    return error;
  }
}
\end{verbatim}
\end{small}

To build and run the client application, we say:
\begin{small}
\begin{verbatim}
> confix.py --packageroot=`pwd`/client --bootstrap --configure 
            --make --target=install

> $CCM_INSTALL/bin/CarRentalClient_CarRentalClient
\end{verbatim}
\end{small}
% $ 

The advantage here is that development of local components is separated from
client development. 
While components can be implemented in independently by different developers, an
application (or client) can use deployed components from a repository.


\newpage
%------------------------------------------------------------------------------
\subsubsection{Uninstall the {\tt CarRental} client}
%------------------------------------------------------------------------------

To remove the client from the {\tt Confix} install repository, type:

\begin{small}
\begin{verbatim}
> confix.py --packageroot=`pwd`/client --make --target=uninstall
\end{verbatim}
\end{small}




%------------------------------------------------------------------------------
\subsubsection{Uninstall the {\tt CarRental} component}
%------------------------------------------------------------------------------

To remove the component from the {\tt Confix} install repository, type:

\begin{small}
\begin{verbatim}
> confix.py --packageroot=`pwd`/server --make --target=uninstall
\end{verbatim}
\end{small}

Installing is not necessary during component development. 
For implementing test cases and business logic we only need the source and
build directory (specified by {\tt BUILDROOT} in {\tt ~/.confix}).
 
