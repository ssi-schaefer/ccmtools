%$Id$

%==============================================================================
\chapter{CCM Tools Commands}
%==============================================================================

%------------------------------------------------------------------------------
\section{ccmtools-generate}
%------------------------------------------------------------------------------

\begin{description}

\item [NAME:] 
  {\tt ccmtools-generate} - Frontend to start available CCM Tools generators.

\item [SYNOPSIS:] 
  {\tt ccmtools-generate TYPE [OPTIONS] FILES}

\item [DESCRIPTION:]
The {\tt ccmtools-generate} script is used to run a particular component generator 
backend based on a set of IDL files. 
Depending on {\tt TYPE} and {\tt OPTIONS} a particular code generator is selected 
to create the desired output.

\item [TYPE:]
  Currently, the following generator types are supported:
  \begin{itemize}
  \item {\tt c++local}\\
    Generates local C++ component logic.
    
  \item {\tt c++local-test} \\
    Generates a test client for a pair of local C++ component and
    mirror component.
    
  \item {\tt c++dbc} \\
    Generates a set of Design by Contract adapters for a local
    C++ component.
    
  \item {\tt idl3 }\\
    Generates IDL3 source files.

  \item {\tt idl3mirror }\\
    Generates IDL3 source files for a mirror component.
    
  \item {\tt idl2} \\
    Generates equivalent IDL2 source files.

  \item {\tt c++remote} \\ 
    Generates a set of remote C++ adapters that establish a standard
    compliant CORBA component where a local C++ component can be embedded.

  \item {\tt c++remote-test}\\
    Generates a test client for a pair of remote component and mirror component.
  \end{itemize}
  
\item [OPTIONS:]
  In addition to the generator types, the {\tt ccmtools-generate} script handles
  the following options:
  \begin{itemize}
  \item {\tt -a, --application} \\
    Forces the local C++ generator to create business logic
    implementation skeletons ({\tt *\_app.*} files).

  \item {\tt -h, --help} \\
    Prints out a short description of the available command line parameters.

  \item {\tt -Ipath} \\
    Specifies a path that will be handled from a preprocessor to find 
    included IDL files.

  \item {\tt -o DIR, --output=DIR} \\
    Specifies the directory where the generated code will be written. 

  \item {\tt -V, --version} \\
    Prints out the current version of installed CCM Tools.
  \end{itemize}
  
\item [FILES:]
  This {\tt ccmtools-generate} script can handle single IDL files or a list of IDL
  files. The following examples show the usage of IDL files: 
  \begin{verbatim}
    ccmtools-generate idl3mirror -o test/idl3mirror Test.idl
    ccmtools-generate c++local -a -o test Test.idl Helper.idl 
    ccmtools-generate c++local-test -o test *.idl
  \end{verbatim}

\item [SEE ALSO:]
  {\tt ccmtools-c++-generate}
  
\end{description}


%------------------------------------------------------------------------------
\section{ccmtools-c++-generate}
%------------------------------------------------------------------------------
\begin{description}

\item [NAME:] 
  {\tt ccmtools-c++-generate} - Run a sequence of generator calls.

\item [SYNOPSIS:] 
  {\tt ccmtools-C++-generate [OPTIONS] FILES}

\item [DESCRIPTION:]
  The {\tt ccmtools-c++-generate} script collects a sequence of 
  generator calls. 
  Thus, this script makes component development more convenient,
  but less flexible.   


\item [OPTIONS:]
  The {\tt ccmtools-c++-generate} script handles the following options:
  \begin{itemize}
  \item {\tt -a, --application} \\
    Forces the local C++ generator to create business logic
    implementation skeletons ({\tt *\_app.*} files).

  \item {\tt -d, --development} \\
    Using this option, for a given IDL a component, its mirror component
    and a test client will be generated.

  \item {\tt -h, --help} \\
    Prints out a short description of the available command line parameters.

  \item {\tt -Ipath} \\
    Specifies a path that will be handled from a preprocessor to find 
    included IDL files.

  \item {\tt -p NAME, --package=NAME} \\
    Specifies the directory where the generated code will be written. 
    This directory is also a package in terms of Confix.  

  \item {\tt -V, --version} \\
    Prints out the current version of installed CCM Tools.
  \end{itemize}
  
\item [FILES:]
  This {\tt ccmtools-c++-generate} script can handle single IDL files or a list of IDL
  files. The following examples show the usage of IDL files: 
  \begin{verbatim}
    ccmtools-c++-generate idl3mirror -o test/idl3mirror Test.idl
    ccmtools-generate c++local -a -o test Test.idl Helper.idl 
    ccmtools-generate c++local-test -o test *.idl
  \end{verbatim}

\item [SEE ALSO:]
  {\tt ccmtools-generate}
  
\end{description}


%------------------------------------------------------------------------------
\section{ccmtools-c++-configure}
%------------------------------------------------------------------------------
\begin{description}

\item [NAME:] 
  {\tt ccmtools-c++-configure} - Run Confix to configure the generated code.

\item [SYNOPSIS:] 
  {\tt ccmtools-C++-configure OPTION}

\item [DESCRIPTION:]
  The {\tt ccmtools-c++-configure} script is a Confix wrapper, and
  represents the following Confix call:
  \begin{small}
  \begin{verbatim}
  confix.py  --packageroot=NAME --profile="ccmtools" \
             --bootstrap --configure --quiet
  \end{verbatim}
  \end{small}
  This script makes component development more convenient,
  but less flexible. 

\item [OPTION:]
  The {\tt ccmtools-c++-configure} script needs one of the following options:
  \begin{itemize}
  \item {\tt -h, --help} \\
    Prints out a short description of the available command line parameters.

  \item {\tt -p NAME, --package=NAME} \\
    Specifies the Confix package we want to configure. 

  \item {\tt -V, --version} \\
    Prints out the current version of installed CCM Tools.
  \end{itemize}
  
\item [SEE ALSO:]
  {\tt Confix manual}
  
\end{description}


%------------------------------------------------------------------------------
\section{ccmtools-c++-make}
%------------------------------------------------------------------------------
\begin{description}

\item [NAME:] 
  {\tt ccmtools-c++-make} - Run Confix to build the generated code.

\item [SYNOPSIS:] 
  {\tt ccmtools-C++-make OPTION}

\item [DESCRIPTION:]
  The {\tt ccmtools-c++-make} script is a Confix wrapper and
  represents the following Confix call:
  \begin{small}
  \begin{verbatim}
  confix.py  --packageroot=NAME --profile="ccmtools" \
             --make --targets="all check" --quiet    
  \end{verbatim}
  \end{small}
  This script makes component development more convenient,
  but less flexible. 

\item [OPTION:]
  The {\tt ccmtools-c++-make} script needs one of the following options:
  \begin{itemize}
  \item {\tt -h, --help} \\
    Prints out a short description of the available command line parameters.

  \item {\tt -p NAME, --package=NAME} \\
    Specifies the Confix package we want to build. 

  \item {\tt -V, --version} \\
    Prints out the current version of installed CCM Tools.
  \end{itemize}
  
\item [SEE ALSO:]
  {\tt Confix manual}
  
\end{description}


%------------------------------------------------------------------------------
\section{ccmtools-c++-install}
%------------------------------------------------------------------------------
\begin{description}

\item [NAME:] 
  {\tt ccmtools-c++-install} - Run Confix to install the generated code.

\item [SYNOPSIS:] 
  {\tt ccmtools-C++-install OPTION}

\item [DESCRIPTION:]
  The {\tt ccmtools-c++-install} script is a Confix wrapper and
  represents the following Confix call:
  \begin{small}
  \begin{verbatim}
   confix.py  --packageroot=NAME --profile="ccmtools" \
              --make --targets="install" --quiet
  \end{verbatim}
  \end{small}
  This script makes component development more convenient,
  but less flexible. 

\item [OPTION:]
  The {\tt ccmtools-c++-install} script needs one of the following options:
  \begin{itemize}
  \item {\tt -h, --help} \\
    Prints out a short description of the available command line parameters.

  \item {\tt -p NAME, --package=NAME} \\
    Specifies the Confix package we want to install. 

  \item {\tt -V, --version} \\
    Prints out the current version of installed CCM Tools.
  \end{itemize}
  
\item [SEE ALSO:]
  {\tt Confix manual}
  
\end{description}



%------------------------------------------------------------------------------
\section{ccmtools-c++-uninstall}
%------------------------------------------------------------------------------

\begin{description}

\item [NAME:] 
  {\tt ccmtools-c++-uninstall} - Run Confix to uninstall the generated code.

\item [SYNOPSIS:] 
  {\tt ccmtools-C++-uninstall OPTION}

\item [DESCRIPTION:]
  The {\tt ccmtools-c++-uninstall} script is a Confix wrapper and
  represents the following Confix call:
  \begin{small}
  \begin{verbatim}
   confix.py  --packageroot=NAME --profile="ccmtools" \
              --make  --targets="uninstall distclean" --quiet
  \end{verbatim}
  \end{small}
  This script makes component development more convenient,
  but less flexible. 

\item [OPTION:]
  The {\tt ccmtools-c++-uninstall} script needs one of the following options:
  \begin{itemize}
  \item {\tt -h, --help} \\
    Prints out a short description of the available command line parameters.

  \item {\tt -p NAME, --package=NAME} \\
    Specifies the Confix package we want to uninstall. 

  \item {\tt -V, --version} \\
    Prints out the current version of installed CCM Tools.
  \end{itemize}
  
\item [SEE ALSO:]
  {\tt Confix manual}
  
\end{description}


%------------------------------------------------------------------------------
\section{ccmtools-idl}
%------------------------------------------------------------------------------

\begin{description}

\item [NAME:] 
  {\tt ccmtools-idl} - Run an IDL compiler to generate CORBA stub and skeletons.

\item [SYNOPSIS:] 
  {\tt ccmtools-idl OPTION FILES}

\item [DESCRIPTION:]
  The {\tt ccmtools-idl} script is a IDL compiler wrapper for Mico ORB and Java ORB,
  and hides the different call notations. This script also allows to process more than
  one IDL file at the same time. 
  Note that this script assumes that both IDL compilers are installed correctly.

\item [OPTION:]
  The {\tt ccmtools-idl} script supports of the following options:
  \begin{itemize}
  \item {\tt -h, --help} \\
    Prints out a short description of the available command line parameters.

  \item {\tt -Ipath} \\
    Specifies a path that will be handled from a preprocessor to find 
    included IDL files.
   
  \item {\tt --mico} \\
    Forces the use of Mico's IDL compiler.
    Thus, the generated stub and skeletons are implemented in C++.

  \item {\tt --java} \\
    Forces the use of Java's build in IDL compiler.
    Thus, the generated stub and skeletons are implemented in Java.
    Note that Java's IDL compiler only supports CORBA 2.x but no CORBA 3.0 extensions
    like {\tt component}, {\tt home}, etc.

  \item {\tt -V, --version} \\
    Prints out the current version of installed CCM Tools.
  \end{itemize}
  
\item [FILES:]
  This {\tt ccmtools-idl} script can handle single IDL files or a list of IDL
  files. The following examples show the usage of IDL files: 
  \begin{verbatim}
    ccmtools-idl --mico CarRental.idl
    ccmtools-idl --java CarRental.idl Customer.idl
    ccmtools-idl --mico *.idl
  \end{verbatim}

\item [SEE ALSO:]
  {\tt Mico manual, Java IDL documentation}
\end{description}


%------------------------------------------------------------------------------
\section{uml2idl}
%------------------------------------------------------------------------------

\begin{description}

\item [NAME:] 
  {\tt uml2idl} - Convert an UML XMI file into an IDL and an OCL file. 

\item [SYNOPSIS:] 
  {\tt uml2idl XMI-FILE PREFIX}

\item [DESCRIPTION:]
  The {\tt uml2idl} script runs a Java program that converts a UML diagram stored
  in an XMI 1.1 file into corresponding IDL and OCL files.
  The IDL file is created in respect to the {\it CCM Profile for CCM}, while the
  OCL file collects all OCL expressions defined in the UML diagram.

\item [XMI-FILE:]
  That's the name of the input XMI 1.1 file which holds the UML class diagram
  (e.g. when using MagicDraw, the file name looks like {\tt Name.xml.zip}).

\item [PREFIX:]
  The generated IDL and OCL files are named {\tt PREFIX.idl} and {\tt PREFIX.ocl}.

\item [SEE ALSO:]
  {\tt UML Profile for CORBA, UML Profile for CCM}
  
\end{description}
