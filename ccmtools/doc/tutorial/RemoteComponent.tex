% $Id$

%==============================================================================
\chapter{Remote Components}
%==============================================================================

%------------------------------------------------------------------------------
\section{Overview}
%------------------------------------------------------------------------------

After implementing and using local components, let's have a look at remote
components. 
While the CCM specification describes only remote components that are
accessible from CORBA clients,  
the goal of CCM--Tools is to support local components that can be put 
transparently into remote CCM components.
You can connect remote components (generated by the CCM-Tools) with any other 
CCM components (e.g. components generated by MicoCCM).

\begin{figure}[!htb]
    \begin{center}
        \includegraphics [width=7cm,angle=0] {LCAC_Overview}
        \caption{Local component adapter}
        \label{LcacOverview}
    \end{center}
\end{figure}

\noindent
An existing local component can fit into a remote component using adapter
classes, as shown in figure \ref{LcacOverview}. For each CORBA interface
of a remote component a adapter delegates the method calls to the local 
equivalent.
To get more information about the {\bf Local Component Adapter Concept} (LCAC)
see the Appendix of this document.

%------------------------------------------------------------------------------
\section{The designer's job}
%------------------------------------------------------------------------------

Of course, developing remote CORBA components starts with an IDL file. In fact, the
IDL comes from the CORBA stuff, and has already been used for local component 
development. 
To generate a remote layer around a local component, we can use existing IDL
files.
  
\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
interface Console {
  long println(in string s);
};

component Hello {
  attribute string prompt;
  provides Console console;
};

home HelloHome manages Hello {
};
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Reusing the local component's IDL definition}
\label{example:one-component-idl}
\end{Example}


%------------------------------------------------------------------------------
\section{The developer's job}
%------------------------------------------------------------------------------

The basic idea is that a component developer always implements a local component.
Business logic is implemented in respect to the local component's programming
model without any CORBA in mind (and code ;-).
Thus, we start with implementing a local component as shown before:
\begin{small}
\begin{verbatim}
~/hello> ccmtools-c++-generate -d -c 2.0 -p hello2.0 Hello.idl
~/hello> ccmtools-c++-configure -p hello2.0
~/hello> ccmtools-c++-make -p hello1.0
\end{verbatim}
\end{small}

We implement the component's test, write the business logic, run the test and so on.
Remember, this iterative programming style forces short turn around cycles that are
not possible in a pure CORBA component environment.



%------------------------------------------------------------------------------
\subsection{Set up remote component environment}
%------------------------------------------------------------------------------

The remote components need some libraries, header and IDL files to run. All these
stuff can be generated, compiled and installed, using the following script: 
\begin{small}
\begin{verbatim}
~/hello> ccmtools-c++remote-environment
\end{verbatim}
\end{small}
	
\noindent
Note that the CCM--Tools need the {\bf Mico ORB}, {\bf IDL compiler} and 
{\bf NameService} to generate, build and run remote components.

 

%------------------------------------------------------------------------------
\subsection{Create the remote layer}
%------------------------------------------------------------------------------

To add a remote layer to an existing local component, we have to generate the
CORBA stubs and remote component adapters that join the CORBA objects with the
local component implementation.
All this code is generated using the following script:

\begin{small}
\begin{verbatim}
~/hello> ccmtools-c++remote-generate -d -p hello1.0 Hello.idl
\end{verbatim}
\end{small}
The {\tt ccmtools-c++remote-generate} script accepts the following command line
parameters:
\begin{itemize}
\item {\tt -d, -\-debug }\\
Enable debugging in generated code. The generated code produces a lot of debug
messages that can be used to trace the program execution. This also causes a
test client to be generated.

\item {\tt -p NAME, -\-package=NAME}\\
Set package name to NAME. The default package name is ``ccmtools-package''. Note
that the package name is used for the name of the generated subdirectory, unless
you override this behavior with the {\tt -o} option.

\item {\tt -h, -\-help}\\
Print out a short description of the available command line parameters.
\end{itemize}


\noindent
Beside the already existing directories and files of the local component code, 
now there are some new directories that contains the code for CORBA stubs and 
the remote component adapters.
Additionally, a second test file ({\tt \_check\_CCM\_Session\_*\_remote.cc}) is
created.

\begin{small}
\begin{verbatim}
    hello/
    |-- Hello.idl
    |-- _check_CCM_Session_Hello_remote.cc
    |-- hello1.0/
    |   |-- CCM_Session_Hello_remote
    |   |-- CCM_Test
    |   |-- idl2
\end{verbatim}
\end{small}

\noindent
We can build the local component code as well as the remote code with the
following commands:
\begin{small}
\begin{verbatim}
~/hello> ccmtools-c++-configure -p hello1.0
~/hello> ccmtools-c++-make -p hello1.0
\end{verbatim}
\end{small}
After the configure and build process, the local and the remote component tests
are started.
For the remote component test we use the CORBA collocation mechanism. Thus the 
generator  can implement the server and client code in a single test file.
Remember that to run the remote test a CORBA NameService must be established.


%------------------------------------------------------------------------------
\subsection{Deploy the remote component}
%------------------------------------------------------------------------------

To install the generated remote component library and header files in the
component repository, we can use the known CCM--Tools script:
\begin{verbatim}
~/hello> ccmtools-c++-install -p hello1.0
\end{verbatim}

\noindent
Applications can use the repository to access local or remote components 
like ordinary libraries.


%------------------------------------------------------------------------------
\subsection{Write a remote client and server}
%------------------------------------------------------------------------------

A remote component must be activated within a CORBA server application that
includes the header files of the ORB, the CORBA stubs and the remote
component.
\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
#include <CORBA.h>
#include <coss/CosNaming.h>

#include <CCM_Utils/Debug.h>
#include <CCM_Remote/CCM_Session_Hello/HelloHome_remote.h>
#include <Hello.h>

using namespace std;
using namespace CCM_Utils;
\end{verbatim}
\end{small}
\end{minifbox}
\caption{CORBA and remote component header files.}
\label{ServerHeaderFiles}
\end{Example}

\noindent
The remote {\tt Hello} component can be activated using the generated {\tt deploy\_HelloHome()} 
function. The first parameter is the initialized ORB object and the second parameter
defines the name of the component's home. This name is used to register the component's
home in the CORBA NameService. 
\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
int main (int argc, char *argv[])
{
  // Set debugging mode
  Debug::set_global(true); 

  // Initialize ORB and value type factories
  CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);
  CCM::register_all_factories (orb);

  int error = deploy_HelloHome(orb, "HelloHome:1.0");
  if(!error) {
    cout << "Component is running..." << endl;
  }
  else {
    cerr << "ERROR: Can't start components!" << endl;
    assert(0);
  }

  // Wait for CORBA requests
  orb.run();
}
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Remote component activation.}
\label{RemoteComponentServer}
\end{Example}

\noindent
Note that the ORB must be initialized and started before a remote component
can be accessed from a CORBA client.

\noindent
The remote client also has to initialize the ORB and the CORBA NameService,
as shown in Example \ref{ClientInit}.
\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
int main (int argc, char *argv[])
{
  Debug::set_global(true); 

  // Initialize ORB 
  CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);
  CORBA::Object_var obj = 
    orb->resolve_initial_references ("NameService");
  CosNaming::NamingContextExt_var nc = 
    CosNaming::NamingContextExt::_narrow (obj);
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Initialize the client's ORB and NameService.}
\label{ClientInit}
\end{Example}

From the CORBA NameService, the client gets a reference to the 
remote component's home. 
After narrowing the CORBA reference to the particular home type, 
the {\tt create()} method is used to get a component instance.
From the component instance we get a {\tt Console} facet reference, 
and set the {\tt prompt} attribute. 
A {\tt configuration\_complete()} call finishes the component 
configuration.

\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
  // Find ComponentHomes in the Naming-Service
  obj = nc->resolve_str ("HelloHome:1.0");
  HelloHome_var myHelloHome = HelloHome::_narrow (obj);

  // Create component instances
  Hello_var myHello =  myHelloHome->create();

  // Provide facets   
  Console_var console = myHello->provide_console();
	
  // Configure the component's attribute
  myHello->prompt("=->");

  // Component configuration finished	
  myHello->configuration_complete();
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Creating the remote component and facet.}
\label{CreatingRemoteComponent}
\end{Example}

\noindent 
Now the remote client can use the component instance to call methods on
the component's equivalent interface and the supported facet.
%Every client request is forwarded to a CORBA object on the server side
%that workes as an adapter to the local component implementation. 
\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
  // Call operations on the component and its facets
  cout << "Version = " << 
    myHello->getComponentVersion() << endl;
  cout << "Date = " << 
    myHello->getComponentDate() << endl;

  console->println("Hello from the remote client");
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Calling the remote component methods.}
\label{RemoteMethodCalling}
\end{Example}

\noindent
Finally, the remote client removes the component instance on the server side
and exits from the main function.

\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
  // Destroy component instances
  myHello->remove();
}
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Destroy component instance.}
\label{DestroyComponent}
\end{Example}



%------------------------------------------------------------------------------
\subsection{Undeploy the remote component}
%------------------------------------------------------------------------------

To remove the component's libraries and header files from the repository, 
call:
\begin{verbatim}
~/hello> ccmtools-c++-uninstall -p hello1.0
\end{verbatim}
Remember, only the installed libraries and header files are deleted while
the developers source code remains untouched.



%------------------------------------------------------------------------------
%\subsection{Remote component packaging}
%------------------------------------------------------------------------------