% $Id$
%==============================================================================
\chapter{First Components}
%==============================================================================


%------------------------------------------------------------------------------
\section{Component development process overview}
%------------------------------------------------------------------------------

This section shows how to implement a simple component using the CCM
Tools. 

Before you start with component development, make sure that the CCM Tools are
installed in a proper way, as described in Appendix A.

\begin{figure}[htbp]
    \begin{center}
        \includegraphics [width=10cm,angle=0] {DevelopmentProcess}
        \caption{Component development process}
        \label{fig:development-process}
    \end{center}
\end{figure}

As shown in Fig.~\ref{fig:development-process}, the development process defines
different roles that reflect different abstraction levels of components:
\begin{description}
\item [Component Designer]
specifies the structure of the component by defining an {\it Interface
Description Language} (IDL) File. The interfaces defined in the IDL source
file(s) are only syntax definitions and do not describe the behavior of the
component. These IDL declarations merely specify the methods that a component is
required to implement. In this way, an IDL file is a sort of protocol
definition for a component.

\item [Component Developer]
implements the behavior of the component with respect to the defined interfaces.
\end{description}

The CCM Tools support this development process by providing an IDL parser and
different code generators. Each component has two logical parts, and generated
code is used in both parts:
\begin{description}
\item [Component Logic]
is the implementation of the component's structure. It contains mechanisms to
create and destroy component instances, as well as access and navigation methods
for finding and manipulating ports and attributes. This code can be completely
generated from the IDL description.

\item [Business Logic]
is the implementation of the component's behavior with respect to the
application domain. Generator tools can create skeleton code, but the component
developer must implement the business code.

Happily, the component developer need not be a CORBA guru to implement these
functions: Generated remote (out--of--process) component logic can handle the
interface with a CORBA server.

Also, because of the nature of a component based application, the component
developer should not implement a given component's business logic with an entire
application in mind. Components are, on the contrary, meant to encapsulate well
defined logical processes without caring about the overall structure of the
application environment.
\end{description}

Finally, the CCM Tools make use of the Confix build tool to create a library
from the generated (component logic) and hand-crafted (business logic) source
code. The component libraries are stored in a component repository on the server
side and are used to assemble modular, component based applications.

\newpage


%------------------------------------------------------------------------------
\section{The designer's job}
%------------------------------------------------------------------------------

Let's start to design the first component. 
In the rolle of a component designer,
we have to create a bunch of IDL files that describes a component's structure
(Fig~\ref{fig:component-design}). 

\begin{figure}[htbp]
    \begin{center}
        \includegraphics [width=4cm,angle=0] {DesignerTask}
        \caption{Component design}
        \label{fig:component-design}
    \end{center}
\end{figure}

As a simple example, we model a car rental component that can handle customers
and miles. For each customer we can evaluate driven miles and costs incurred. 
Of course, this is not a real world application, but this example is
well suited to demonstrate CCM Tools in action.


We will store all created IDL files in a {\tt example1} directory:
\begin{small}
\begin{verbatim}
        example1/
        |-- Exceptions.idl
        |-- Customer.idl
        |-- CustomerMaintenance.idl
        |-- CustomerBusiness.idl
        `-- CarRental.idl
\end{verbatim}
\end{small}

Keep in mind that IDL files contain no specification of what exact action will be
performed.
The component developer bears the responsibility of filling in the functionality after
the component logic has been generated.


\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
#ifndef __EXCEPTIONS_IDL__
#define __EXCEPTIONS_IDL__

module BigBusiness {
  exception CreateCustomerException{};
  exception RemoveCustomerException{};
  exception NoCustomerException{};
}; // End of module BigBusiness

#endif
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Exceptions.idl}
\label{example:Exceptions}
\end{Example}
The first code snippet (example \ref{example:Exceptions}) shows the definition of three 
IDL exceptions.
In order to get a namespace, we envelop these definitions using a module called 
BigBusiness. 
To prevent IDL files from multiple includings, we define include guards within 
each source file.


\newpage
 
\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
#ifndef __CUSTOMER_IDL__
#define __CUSTOMER_IDL__

module BigBusiness {
  struct Customer {
    long id;
    string first_name;
    string last_name;
    double mileage;
  };
  typedef sequence<Customer> CustomerList;
}; // End of module BigBusiness

#endif
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Customer.idl}
\label{example:Customer}
\end{Example}

In {\tt Customer.idl}, we define a structure of basic 
data types and a sequence of this structure type.
Again, there is a BigBusiness module and an include guard.

\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
#ifndef __CUSTOMER_MAINTENANCE_IDL__
#define __CUSTOMER_MAINTENANCE_IDL__

#include"Exceptions.idl"
#include"Customer.idl"

module BigBusiness {
  interface CustomerMaintenance
  {
    void createCustomer(in Customer person) 
      raises (CreateCustomerException);
    Customer retrieveCustomer(in long id)  
      raises (NoCustomerException);
    CustomerList retrieveAllCustomers()  
      raises (NoCustomerException);
    void updateCustomer(in Customer person)  
      raises (NoCustomerException);
    void deleteCustomer(in long id)  
      raises (RemoveCustomerException);
  };
}; // End of module BigBusiness
#endif
\end{verbatim}
\end{small}
\end{minifbox}
\caption{CustomerMaintenance.idl}
\label{example:}
\end{Example}
Customers must be handled in a database like way. Thus, {\tt CustomerMaintenance.idl} 
contains a Create, Retrieve, Update and Delete (CRUD) interface. 
To pick a particular Customer, we use a Customer id that is realized as an IDL long type.
Methods can throw exceptions in the case of illegal Customer ids, create or remove problems. 

\newpage

\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
#ifndef __CUSTOMER_BUSINESS_IDL__
#define __CUSTOMER_BUSINESS_IDL__

#include "Exceptions.idl"

module BigBusiness {
  interface CustomerBusiness
  {
    attribute double dollars_per_mile;
    void addCustomerMiles(in long id, in double miles) 
      raises(NoCustomerException);
    void resetCustomerMiles(in long id) 
      raises(NoCustomerException);
    double getCustomerMiles(in long id) 
      raises(NoCustomerException);
    double getCustomerDollars(in long id) 
      raises(NoCustomerException);
  };
}; // End of module BigBusiness
#endif
\end{verbatim}
\end{small}
\end{minifbox}
\caption{CustomerBusiness.idl}
\label{example:}
\end{Example}

Beside the pure data manipulation, we also need an interface that defines a
business functionality.
{\tt CustomerBusiness.idl} defines an attribute and some methods that operate
on the given Customer data. 
If a parameter represents a wrong Customer id, the {\tt NoCustomerException}
will be thrown.

\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
#ifndef __CAR_RENTAL_IDL__
#define __CAR_RENTAL_IDL__

#include "CustomerMaintenance.idl"
#include "CustomerBusiness.idl"

module BigBusiness {

  component CarRental 
  { 
    provides CustomerMaintenance maintenance;
    provides CustomerBusiness business;
  };
  
  home CarRentalHome manages CarRental 
  { };

}; // End of module BigBusiness
#endif
\end{verbatim}
\end{small}
\end{minifbox}
\caption{CarRental.idl}
\label{example:}
\end{Example}

Finally, we collect the included interfaces to a {\tt CarRental} component and 
define a {\tt CarRentalHome} that will be used to create component instances at
runtime.

Well done! We have defined our first component in terms of IDL.


\newpage

%------------------------------------------------------------------------------
\section{The developer's job}
%------------------------------------------------------------------------------

Remember, the component developer implements the behavior of the component with
respect to the defined IDL interfaces (Fig.~\ref{fig:component-development}). 
\begin{figure}[htbp]
    \begin{center}
        \includegraphics [width=8cm,angle=0] {DeveloperTask}
        \caption{Component development}
        \label{fig:component-development}
    \end{center}
\end{figure}

This section shows how the CCM Tools make this job easier.

%------------------------------------------------------------------------------
\subsection{Create component logic from IDL}
%------------------------------------------------------------------------------


To generate source code from IDL files, we type:
\begin{small}
\begin{verbatim}
~/example1> ccmtools-generate c++local -a -o CarRental *.idl
\end{verbatim}
\end{small}

Now, we have a new subdirectory ({\tt CarRental}) that contains the generated code. 
(To get a description of all {\tt ccmtools-generate} options consult the CCM Tools
commands section in the tutorial's appendix).
\begin{small}
\begin{verbatim}
CarRental
|-- CCM_Local_BigBusiness
|-- CCM_Local_BigBusiness_CCM_Session_CarRental
|-- CCM_Local_BigBusiness_CCM_Session_CarRental_share
`-- src
    |-- CarRentalHome_app.cc
    |-- CarRentalHome_app.h
    |-- CarRentalHome_entry.h
    |-- CarRental_app.cc
    |-- CarRental_app.h
    `-- Makefile.py
\end{verbatim}
\end{small}

The component developer really ought not to care about the generated {\tt CCM\_Local\_*}
subdirectories (if you don't believe us, though, feel free to read
through it; just don't edit anything). 
The interesting files are listed in the {\tt src} directory. These files contain skeleton
code of the component's business logic.

\begin{itemize}
\item {\tt CarRentalHome\_entry.h} \\
This file is the business logic's entry point and declares an extern ``C'' function 
that returns a component home instance.
The generated implementation of this function is hosted in the 
{\tt CarRentalHome\_app.cc} file.

\item {\tt CarRentalHome\_app.[h,cc]} \\
These files contain the factory methods for component instantiation. 
While user defined factory methods must be implemented manually, the default 
{\tt create()} method is already generated.

\item {\tt CarRental\_app.[h,cc]} \\
These files contain the component's business logic skeletons and are intended
for developer extensions (grep for {\tt // TODO : IMPLEMENT ME HERE !}).

\item {\tt Makefile.py} \\
This file is a confix marker that denotes a directory as 'to compile'.
\end{itemize}

Files in the {\tt src} directory are protected from overwriting.
Running the {\tt ccmtools-generator} again results in a bunch of warnings. 
Instaed of overwriting, the generator stores the new files with an extension ({\tt *.new}). 

\vspace{3mm}
The generated business logic skeletons contains enough code to be compilable.
To build the generated source code, we use an open source build tool called Confix:
\begin{small}
\begin{verbatim}
~/example1> confix.py --packageroot=`pwd`/CarRental \
                      --bootstrap --configure --make
\end{verbatim}
\end{small}


%------------------------------------------------------------------------------
\subsection{Test driven development}
%------------------------------------------------------------------------------

Software development is an iterative process. Kent Beck~\cite{Beck2003TDD}
proposed a {\it Test Driven Development} (TDD) methodology that starts by
implementing the test~-- before implementing the application!

\begin{figure}[!htb]
    \begin{center}
        \includegraphics [width=6cm,angle=0] {TestDrivenDevelopment}
        \caption{Test driven development process}
        \label{fig:test-driven-development}
    \end{center}
\end{figure}

As shown in Fig.~\ref{fig:test-driven-development}, the CCM Tools make use of
the TDD idea in the context of components. For every component $C$, we
generate a mirror component $\overline{C}$. Each input port (receptacle)
of $C$ corresponds to an output port (facet) of $\overline{C}$, and vice versa.

To convert the given IDL3 files into files for a mirror component $\overline{C}$, type:
\begin{small}
\begin{verbatim}
~/example1> ccmtools-generate idl3mirror \
                              -o CarRental/idl3mirror *.idl
\end{verbatim}
\end{small}

Now we can use the known {\tt c++local} generator to create C++ component logic 
from the IDL3 mirror files.
To convert the given IDL3 files into files for a mirror component $\overline{C}$, type:
\begin{small}
\begin{verbatim}
~/example1> ccmtools-generate c++local -a -o CarRental   \
                              -ICarRental/idl3mirror     \
                              CarRental/idl3mirror/*.idl
\end{verbatim}
\end{small}

Finally, a test client coordinates creating and connecting of component $C$ and 
mirror component $\overline{C}$.
To generate a test client we type:
\begin{small}
\begin{verbatim}
~/example1> ccmtools-generate c++local-test -o CarRental *.idl
\end{verbatim}
\end{small}

After all these steps, the current {\tt CarRental} directory contains the following
enities:
\begin{small}
\begin{verbatim}
CarRental
|-- CCM_Local_BigBusiness
|-- CCM_Local_BigBusiness_CCM_Session_CarRental
|-- CCM_Local_BigBusiness_CCM_Session_CarRental_mirror
|-- CCM_Local_BigBusiness_CCM_Session_CarRental_mirror_share
|-- CCM_Local_BigBusiness_CCM_Session_CarRental_share
|-- idl3mirror
|-- src
|   |-- CarRentalHome_app.cc
|   |-- CarRentalHome_app.h
|   |-- CarRentalHome_entry.h
|   |-- CarRentalHome_mirror_app.cc
|   |-- CarRentalHome_mirror_app.h
|   |-- CarRentalHome_mirror_entry.h
|   |-- CarRental_app.cc
|   |-- CarRental_app.h
|   |-- CarRental_mirror_app.cc
|   |-- CarRental_mirror_app.h
|   `-- Makefile.py
`-- test
    |-- Makefile.py
    `-- _check_CCM_Local_BigBusiness_CCM_Session_CarRental.cc
\end{verbatim}
\end{small}

In the {\tt src} and {\tt test} directories, there are the generated files of the mirror
component's business logic and the test client:
\begin{itemize}
\item {\tt CarRentalHome\_mirror\_entry.h} \\
This file declares an extern ``C'' function 
that returns a mirror component home instance.

\item {\tt CarRentalHome\_mirror\_app.[h,cc]} \\
These files contain the factory methods for mirror component instantiation. 

\item {\tt CarRental\_mirror\_app.[h,cc]} \\
These files contain the mirror component's business logic skeletons and are intended
for developer extensions.

\item {\tt \_check\_CCM\_Local\_BigBusiness\_CCM\_Session\_CarRental.cc} \\
This file contains the test client that connects $C$ and $\overline{C}$.  
Files in {\tt test} are also protected from overwriting.
\end{itemize}  




\newpage
%------------------------------------------------------------------------------
\subsection{Write the test first}
%------------------------------------------------------------------------------

Now is a good time to start the development of business code. First, we have to
define the behavior of the business code in an executable semantic. In other words, 
we write a test case in the mirror component ({\tt CarRental\_mirror\_app.cc}), as
shown in Example~\ref{example:one-component-mirror-impl}.

\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
void CCM_CarRental_mirror_impl::ccm_activate()
  throw ( LocalComponents::CCMException )
{
  try {
    {
      CCM_Local::BigBusiness::Customer person;
      person.id = 1;
      person.first_name = "Franz";
      person.last_name = "Kafka";
      ctx->get_connection_maintenance_mirror()->
           createCustomer(person);
    }
    {
      CCM_Local::BigBusiness::Customer person;
      long id = 1;
      person = ctx->get_connection_maintenance_mirror()->
               retrieveCustomer(id);
      assert(person.id == 1);
      assert(person.first_name == "Franz");
      assert(person.last_name == "Kafka");
    }
  }
  catch(CCM_Local::BigBusiness::CreateCustomerException) {
    cerr << "MAINTENANCE ERROR: Can't create customer!" << endl;
  }
  catch(CCM_Local::BigBusiness::NoCustomerException) {
    cerr << "MAINTENANCE ERROR: no customer found!" << endl;
  }
}
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Test case implementation in the mirror component.}
\label{example:one-component-mirror-impl}
\end{Example}

The test case is implemented in the {\tt ccm\_activate()} callback method of the
mirror component because this method is called after creating and connecting $C$
and $\overline{C}$ from the component logic. 

First, we creating a valid {\tt Customer} record and  
use the context object ({\tt ctx}) to get a smart pointer
to $\overline{C}$'s receptacle (which is connected with $C$'s facet) 
before we call the {\tt createCustomer()} operation. 
After that, we retrieve the record from the receptacle and compare the stored items.

To compile and run the test, we type:
\begin{small}
\begin{verbatim}
~/example1> confix.py --packageroot=`pwd`/CarRental \
                      --make --targets="check"
\end{verbatim}
\end{small}

The test failed!
Remember, there is no business code implemented in {\tt createCustomer()} and 
{\tt retrieveCustomer()}; they are empty function skeletons. 



%------------------------------------------------------------------------------
\subsection{Write the business logic}
%------------------------------------------------------------------------------

Now we are ready to implement the business logic that satisfies the written test
case. We open {\tt CarRental\_app.cc} and add some lines, as shown in
Example~\ref{example:one-component-impl}.

\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
void
maintenance_impl::createCustomer ( const Customer& person )
  throw (LocalComponents::CCMException, CreateCustomerException)
{
  component->CustomerDB.push_back(person);
}

Customer
maintenance_impl::retrieveCustomer ( const long id )
  throw (LocalComponents::CCMException, NoCustomerException)
{
  std::vector<CCM_Local::BigBusiness::Customer>::iterator pos;
  for(pos = component->CustomerDB.begin(); 
      pos != component->CustomerDB.end(); ++pos) {
    if(pos->id == id) {
      return *pos;
    }
  }
  throw NoCustomerException();
}
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Business logic implementation.}
\label{example:one-component-impl}
\end{Example}

Instead of a database, we simply use a {\tt std::vector<>} template to implement
the {\tt createCustomer()} and {\tt retrieveCustomer()} methods~-- that's it! 

We'll run the test again to see if it's working:
\begin{small}
\begin{verbatim}
~/example1> confix.py --packageroot=`pwd`/CarRental \
                      --make --targets="check"
\end{verbatim}
\end{small}

Yay, the test passed!

In the next step, we write a new test case in $\overline{C}$ and implement 
business logic in $C$ that satisfies the test, and so on.
To keep the tutorial clear, we have put the source code of the whole example
into the tutorial's Appendix.
The example is also available in the {\tt test/CppGenerator/tutorial}
directory of the CCM Tools project. 

\newpage
%------------------------------------------------------------------------------
\subsection{Deploy the component}
%------------------------------------------------------------------------------

Deploying a component means that the component's libraries and header files will 
be stored in a component repository, which is simply a directory on your computer
(specified by 'PREFIX' in {\tt ~/.confix}).

Component deployment is performed by Confix:
\begin{small}
\begin{verbatim}
~/example1> confix.py --packageroot=`pwd`/CarRental \
                      --make --targets="install"
\end{verbatim}
\end{small}

After installing a component, the component repository contains the following
file structures:
\begin{small}
\begin{verbatim}
include/
|-- CCM_Local
|   |-- BigBusiness
|   |   |-- CCM_Session_CarRental/
|   |   |-- CCM_Session_CarRental_mirror/
|   |   |-- CreateCustomerException.h
|   |   |-- Customer.h
|   |   |-- CustomerBusiness.h
|   |   |-- CustomerList.h
|   |   |-- CustomerMaintenance.h
|   |   |-- NoCustomerException.h
|   |   `-- RemoveCustomerException.h
\end{verbatim}
\end{small}

\begin{small}
\begin{verbatim}
lib/
|-- libCarRental_CCM_Local_BigBusiness.a
|-- libCarRental_CCM_Local_BigBusiness_CCM_Session_CarRental.a
|-- libCarRental_CCM_Local_BigBusiness_CCM_Session_CarRental_mirror.a
|-- libCarRental_CCM_Local_BigBusiness_CCM_Session_CarRental_mirror_share.a
|-- libCarRental_CCM_Local_BigBusiness_CCM_Session_CarRental_share.a
`-- libCarRental_src.a
\end{verbatim}
\end{small}




%------------------------------------------------------------------------------
\subsection{Undeploy the component}
%------------------------------------------------------------------------------

To remove the component from the component repository, type:

\begin{small}
\begin{verbatim}
~/example1>  confix.py --packageroot=`pwd`/CarRental \
                       --make --targets="uninstall distclean" 
\end{verbatim}
\end{small}

The optional parameter {\tt distclean} causes Confix to remove the
component's resources in the build directory too.

Note that installing is not necessary during component development. 
For implementing test cases and business logic we only need the source and
build directotry (specified by 'BUILDROOT' in {\tt ~/.confix}).
 


\newpage
%------------------------------------------------------------------------------
\subsection{Component packaging}
%------------------------------------------------------------------------------
\dots

%------------------------------------------------------------------------------
\subsection{Write a component client}
%------------------------------------------------------------------------------
\dots





 

