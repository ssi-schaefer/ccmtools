% $Id$
%==============================================================================
\chapter{First Components}
%==============================================================================


%------------------------------------------------------------------------------
\section{Overview}
%------------------------------------------------------------------------------

This section shows how to implement a simple hello world component using the CCM
Tools. Of course, this is not a real world application; creating a component
just for a hello world example is really structural overkill. But the example is
well suited to demonstrate the use of the CCM Tools.

\begin{figure}[htbp]
    \begin{center}
        \includegraphics [width=10cm,angle=0] {DevelopmentProcess}
        \caption{Component development process}
        \label{fig:development-process}
    \end{center}
\end{figure}

As shown in Fig.~\ref{fig:development-process}, the development process defines
different roles that reflect different abstraction levels of components.
\begin{description}
\item [Component Designer]
specifies the structure of the component by defining an {\it Interface
Description Language} (IDL) File. The interfaces defined in the IDL source
file(s) are only syntax definitions and do not describe the behavior of the
component. These IDL declarations merely specify the methods that a component is
required to implement. In this way, an IDL file is a sort of protocol
definition for a component.

\item [Component Developer]
implements the behavior of the component with respect to the defined interfaces.
\end{description}

The CCM Tools support this development process by providing an IDL parser and
different code generators. Each component has two logical parts, and generated
code is used in both parts:
\begin{description}
\item [Component Logic]
is the implementation of the component's structure. It contains mechanisms to
create and destroy component instances, as well as access and navigation methods
for finding and manipulating ports and attributes. This code can be completely
generated from the IDL description.

\item [Business Logic]
is the implementation of the component's behavior with respect to the
application domain. Generator tools can create skeleton code, but the component
developer must implement the business code.

Happily, the component developer need not be a CORBA guru to implement these
functions: Generated remote (out--of--process) component logic can handle the
interface with a CORBA server.

Also, because of the nature of a component based application, the component
developer should not implement a given component's business logic with an entire
application in mind. Components are, on the contrary, meant to encapsulate well
defined logical processes without caring about the overall structure of the
application environment.
\end{description}

Finally, the CCM Tools make use of the Confix build tool to create a library
from the generated (component logic) and hand-crafted (business logic) source
code. The component libraries are stored in a component repository on the server
side and are used to assemble modular, component based applications.

%------------------------------------------------------------------------------
\section{The designer's job}
%------------------------------------------------------------------------------

Let's start to implement the first component using the CCM Tools. We'll define
an IDL file named {\tt Hello.idl} (Example~\ref{example:one-component-idl}) that
describes the component's structure. In this example, our IDL source file is
stored in a {\tt hello} directory on our development machine.

\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
interface Console {
  long println(in string s);
};

component Hello {
  attribute string prompt;
  provides Console console;
};

home HelloHome manages Hello {
};
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Interface, component, and home definition for the hello world example.}
\label{example:one-component-idl}
\end{Example}

The IDL file defines a {\tt Console} interface that contains a {\tt println}
method. The {\tt Hello} component provides the {\tt console} interface as a
facet. This means the {\tt Hello} component will appear to external component
users as if it possess a method called {\tt println} that is only available at
certain times. In this case, the {\tt println} method will be available to
external components when some sort of receptacle speaking the {\tt Console}
interface is connected to the {\tt console} facet.

Keep in mind that the IDL file contains no specification of what exact action
this {\tt println} method will perform! The component developer bears the
responsibility of filling in the method functionality after the component code
has been generated. So although this method could theoretically perform any
task, most component developers would expect it to print out its string argument
and return something like the number of printed characters.

This component also has an attribute called {\tt prompt}. Just like the method,
the component's attribute could store any string; the IDL file contains no
information about the attribute other than its data type! Most likely, though,
it will store the command prompt for some user input. Finally, the {\tt
HelloHome} is defined to manage the {\tt Hello} component.

Thus, we have created the following file structure:
\begin{small}
\begin{verbatim}
        hello/
        |-- Hello.idl
\end{verbatim}
\end{small}

Well done! We have designed an example component and created the corresponding
IDL definitions. Note that the component designer normally defines the external
view of a component as a part of the whole application structure, so in a real
application there would be more components that would be capable of performing
other distinct actions in the application.

%------------------------------------------------------------------------------
\section{The developer's job}
%------------------------------------------------------------------------------

Remember, the component developer implements the behavior of the component with
respect to the defined interfaces. This section shows how the CCM Tools make
this job easier.

%------------------------------------------------------------------------------
\subsection{Set up component environment}
%------------------------------------------------------------------------------

Before we can develop components, we have to create the component's environment.
First, we create or extend the Confix configuration file {\tt \~/.confix} (see
the Confix manual for more details). An example Confix configuration file is
included in the CCM Tools source distribution, and
Example~\ref{example:confix-configuration} shows a basic template.
\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
ccmtools_profile = {
    'PREFIX': '<install-path>/ccmTools',
    'BUILDROOT': '/tmp',
    'ADVANCED': 'true',
    'CONFIX': {},
    'CONFIGURE': {
       'ENV': {},
       'ARGS': []
    },
}

PROFILES = {
    'ccmtools': ccmtools_profile,
    #...
}
\end{verbatim}
\end{small}
\end{minifbox}
\caption{A skeletal Confix configuration file.}
\label{example:confix-configuration}
\end{Example}

Next, we install the local C++ component runtime libraries:
\begin{small}
\begin{verbatim}
~/hello> ccmtools-c++-environment
\end{verbatim}
\end{small}
The libraries will be installed into the {\tt PREFIX} directory specified in
your Confix configuration. Note that the CCM Tools always use the ``ccmtools''
Confix profile.

That's it, now we are ready to implement components. Note that the component's
environment is installed only once for all the components we implement.

%------------------------------------------------------------------------------
\subsection{Create an empty component}
%------------------------------------------------------------------------------

To get the component logic and the skeletons of the business logic from the IDL
file, we start the local C++ code generator:
\begin{small}
\begin{verbatim}
~/hello> ccmtools-c++-generate -c 1.0 -d -p hello1.0 Hello.idl
\end{verbatim}
\end{small}

The {\tt ccmtools-c++-generate} call accepts a bunch of command line parameters.
In the example we only use a few to demonstrate the possibilities. An in depth
description of the CCM Tools is out of the scope this tutorial (see the {\it CCM
Tools User's Guide} instead), but here is a short description of the options we
used:
\begin{itemize}
\item {\tt -c VERSION, -\-code-version=VERSION }\\
Set the VERSION of generated code. The default component version is ``0.1.0''.
Note that the component's version number can be queried at runtime.

\item {\tt -d, -\-debug }\\
Enable debugging in generated code. The generated code produces a lot of debug
messages that can be used to trace the program execution. This also causes a
mirror test component and an example test client to be generated.

\item {\tt -p NAME, -\-package=NAME}\\
Set package name to NAME. The default package name is ``ccmtools-package''. Note
that the package name is used for the name of the generated subdirectory, unless
you override this behavior with the {\tt -o} option.

\item {\tt -h, -\-help}\\
Print out a short description of the available command line parameters.
\end{itemize}

After calling {\tt ccmtools-c++-generate}, we have a new subdirectory ({\tt
hello1.0}) that contains the generated component logic. Also, the skeletons for
the business logic have been copied into the current directory:
\begin{small}
\begin{verbatim}
  hello/
  |-- HelloHome_app.cc
  |-- HelloHome_app.h
  |-- HelloHome_mirror_app.cc
  |-- HelloHome_mirror_app.h
  |-- Hello_app.cc
  |-- Hello_app.h
  |-- Hello_mirror_app.cc
  |-- Hello_mirror_app.h
  |-- Hello.idl
  |-- Hello_user_types.h
  |-- _check_CCM_Session_Hello.cc
  |-- hello1.0/
\end{verbatim}
\end{small}

The component developer really ought not to care about the generated component
logic in the subdirectory (if you don't believe us, though, feel free to read
through it; just don't edit anything). The interesting files are in the current
directory. These files are as follows:
\begin{itemize}
\item {\tt HelloHome\_app.[h,cc]} \\
Contain the factory methods for component creation. Note that the default {\tt
create()} method is already implemented.
\item {\tt Hello\_app.[h,cc]} \\
Contain the component's business logic skeletons.
\item {\tt hello\_user\_types.h} \\
Contains the default IDL to C++ mappings. Note that these mappings can be
changed by the user, hence the ``user\_types'' name.
\end{itemize}

The generated business logic skeletons contains enough code to be compilable.
Each method includes a debug statement that prints out the file name and the method name of
the executed function. Thus, we have an empty but compilable component. Let's
compile it!
\begin{small}
\begin{verbatim}
~/hello> ccmtools-c++-configure -p hello1.0
~/hello> ccmtools-c++-make -p hello1.0
\end{verbatim}
\end{small}

The {\tt ccmtools-c++-configure} and {\tt ccmtools-c++-make} scripts also accept 
command line parameters as described below:
\begin{itemize}
\item {\tt -p NAME, -\-package=NAME}\\
Use the package named NAME. The default package name is ``ccmtools-package''.

\item {\tt -h, -\-help}\\
Print out a short description of the available command line parameters.
\end{itemize}

After compiling the source code, the test client calls some operations of the
generated component logic. The running test prints out a lot of debugging
messages; these messages document the execution flow of the program. The first
component is running!

\newpage
%------------------------------------------------------------------------------
\subsection{Test driven development}
%------------------------------------------------------------------------------

Software development is an iterative process. Kent Beck~\cite{Beck2003TDD}
proposed a {\it Test Driven Development} (TDD) methodology that starts by
implementing the test~-- before implementing the application!

\begin{figure}[htbp]
    \begin{center}
        \includegraphics [width=6cm,angle=0] {TestDrivenDevelopment}
        \caption{Test driven development process}
        \label{fig:test-driven-development}
    \end{center}
\end{figure}

As shown in Fig.~\ref{fig:test-driven-development}, the CCM Tools make use of
the TDD idea in the context of components. For every component $C$, the CCM
Tools generate a mirror component $\overline{C}$. Each input port (receptacle)
of $C$ corresponds to an output port (facet) of $\overline{C}$, and vice versa.
A test client coordinates creating and connecting the components, as well as the
test calls to the facets of $C$.

The current component directory contains the skeletons of the mirror
component business logic and the test client:
\begin{itemize}
\item {\tt HelloHome\_mirror\_app.[h,cc]} \\
Contain the factory methods for mirror component creation. Note that the default
{\tt create()} method is already implemented.
\item {\tt Hello\_mirror\_app.[h,cc]} \\
Contain the skeletons of the mirror component's test code.
\item {\tt \_check\_CCM\_Session\_Hello.cc} \\
Contains the component's test client skeleton that creates the component as well as
the mirror component and connects all facets to receptacles.
\end{itemize}

Note that the mirror component $\overline{C}$ and the test client are always
generated at the same time as the component itself, without additional
development effort. Both of these pieces of generated code can be suppressed by
leaving out the debug ({\tt -d} or {\tt --debug}) parameter when generating the
component code with {\tt ccmtools-c++-generate}.

As explained above, the component's unit test client creates $C$ and
$\overline{C}$ instances and connects these components together as shown in
Fig.~\ref{fig:test-driven-development}. This process begins automatically after
compiling. Later on, if you want to rerun the test to impress colleagues and
pets, you can type:
\begin{small}
\begin{verbatim}
~/hello> /tmp/hello1.0/CCM_Test/hello1.0_CCM_Test__check_CCM_Session_Hello
\end{verbatim}
\end{small}

%------------------------------------------------------------------------------
\subsection{Write the test first}
%------------------------------------------------------------------------------

Now is a good time to start the development of business code. First, we have to
define the behavior of the business code in an executable semantic. Thus we
write a test case in the mirror component ({\tt Hello\_mirror\_app.cc}), as
shown in Example~\ref{example:one-component-mirror-impl}.

\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
void
CCM_Hello_mirror_impl::ccm_activate (  )
  throw ( localComponents::CCMException )
{
  DEBUGNL ( " CCM_Hello_mirror_impl->ccm_activate (  )" );

  const string s = "Hello World";
  cout << "Start of Hello unit test:" << endl;
  int number_of_char =
    ctx->get_connection_console_mirror().ptr()->println(s);
  assert(number_of_char == s.length());
}
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Business logic implementation in a mirror component function.}
\label{example:one-component-mirror-impl}
\end{Example}

The test case is implemented in the {\tt ccm\_activate()} callback method of the
mirror component because this method is called after creating and connecting $C$
and $\overline{C}$. We use the context object ({\tt ctx}) to get a smart pointer
to the facet of $C$ before we call the {\tt println()} operation. To compile and
run the unit test again, we just use the CCM Tools C++ component make tool:
\begin{small}
\begin{verbatim}
~/hello> ccmtools-c++-make -p hello1.0
\end{verbatim}
\end{small}

From the output of the test client, we can see that the {\tt println()} method
of $C$ is called from the mirror component $\overline{C}$, but {\tt println()}
in the test fails. Remember, there is no business code implemented in {\tt
println()}; it is an empty function skeleton! Note that functions with a {\tt
void} return type will not fail the test, because the test client has no way of
receiving notification that such function calls succeeded.

%------------------------------------------------------------------------------
\subsection{Write the business logic}
%------------------------------------------------------------------------------

Finally, we can implement the business logic that satisfies the written test
case. We open the {\tt Hello\_app.cc} file and add a single line, as shown in
Example~\ref{example:one-component-impl}.

\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
long
console_impl::println ( const std::string& s )
{
  DEBUGNL ( " console_impl->println ( s )" );
  cout << s << endl;
  return s.length();
}
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Business logic implementation in a component function.}
\label{example:one-component-impl}
\end{Example}

As discussed above, the {\tt println()} method simply prints out the given
string and returns the number of characters of the string~-- that's it! We'll
run the test again to see if it's working:
\begin{small}
\begin{verbatim}
~/hello> ccmtools-c++-make -p hello1.0
\end{verbatim}
\end{small}

Yay, the unit test passed!

Note that all the hand crafted code is in the current directory. There is no
need to touch the generated code in {\tt hello1.0}. To protect the business code
from overwriting, the {\tt ccmtools-c++-generate} tool creates the {\tt
*\_app.[h,cc]} files only if they do not exist. If you really want to overwrite
these business logic files, however, you can use the force ({\tt -f} or {\tt
--force}) option to the {\tt ccmtools-c++-generate} tool.

%------------------------------------------------------------------------------
\subsection{Deploy the component}
%------------------------------------------------------------------------------

Deploying a component means that the component's source code will be compiled
into a component library file. This library file will then be stored in the
component repository, which is simply a directory on the computer that will
serve as a component server. The CCM Tools provide this functionality in a
single call:
\begin{small}
\begin{verbatim}
~/hello> ccmtools-c++-install -p hello1.0
\end{verbatim}
\end{small}

The {\tt ccmtools-c++-install} script accepts the following command line
parameters:
\begin{itemize}
\item {\tt -p NAME, --package=NAME}\\
Use package named NAME, the default package name is ``ccmtools-package''.

\item {\tt -h, --help}\\
Prints out a short description of the available command line parameter.
\end{itemize}

After being installed, the component is part of the component repository and can
be used in a component assembly or a local client.

%------------------------------------------------------------------------------
\subsection{Write a local test client}
%------------------------------------------------------------------------------

A component based application builds up component assemblies using deployed
components. In this section we'll show this task using a simple test client that
instantiates the {\tt Hello} component and calls the component's operations.

First, we'll add a {\tt test} directory to our project and implement the client
code in the subdirectory {\tt client}:
\begin{small}
\begin{verbatim}
    hello/
    |-- hello1.0/
    |-- test/
    |   |-- client/
    |   |   |-- client.cc
\end{verbatim}
\end{small}

The test client needs a bunch of included header files that are generated by the
CCM Tools. There are different namespaces defined in the header files that we
are using in the client code. The header lines from the test client are shown in
Example~\ref{example:one-component-test-head}.

The main function contains all the necessary code to use a local component. At
the local home finder, the client needs to register the {\tt HelloHome}
instance, as shown in Example~\ref{example:one-component-test-register}. After
home registration, we can find the home by its name and create a component
instance. From the component instance we get a reference to the {\tt Console}
facet. Finally, to indicate the component the end of create and configuration,
we call {\tt configuration\_complete} method. See
Example~\ref{example:one-component-test-create} for the code needed here.

Now that we have a component, we are ready to use the operations provided by the
component and its facet. Example~\ref{example:one-component-test-call} shows how
to call component methods. After calling component methods to test the
component, the client needs to tear down the components to free up allocated
memory. To tear the application town, we remove the component instance from
memory and unregister the component's home, as shown in
Example~\ref{example:one-component-test-teardown}.

\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
#include <localComponents/CCM.h>
#include <CCM_Local/HomeFinder.h>
#include <CCM_Utils/Debug.h>

#include <CCM_Local/CCM_Session_Hello/HelloHome_gen.h>
#include <CCM_Local/CCM_Session_Hello/Hello_gen.h>

using namespace std;
using namespace CCM_Utils;
using namespace CCM_Local;
using namespace CCM_Session_Hello;
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Test client header lines for the single component example.}
\label{example:one-component-test-head}
\end{Example}

\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
int main ( int argc, char *argv[] )
{
  // Set debugging mode
  Debug::set_global(true);

  // Get in instance of the local HomeFinder and
  // register component homes
  localComponents::HomeFinder* homeFinder =
    HomeFinder::Instance (  );
  try {
    homeFinder->register_home(create_HelloHomeAdapter(),
                              "HelloHome" );
  } catch ( ... )  {
    cout << "Aut'sch: when registering homes!" << endl;
    return -1;
  }
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Registering the component home with the local home finder.}
\label{example:one-component-test-register}
\end{Example}

\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
  try {
    // Find component home
    SmartPtr<HelloHome> myHelloHome
      ( dynamic_cast<HelloHome*>
        ( homeFinder->find_home_by_name
          ( "HelloHome").ptr ()));

    // Create a component instance
    SmartPtr<Hello> myHello =
      myHelloHome.ptr()->create();

    // Get a facet reference
    SmartPtr<CCM_Console> console =
      myHello.ptr()->provide_console();

    // Configure the component's attribute
    myHello.ptr()->prompt("=->");

    // Component configuration finished
    myHello.ptr()->configuration_complete();
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Creating the component and facet in the hello world example.}
\label{example:one-component-test-create}
\end{Example}

\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
    // Call operations on the component and its facet
    cout << "Version = " <<
      myHello.ptr()->getComponentVersion() << endl;
    cout << "Date = " <<
      myHello.ptr()->getComponentDate() << endl;

    console.ptr()->println("Hello from test client");
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Calling component methods in the hello world example.}
\label{example:one-component-test-call}
\end{Example}

\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
    // Destroy component instance
    myHello.ptr()->remove();

    // Unregister component home
    homeFinder->unregister_home("HelloHome");
  }
  catch ( localComponents::HomeNotFound ) {
    cout << "Aut'sch: can't find a home!" << endl;
    return -1;
  }
  catch ( ... )  {
    cout << "Aut'sch: there is something wrong!" << endl;
    return -1;
  }
  return 0;
}
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Tearing down the client in the single component hello world example.}
\label{example:one-component-test-teardown}
\end{Example}

To compile and install the local test client we use the {\tt Confix} tool, which
is also used by the component build process. Note that we use the same confix
profile the CCM Tools, to ensure that the client can access the component
libraries.
\begin{small}
\begin{verbatim}
~/hello/test> confix.py --bootstrap --configure  \
                        --make --targets=install --profile=ccmtools
\end{verbatim}
\end{small}

Finally, we can run the test client:
\begin{small}
\begin{verbatim}
~/hello> test_client_client
\end{verbatim}
\end{small}

The advantage here is that the development of the local component is separated
from the development of the test client. Thus, a deployed component can be used
in different applications at the same time.

%------------------------------------------------------------------------------
\subsection{Integrate existing business logic}
%------------------------------------------------------------------------------

The component's business code, in the example above, is very simple and
therefore directly implemented in the {\tt Hello\_app.[h,cc]} files. Usually,
however, business code has been already developed in a separated {\tt business}
directory. Even more likely is that the business logic is contained in some sort
of legacy code library:
\begin{small}
\begin{verbatim}
    hello/
    |-- hello1.0/
    |-- test/
    |   |-- client/
    |   |-- business/
    |   |   |-- legacy.h
    |   |   |-- legacy.cc
\end{verbatim}
\end{small}

For this example, we'll use some implemented business logic from legacy code.
This legacy code provides a {\tt print\_string} method, so all the component
developer needs to do is call up the legacy function, as shown in
Example~\ref{example:one-component-legacy-wrapper}.

\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
// legacy.h
#include<stdio.h>
extern void print_string(const char* s);

// legacy.cc
#include "legacy.h"
void print_string(const char* s)
{
  printf(s);
}
\end{verbatim}
\end{small}
\end{minifbox}
\caption{A short legacy code library wrapper.}
\label{example:one-component-legacy-wrapper}
\end{Example}

We suggest building the business logic in the same way as the test client, using
the {\it Confix} tool. Always remember to use the Confix ``ccmtools'' profile
when using the CCM Tools.
\begin{small}
\begin{verbatim}
test> confix.py --bootstrap --configure \
                --make --targets=install --profile=ccmtools
\end{verbatim}
\end{small}

After installing the component test, the {\tt Hello\_app.cc} file can be
modified as shown in Example~\ref{example:one-component-legacy-impl} to
integrate the separately compiled business code.

\begin{Example}
\begin{minifbox}
\begin{small}
\begin{verbatim}
#include<legacy.h>
//...
void
console_impl::println ( const std::string s2 )
{
  DEBUGNL ( " console_impl->println ( s2 )" );
  print_string(s2.c_str());  // call the legacy code
  return s2.length();
}
\end{verbatim}
\end{small}
\end{minifbox}
\caption{Including legacy code in a component's business logic implementation.}
\label{example:one-component-legacy-impl}
\end{Example}

In conclusion, to build the final component and the test client, we type:
\begin{small}
\begin{verbatim}
~/hello> ccmtools-c++-make -p hello1.0
~/hello/test> confix.py --bootstrap --configure \
                        --make --targets=install --profile=ccmtools
~/hello/test> test_client_client
\end{verbatim}
\end{small}

In summary, we have included legacy code in the component's business logic and
used the existing client to integrate the component in an application. This is
the beginning of the process of componentizing an existing legacy library. By
fully compartmentalizing legacy code (if that is possible), the respective
components can be individually tested to provide for more stable component based
software systems in the future.

%------------------------------------------------------------------------------
\subsection{Undeploy the component}
%------------------------------------------------------------------------------

To remove the component from the component repository, type:
\begin{small}
\begin{verbatim}
~/hello> ccmtools-c++-uninstall -p hello1.0
\end{verbatim}
\end{small}

The command line parameters are the same as those for the {\tt
ccmtools-c++-install} tool. Note that the source code is not affected by the
undeployment process; the uninstallation simply removes the component library
and cleans up the build directory tree.

