% $Id$
%==============================================================================
\chapter{Introduction}
%==============================================================================
\begin{flushright}
{\it From there to here, \\
     from here to there \\
     funny things are everywhere.\\
		(Dr. Seuss)}

\end{flushright}

The CCM Tools are a set of Java programs, libraries, and Python scripts. These
tools support the development of component based software systems. Components
generated using the CCM Tools are based on the {\it CORBA Component Model}
(CCM)~\cite{CCMSpecification}. As shown in Fig.~\ref{ccmtools}, the CCM Tools
form a component development framework that is flexible and extensible.

\begin{figure}[!htb]
    \begin{center}
        \includegraphics [width=12cm,angle=0] {ComponentGeneratorTools}
        \caption{CCM Tools overview}
        \label{ccmtools}
    \end{center}
\end{figure}

Using a well defined CCM model, we can separate the component description from
the code generator tools. Therefore, we can add new description methods (e.g.
UML) or code generator tools (e.g. a Java Component Generator) without changing
the other tools.

Note that the dashed tools are still under construction and therefore not part
of the current release series (CCM Tools release series 0.2).

The CCM Tools framework contains the following tools:

\begin{description}
\item [CCM Metamodel Library]
The CCM specification defines an {\it Interface Repository Metamodel} for the
IDL3 syntax. The CCM Tools contain a CCM Metamodel Library that allows for
creating and iterating over CCM models. Using this library allows a clear
separation between the parser and the code generators: A parser reads a set of
IDL3 statements and creates a CCM model, while a code generator reads through a
CCM model to produce code in a specific language.

\item [IDL3 Parser]
The IDL3 Parser reads an input IDL3 file, checks the syntax of the IDL source
code, and creates a CCM model using the CCM Metamodel Library. This CCM model is
the starting point for all code generator tools in the framework.

\item [IDL3 Generator]
To test the functionality of the CCM Metamodel Library and the IDL3 Parser, the
CCM Tools include an IDL3 Generator that writes out the CCM model in a
corresponding IDL3 File. Comparing these two files provides a careful gauge of
how well the CCM metamodel is implemented in the IDL3 Parser and IDL3 Generator.

\item [IDL3 Mirror Generator]
The CCM Tools enable a {\it Test Driven Development} (TDD) strategy to develop
and to specify components (as described later in this tutorial). In particular,
the CCM Tools can generate component unit tests, which use a mirror component to
connect and test all ports of an existing component. The IDL3 Mirror Generator
creates the IDL3 syntax definition of this mirror component.

\item [Local C++ Component Generator]
The component model is realized by the component logic that implements the
operations for providing, using, and connecting components by their facets and
receptacles. The CCM Tools contain a generator tool that creates local
(in--process) C++ component logic from a given CCM model. After generating the
component logic, the component developer needs to write the business logic
within the generated component skeletons.

\item [Local C++ Mirror Generator]
After building a local C++ component, it is a good idea to run a functional test
on it. To provide a suitable test environment, the CCM Tools can create a mirror
component as well as a test client that performs the component unit test. Note
that unit testing still depends on business logic implementation from the
component developer---just because the CCM Tools can generate code does not mean
you can just think your way into a well tested, component based application!

\item [Local Python Component Generator (under construction)]
For rapid prototyping and the development of glue components, the CCM Tools
encourage the use of heterogeneous local C++/Python components. The component
logic---including the component's interfaces---is implemented in C++, while the
business code can be sketched out in Python. This lets component developers work
quickly without the need to compile and redeploy after changes.

\item [IDL2 Generator]
To implement CORBA compliant components, the IDL3 source code is mapped to IDL2.
This IDL2 code can be processed by a classic IDL2 Compiler. (Currently we have
only tested with the Mico ORB.) The transformation from IDL3 to IDL2 adds some
operations needed for navigation between components and their ports; these
operations are called equivalent operations. The CCM Tools support this
transformation with an IDL2 Generator tool that creates IDL2 from an existing
CCM model.

\item [Remote C++ Component Generator (under construction)]
Local (in--process) components can only be used in a common address space and
must be implemented in the same programming language. To overcome these
limitations, the CCM Tools will generate remote component logic that interfaces
the local components with CORBA. The remote component logic is thus a superset
of the local component logic; the remote logic simply handles the argument
marshaling and demarshaling from operation calls to remote (out--of--process)
components. Note that the external view of such a remote component conforms to
the CCM specification.

\item [Component Descriptor Generator (under construction)]
To describe the component for the deployment and the assembling process, the OMG
defined a {\it CORBA Component Descriptor} (CCD) file format. This is an XML
file containing a short description of a component and its ports. The CCM Tools
use the CCM model and some information from a user interface to generate a
descriptor file for each component.

\end{description}


