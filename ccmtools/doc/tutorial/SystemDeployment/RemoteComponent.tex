% $Id$

%==============================================================================
\section{Car rental example}
%==============================================================================

We reuse our well known {\tt CarRental} component
to show how a local component can be extended to a CORBA component.
The local {\tt CarRental} component is organized in the following file 
structure:

\begin{small}
\begin{verbatim}
   server
   |-- component
   |   `-- CarRental
   |       |-- CCM_BigBusiness_ccm_local_component_CarRental
   |       `-- CCM_BigBusiness_ccm_local_component_CarRental_share
   |-- idl3
   |   |-- component
   |   |   `-- BigBusiness
   |   `-- interface
   |       `-- BigBusiness
   `-- interface
       |-- CCM_BigBusiness_ccm_local
       `-- CCM_BigBusiness_ccm_local_adapter
\end{verbatim}
\end{small}


%------------------------------------------------------------------------------
\subsubsection{Generate CORBA component adapters}
%------------------------------------------------------------------------------

For a remote CORBA component all IDL3 files must be mapped to equivalent
IDL2 files, as defined in the CCM specification \cite{CCMSpecification}.
Using the CCM Tools, this mapping can be done with a single call: 
\begin{small}
\begin{verbatim}
> ccmtools idl2 -o server/component/CarRental/CCM_corba_stubs \ 
                -Iserver/idl3/interface \
                -Iserver/idl3/component \
                server/idl3/interface/BigBusiness/*.idl \
                server/idl3/component/BigBusiness/CarRental*.idl
\end{verbatim}
\end{small}

The result of this IDL3 to IDL2 mapping is a {\tt CCM\_corba\_stubs} 
subdirectory, where all IDL2 files are stored.
\begin{small}
\begin{verbatim}
server/
|-- component
|   |-- CarRental
|   |   |-- CCM_corba_stubs
|   |   |   |-- BigBusiness_CarRental.idl
|   |   |   |-- BigBusiness_CarRentalHome.idl
|   |   |   |-- BigBusiness_CreateCustomerException.idl
|   |   |   |-- BigBusiness_Customer.idl
|   |   |   |-- BigBusiness_CustomerBusiness.idl
|   |   |   |-- BigBusiness_CustomerList.idl
|   |   |   |-- BigBusiness_CustomerMaintenance.idl
|   |   |   |-- BigBusiness_NoCustomerException.idl
|   |   |   |-- BigBusiness_RemoveCustomerException.idl
|   |   |   |-- Makefile
|   |   |   |-- Makefile.py
|   |   |   `-- build.xml
\end{verbatim}
\end{small}

Additionally, the generated  {\tt CCM\_corba\_stubs/Makefile} will
trigger Mico's IDL compiler to create C++ stub and skeleton files:
\begin{small}
\begin{verbatim}
> make -C server/component/CarRental/CCM_corba_stubs
\end{verbatim}
\end{small}

Besides the CORBA stubs and skeletons, a set of adapters is used to
convert between CORBA objects and local component classes.
These component adapters are generated with the following CCM Tools call:
\begin{small}
\begin{verbatim}
> ccmtools c++remote -o server/component/CarRental \
                     -Iserver/idl3/interface \
                     -Iserver/idl3/component \
                     server/idl3/interface/BigBusiness/*.idl \
                     server/idl3/component/BigBusiness/*.idl
\end{verbatim}
\end{small}

This additional component logic is stored within the {\tt CarRental}
component directory (see {\tt CCM\_*\_ccm\_remote\_component\_*} and 
{\tt CCM\_corba\_converter} subdirectories).
\begin{small}
\begin{verbatim}
server/
|-- component
|   |-- CarRental
|   |   |-- CCM_BigBusiness_ccm_local_component_CarRental
|   |   |-- CCM_BigBusiness_ccm_local_component_CarRental_share
|   |   |-- CCM_BigBusiness_ccm_remote_component_CarRental
|   |   |-- CCM_corba_converter
|   |   |-- CCM_corba_stubs
\end{verbatim}
\end{small}

Remember, the LCAC allows to extend a local component to a CORBA component
without business logic changes. 


\newpage
%------------------------------------------------------------------------------
\subsubsection{Install the remote {\tt CarRental} component}
%------------------------------------------------------------------------------
Finally, we can run {\tt Confix} to build and install this remote component:
\begin{small}
\begin{verbatim}
> confix.py --packageroot=`pwd`/server --bootstrap --configure 
            --make --targets=install
\end{verbatim}
\end{small}

After installing this remote component, the component repository contains
the following structure for C++ header files and libraries:
\begin{small}
\begin{verbatim}
include/
|-- BigBusiness
|   `-- ccm
|       |-- local
|       |   `-- component
|       |       |-- CarRental
|       |       `-- CarRental_mirror
|       `-- remote
|           `-- component
|               `-- CarRental
\end{verbatim}
\end{small}

\begin{small}
\begin{verbatim}
lib/
|-- libCarRental_component_CarRental.a
|-- libCarRental_..._ccm_local_component_CarRental.a
|-- libCarRental_..._ccm_remote_component_CarRental.a
|-- libCarRental_component_CarRental_CCM_corba_converter.a
|-- libCarRental_component_CarRental_CCM_corba_stubs.a
|-- libCarRental_component_CarRental_mirror.a
|-- libCarRental_component_CarRental_mirror_..._CarRental_mirror.a
|-- libCarRental_interface_CCM_BigBusiness_ccm_local_adapter.a
\end{verbatim}
\end{small}


\newpage
%------------------------------------------------------------------------------
\subsubsection{Implement a CORBA component server}
%------------------------------------------------------------------------------

A remote component must be launched in its own process to handle CORBA calls
from clients or other remote components.
For that reason, we create a new directory called {\tt corba\_server}
that hosts the code for a pretty simple CORBA server.
\begin{small}
\begin{verbatim}
corba_server/
|-- Makefile.py
`-- server.cc
\end{verbatim}
\end{small}

The {\tt server.cc} code, shows a minimal implementation of such a CORBA 
component's server.
\begin{small}
\begin{verbatim}
#include <cstdlib> 
#include <iostream>
#include <string>
#include <WX/Utils/debug.h>
#include <CCM/CCMContainer.h>

#include <CORBA.h>
#include <coss/CosNaming.h>

#include <BigBusiness/ccm/remote/component/CarRental/CarRentalHome_remote.h>
#include <BigBusiness_CarRental.h>

using namespace std;
using namespace WX::Utils;

int main (int argc, char *argv[])
{
    // Initialize ORB 
    CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);

    // Register all value type factories with the ORB  
    CCM::register_all_factories (orb);

    // Deploy local and remote component homes	
    int error = 0;
    error += deploy_BigBusiness_ccm_local_component_CarRental_CarRentalHome(
             "CarRentalHome");
    error += deploy_BigBusiness_ccm_remote_component_CarRental_CarRentalHome(
             orb, "CarRentalHome:1.0");
    if(error) {
        cerr << "ERROR: Can't deploy components!" << endl;
        return -1;
    }

    // Start ORB
    orb->run();  
}
\end{verbatim}
\end{small}

After setting up the ORB, both local and remote component are deployed.
Deployment of a remote component also implies the registration to a 
CORBA NameService.
Finally, the ORB is turned to its running mode to handle incoming 
CORBA requests.


Before we can build this CORBA server with a well known Confix call, 
we have to create a {\tt Makefile.py} file:
\begin{small}
\begin{verbatim}
#corba_server/Makefile.py
PACKAGE_NAME('corba_server')
PACKAGE_VERSION('1.0.0')
\end{verbatim}
\end{small}

\begin{small}
\begin{verbatim}
> confix.py --packageroot=`pwd`/corba_server --bootstrap --configure \
            --make --targets=install
\end{verbatim}
\end{small}


The server's code is compiled and linked to an executable in the
component repository:
\begin{small}
\begin{verbatim}
bin/
`-- corba_server_server
\end{verbatim}
\end{small}

A distributed CCM application uses CORBA's NameService to store
component home instance references together with their symbolic names. 
Mico comes with such a service called {\tt nsd}.

We start this service at port 5050:
\begin{small}
\begin{verbatim}
> nsd -ORBIIOPAddr inet:localhost:5050 -ORBIIOPVersion 1.2
\end{verbatim}
\end{small}

Now, we can start our brand--new CORBA server:
\begin{small}
\begin{verbatim}
> $CCM_INSTALL/bin/corba_server_server\
      -ORBInitRef NameService=corbaloc:iiop:1.2@localhost:5050/NameService
\end{verbatim}
\end{small}
%$

OK, our first CORBA component server is running - let's try to access it from
a remote client.


\newpage
%------------------------------------------------------------------------------
\subsubsection{Implement a C++ CORBA component client}
%------------------------------------------------------------------------------

Usually, CORBA components are connected to each other to build component 
assemblies.
In our case where only one component is used, we can implement a simple 
C++ CORBA client to access the remote component.

We create a new directory called {\tt corba\_client} that will
contain the code for such a simple CORBA client.
\begin{small}
\begin{verbatim}
corba_client/
|-- Makefile.py
`-- client.cc
\end{verbatim}
\end{small}

The following {\tt client.cc} file shows the implementation of a minimalistic
CORBA client using our remote {\tt CarRental} component:
\begin{small}
\begin{verbatim}
#include <CORBA.h>
#include <coss/CosNaming.h>

#include <CCM/CCMContainer.h>

#include <BigBusiness_CarRentalHome.h>
#include <BigBusiness_CarRental.h>

using namespace std;
using namespace WX::Utils;

int main (int argc, char *argv[])
{
  try {
    // Initialize ORB and NameService
    CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);
    CORBA::Object_var obj = orb->resolve_initial_references("NameService");
    CosNaming::NamingContextExt_var nc =
      CosNaming::NamingContextExt::_narrow(obj);
    
    // Find ComponentHomes in the Naming-Service
    obj = nc->resolve_str("CarRentalHome:1.0");
    assert (!CORBA::is_nil (obj));
    ::BigBusiness::CarRentalHome_var myCarRentalHome = 
        ::BigBusiness::CarRentalHome::_narrow (obj);
    
    // Create component instances
    ::BigBusiness::CarRental_var myCarRental = 
        myCarRentalHome->create();
    
    // Provide facets   
    ::BigBusiness::CustomerMaintenance_var maintenance = 
        myCarRental->provide_maintenance();
    
    ::BigBusiness::CustomerBusiness_var business = 
        myCarRental->provide_business();
    
    myCarRental->configuration_complete();
    
    cout << "==== Begin Test Case ====" << endl;
    
    business->dollars_per_mile(5.5);

    {
      CORBA::Long id = 1;
      ::BigBusiness::Customer person;
      person.id = id;
      person.first_name = "Franz";
      person.last_name = "Kafka";
      maintenance->createCustomer(person);
    
      business->resetCustomerMiles(id);
      business->addCustomerMiles(id, 120.0);
    }

    {
      CORBA::Long id = 1;
      ::BigBusiness::Customer_var person = 
          maintenance->retrieveCustomer(id);
      double dollars = business->getCustomerDollars(id); 

      cout << " Customer: " << person->first_name << " " 
           << person->last_name << endl;
      cout << " Miles : " <<  person->mileage << endl;
      cout << " To pay: " << dollars << " Dollars" << endl;
    }

    cout << "==== End Test Case ====" << endl; 

    // Destroy component instance
    myCarRental->remove();
  }
  catch(...) {
    cout << "Client: there is something wrong!" << endl;
    return -1;
  }
}
\end{verbatim}
\end{small}

In the majority of cases, a CORBA component client can be structured like:
\begin{itemize}
\item Initialize the CORBA ORB and the CORBA NameService.

\item Find a component home object, create a component instance and retrieve 
some facet references. Don't forget to finish this instantiation phase with a
{\tt configuration\_complete()} call.

\item Use the component instance and their facets to call some business
logic.

\item Destroy the component instance to free server resources.
\end{itemize} 

That's it, we can build this simple client and run it against our CORBA
component server.

Once again, we define a {\tt Makefile.py} that defines the name and version
of our package and run Confix to build and install this application.
\begin{small}
\begin{verbatim}
#corba_server/Makefile.py
PACKAGE_NAME('corba_client')
PACKAGE_VERSION('1.0.0')
\end{verbatim}
\end{small}

\begin{small}
\begin{verbatim}
> confix.py --packageroot=`pwd`/corba_client --bootstrap --configure \
            --make --targets=install
\end{verbatim}
\end{small}

The client's code is compiled and linked to an executable in the
component repository:
\begin{small}
\begin{verbatim}
bin/
|-- corba_server_server
`-- corba_client_client
\end{verbatim}
\end{small}

To start the client we have to pass a CORBA parameter which defines 
the NameService's location:

\begin{small}
\begin{verbatim}
> $CCM_INSTALL/bin/corba_client_client \
      -ORBInitRef NameService=corbaloc:iiop:1.2@localhost:5050/NameService
\end{verbatim}
\end{small}
% $

This example can also be tested in a distributed environment - the only thing
you have to ensure is that the right NameService location is passed to both
server and client.


%------------------------------------------------------------------------------
%\subsubsection{Implement a Java CORBA component client}
%------------------------------------------------------------------------------
