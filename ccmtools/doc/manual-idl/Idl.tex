\chapter{CCM Tools\\Interface Definition Language}

In the CCM Tools framework, a subset of CORBA's Interface Definition Language
(IDL) is used to define components, interfaces and parameters.

\newpage
%=============================================================================
\section{Source Files}
%=============================================================================
The IDL specification defines a number of rules for the naming and contents of
IDL source files.

%-----------------------------------------------------------------------------
\subsection{File Naming}
%-----------------------------------------------------------------------------
The names of source files containing IDL definitions must end in {\bf \tt .idl}
(for example, we can define a file named {\tt Components.idl}).

%-----------------------------------------------------------------------------
\subsection{File Format}
%-----------------------------------------------------------------------------
IDL is a free--form language. This means that IDL allows free use of spaces
and newline characters.
Layout and indentation do not carry semantics, so you can choose any textual
style you prefer, but keep in mind that IDL is programming language independent
so don't use language specific prefixes or names.
 

%-----------------------------------------------------------------------------
\subsection{Preprocessing}
%-----------------------------------------------------------------------------
IDL source files are preprocessed. The preprocessor's behavior is identical to
the C++ preprocessor (actually, the CCM Tools use the GNU C preprocessor {\tt 
cpp}).

The most common use of the preprocessor is for {\tt \#include} directives. This
permits an IDL definition to use types defined in a different source file.
You may also want to use the preprocessor to guard against double inclusion of a
file:
\begin{verbatim}
    #ifndef _MYFILENAME_IDL_
    #define _MYFILENAME_IDL_
    
    // some IDL definitions

    #endif /* _MYFILENAME_IDL_ */
\end{verbatim}


%-----------------------------------------------------------------------------
\subsection{Definition Order}
%-----------------------------------------------------------------------------
IDL constructs (modules, interfaces, type definitions) can appear in any order
you prefer.
However, identifiers must be declared befor they can be use.


%-----------------------------------------------------------------------------
\subsection{Comments}
%-----------------------------------------------------------------------------
IDL definitions permit both the C and the C++ style of writing comments:
\begin{verbatim}
    /**
     * This is a legal IDL comment.
     * Note that you can use tools like doxygen to extract
     * comments from IDL files.
     */

    // This comment extends to the end of this line.
\end{verbatim}


%-----------------------------------------------------------------------------
\subsection{Keywords}
%-----------------------------------------------------------------------------
IDL uses a number of keywords, which must be spelled in lowercase (e.g. {\tt
interface}, {\tt struct}, etc.).
There are three exceptions to this lowercase rule: {\tt Object}, {\tt TRUE} and
{\tt FALSE} are all keywords and must be capitalized.

%-----------------------------------------------------------------------------
\subsection{Identifiers}
%-----------------------------------------------------------------------------
Identifiers begin with an alphabetic character followed by any number of
alphabetics, digits, or underscores. Unlike C++ identifiers, IDL identifiers
can't have a leading underscore.

Identifiers are case--insensitive but must be capitalized consistently. 
This rule exists to permit mappings of IDL to languages that ignore case in
identifiers (e.g. Pascal) as well as to languages that treat differently
capitalized identifiers as distinct (e.g. C++, Java).

IDL permits you to create identifiers that happen to be keywords in one or more
implementation languages, but to make life easier, you should try to avoid IDL
identifiers that are likely to be implementation language keywords.

\newpage
%=============================================================================
\section{Basic IDL Types}
%=============================================================================
IDL provides a number of build--in basic types. 
The CORBA specification requires that language mappings preserve the {\it size}
of basic IDL types.
To avoid restricting the possible target environments and languages, the 
specification leaves the size and range requirements for IDL basic types loose.


%-----------------------------------------------------------------------------
\subsection{Integer Types}
%-----------------------------------------------------------------------------

\begin{itemize}
  \item {\tt short} (range from $-2^{15}$ to $2^{15}-1$, size $\geq$ 16 bits)
  \item {\tt long} (range from $-2^{31}$ to $2^{31}-1$, size $\geq$ 32 bits)
  \item {\tt unsigned short} (range from $0$ to $2^{16}-1$, size  $\geq$
  16 bits)
  \item {\tt unsigned long} (range from $0$ to $2^{32}-1$, size $\geq$ 32
  bits)
\end{itemize}

%-----------------------------------------------------------------------------
\subsection{Floating--Point Types}
%-----------------------------------------------------------------------------

\begin{itemize}
  \item {\tt float} (IEEE single--precision, size $\geq$ 32 bits)
  \item {\tt double} (IEEE double--precision, size $\geq$ 64 bits)
\end{itemize}


%-----------------------------------------------------------------------------
\subsection{Characters}
%-----------------------------------------------------------------------------
\begin{itemize}
  \item {\tt char} (ISO Latin--1, $\geq$ 8 bits)
  \item {\tt wchar} ($\geq$ 16 bits)
\end{itemize}

%-----------------------------------------------------------------------------
\subsection{Strings}
%-----------------------------------------------------------------------------
\begin{itemize}
  \item {\tt string} (ISO Latin--1, variable--length)
  \item {\tt wstring} (variable--length)
\end{itemize}

%-----------------------------------------------------------------------------
\subsection{Booleans}
%-----------------------------------------------------------------------------
Boolean values can have only the values {\tt TRUE} and {\tt FALSE}. 

%-----------------------------------------------------------------------------
\subsection{Octets}
%-----------------------------------------------------------------------------
The IDL type {\tt octet} is an 8--bit type that is guaranteed not to undergo any
changes in representation as it is transmitted between processes.

%-----------------------------------------------------------------------------
\subsection{Type any}
%-----------------------------------------------------------------------------
Type {\tt any} is a universal container type. A value of type {\tt any} can hold
a value of any other IDL type (e.g. {\tt long}, {\tt string}, or even another
value of type {\tt any}).
Type {\tt any} is useful when you don't know at compile time what IDL types you
will eventually need to transmit between client and server, you can find out at
runtime what type of value is contained in the {\tt any}.


\newpage
%=============================================================================
\section{User--Defined IDL Types}
%=============================================================================
In addition to providing the build--in basic types, IDL permits you to define
complex types: enumerations, structures and sequences. You can also use {\tt 
typedef} to explicitly name a type.

%-----------------------------------------------------------------------------
\subsection{Named Types}
%-----------------------------------------------------------------------------

You can use {\tt typedef} to create a new name for a type or to rename an
existing type.

Example:
\begin{verbatim}
    typedef long TimeStamp;
\end{verbatim}

Be careful about the semantics of IDL {\tt typedef}. It depends on the language
mapping whether an IDL {\tt typedef} results in a new, separate type or only an
alias. 
To avoid potential problems, you should define each logical type exactly once
and then use that definition consistently throughout your specification.


%-----------------------------------------------------------------------------
\subsection{Enumerations}
%-----------------------------------------------------------------------------
An IDL enumerated type definition looks much like the C++ version.

Example:
\begin{verbatim}
    enum Color 
    {
        red, 
        green, 
        blue
    };
\end{verbatim}

This example introduces a type named {\tt Color} that becomes a new type in its
own right - there is no need to use a {\tt typedef} to name the type.


%-----------------------------------------------------------------------------
\subsection{Structures}
%-----------------------------------------------------------------------------
IDL supports structures containing one or more named members of arbitrary type,
includeing user--defined complex types.

Example:
\begin{verbatim}
    struct TimeOfDay
    {
        short hh;
        short mm;
        short ss;
    };
\end{verbatim}

This definition introduces a new type called {\tt TimeOfDay}.
Structure definition form a namespace, so the names of the structure members
need to be unique only within their enclosing structure.

%-----------------------------------------------------------------------------
\subsection{Sequences}
%-----------------------------------------------------------------------------
Sequences are variable--length vectors that can contain any element type. 

Example:
\begin{verbatim}
    typedef sequence<Color> Colors; 
\end{verbatim}

A sequence can hold any number of elements up to the memory limits of your
platform. 


\newpage
%=============================================================================
\section{Modules}
%=============================================================================
IDL uses the {\tt module} construct to create namespaces.
Modules combine related definitions into a logical group and prevent pollution
of the global namespace.

Identifiers in a module need be unique only within that module.
Modules do not hide their contents, so you can use a type defined in one module
inside another module.

Modules can contain any definition that can appear at global scope.
In addition, modules can contain other modules, so you can create nested
hierarchies. 

Modules can be reopened. 
Incremental definition of modules is useful if specifications are written by a
number of developers (instead of creating a giant definition inside a single
module, you can break the module into a number of separate source files).




\newpage
%=============================================================================
\section{Interfaces}
%=============================================================================

%-----------------------------------------------------------------------------
\subsection{Constant Definitions and Literals}
%-----------------------------------------------------------------------------

%-----------------------------------------------------------------------------
\subsection{Operations}
%-----------------------------------------------------------------------------

%-----------------------------------------------------------------------------
\subsection{Attributes}
%-----------------------------------------------------------------------------

%-----------------------------------------------------------------------------
\subsection{User Exceptions}
%-----------------------------------------------------------------------------

%-----------------------------------------------------------------------------
\subsection{Inheritance}
%-----------------------------------------------------------------------------



\newpage
%=============================================================================
\section{Components}
%=============================================================================

%-----------------------------------------------------------------------------
\subsection{}
%-----------------------------------------------------------------------------


