%******************************************************************************
\chapter{Component Generator Tools}
%******************************************************************************

%==============================================================================
\section{Introduction}
%==============================================================================

This chapter describes the code generators in the CCM MOF Library. A library
like the CCM MOF greatly facilitates tasks like code generation. However, such
libraries usually provide an API that is too low--level to be of concern for
direct users. Hence this chapter focuses on development topics related to
expanding the component generator tools. If you are interested in {\it using\/}
the component generator tools (as opposed to {\it programming\/} the tools to
add new code generator functionality), see the user manual.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{ComponentGeneratorTools}
\caption{Component generation tools.}
\label{fig:component-generator-tools}
\end{figure}

The chapter is laid out in three major parts. First comes a design overview,
which describes the class and interface design, and outlines template
interactions in the component generator tools. The second part is a tutorial
that describes how to create a new code generator, and the third part is a
tutorial that presents an example of how to maintain an existing set of
templates along with a corresponding code generator. Generally, the three parts
in this chapter proceed from a more theoretical, developer--oriented point of
view to a more practical, maintainer--oriented point of view.

Before you begin, note that the rest of this chapter uses the term ``graph'' to
refer to a CCM MOF metamodel graph instance in memory. Usually such graphs are
created by the IDL3 Parser by parsing an input IDL3 file---see the chapter on
the IDL3 parser for more details on that process.

%==============================================================================
\section{Design overview}
%==============================================================================

The code generator library consists of three main objects: a graph traverser
class, a node handler interface, and a driver interface.
Figure~\ref{fig:component-generator-design} shows the major components involved.
These objects' functions are as follows:

\begin{description}
\item [Graph traverser] The graph traverser class is responsible for visiting
      the nodes in a given CCM MOF Library graph. The traverser visits graph
      nodes in a depth-first manner; that is, all child nodes of a given graph
      node are visited before proceeding to a sibling node. While visiting the
      graph, the traverser sends out events about the objects it sees.
\item [Node handler] The node handler interface receives graph traversal events
      from the traverser object and performs some useful action with them. The
      node handler also sends user interface events to the driver as needed.
\item [Driver] The driver interface receives events from a node handler
      implementation and translates these events to some sort of user interface
      information.
\end{description}

\begin{figure}
\centering
\includegraphics[width=\textwidth]{ComponentGeneratorDesign}
\caption{Components of the code generator design pattern.}
\label{fig:component-generator-design}
\end{figure}

A fourth very important object is an abstract implementation of the node handler
interface: the code generator base class. This abstract base class performs most
bookkeeping tasks involved in code generation, such as maintaining a record of
visited nodes, providing some standard information about the current node in the
graph, interfacing with a template set, and determining when to write generated
code to disk.

Finally, the entire code generator class family uses a system of templates for
generating code from a given CCM MOF graph. By deriving code generators from the
abstract code generator base class, and by creating or modifying a set of
templates, it is relatively easy to create or modify a code generator.

%------------------------------------------------------------------------------
\subsection{Two--layer visitor design pattern}
%------------------------------------------------------------------------------

The code generator library follows a general design pattern known as the {\em
visitor pattern\/}. In this pattern, a ``visitor'' object visits (or ``travels
through'') an abstract space. As the visitor object travels, it communicates its
observations to some other object. The other object then does something useful
with the received observations.

For the code generation task, the ``space'' is a CCM MOF graph, which is
normally the result of parsing an input IDL3 source file. The visitor object
travels to each node in the graph and sends events about these nodes to a node
handler object. In turn, the node handler object transforms these events into
some sort of generated code.

Just for comparison, note that the visitor pattern shows up in other software
packages. For example, this visitor pattern is also used in Python's SAX XML
parser classes: An XML tree traverser object crawls through the XML elements in
an input file, sending traversal events to a node handler for useful output. In
fact, the similarity between the two tasks is what inspired the current code
generator design.

The code generator extends the visitor pattern by adding a second visitor layer.
This second layer comes from the interaction between the node handler and driver
objects. The node handler acts as a visitor in code generation space and sends
events to the driver object. The driver object, in turn, handles these events by
translating them into some sort of user interface activity. This permits the
node handler objects to be agnostic about displaying status information to the
user.

This separation of traversal, node handling, and user interface information
allows for a smaller code base and more abstract graph handling. In addition,
separating graph traversal from node handling allows for reuse of the traverser
object. For example, to generate code for different component types with a given
input file, a driver program needs only to instantiate multiple node handler
objects. Each node handler object can independently receive and interpret the
traversal events from the graph traverser. However, the current traverser
implementation does not allow for multiple, simultaneous node handlers.

Similarly, separating the user interface from the node handling allows for reuse
of the node handler object: Any node handler object can use any front end, which
results in easier adaptation to different user interface environments.

%------------------------------------------------------------------------------
\subsection{Code generator templates}
%------------------------------------------------------------------------------

None of the code generator objects could generate any code without templates. In
the absence of a template set, the graph traverser would send graph traversal
information to a code generator, but the generator would not have any way of
converting that information into output code.\footnote{Well, that is not
entirely correct; the code generators could indeed function, but the generated
code would have to be hard-coded in the generator's Java class. That's Just Bad,
especially for maintenance.} So to allow for more flexible template maintenance
and increased code reuse, the code generators in the CCM Tools package use
template sets.

A template set is essentially a collection of plain text files. These files are
mostly written in the target language, for example, in C++, Java, or Python. If
a template needs information from the graph traversal process, it will contain a
{\em key\/} as a placeholder for the dynamically--generated information.
Template keys form a large part of the template system's functionality, so a
large part of the following tutorials are devoted to explaining how they work.

For now, consider a short example. The local C++ component generator uses a
template set that is written in C++. The templates can have keys as placeholders
for things like component and operation identifiers (\verb+%(Identifier)s+);
operation parameter information (\verb+%(MParameterDef)s+); exception names
(\verb+%(MExceptionDefName)s+); C++ data types for parameters, operations, and
{\tt struct}s (\verb+%(LanguageType)s+); and so forth. In fact, these four types
of keys each have different meanings to the code generator. To convert the
templates into generated code, a code generator performs a series of text
substitutions, replacing each key in a template with information from the graph
traversal.

The different meanings of the four key types, and the template substitution
processes, are all explained in greater detail in the next two tutorials. The
first tutorial concentrates on writing a new code generator and associated
template set. The second tutorial gives some guidelines for maintaining an
existing generator and template set.

%==============================================================================
\section{Writing a new code generator}
%==============================================================================

\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{ComponentGeneratorParts}
\caption{Component generation class hierarchy.}
\label{fig:component-generator-parts}
\end{figure}

Creating a new code generator tool necessarily depends on the specific nature of
the code generation task you want to accomplish. Nevertheless, the creation
generally needs to cover several tasks before you can get a working code
generator. The tasks involved fall into four general categories:

\begin{description}
\item [Creating a basic class] This category covers the basics of creating a new
      code generator. You will need to create the basic Java skeleton class,
      determine the nodes for which generated code should be written to disk,
      identify files that need to be output only once per generation task, and
      create a set of language data type mappings.
\item [Templates] This step involves creating a set of templates for your
      generator. Most of the work of a code generator goes into these templates.
\item [Implementing basic functionality] Each code generator requires at least
      three function implementations. These three basic functions are:
      \begin{description}
      \item [{\tt writeOutput}] This function will write generated code to the
            hard disk.
      \item [{\tt finalize}] This function can generate global package files
            based on the set of input IDL source files.
      \item [{\tt getLanguageType}] This function provides the generator with a
            mapping between IDL data types and the data types in the target
            language. The language mapping you create in the first stage usually
            comes in handy here.
      \end{description}
\end{description}

In addition, depending on the complexity of the code generator you want to
write, you might need to perform some additional coding tasks. This could
include any of the following:

\begin{enumerate}
\item hello
\end{enumerate}

\begin{enumerate}
\item Create the basic skeleton Java needed for a new code generator class. This
      is usually done by just copying an existing generator class and stripping
      out the existing language-specific functionality. See the IDL2 generator
      class for an example of minimal generator Java code.
\item Determine the nodes for which generated code should be written to disk.
      These will be referred to as ``top level node types''. Store these node
      types, as strings in a {\tt private final static String[]} array in your
      new class. Note that ``MContainer'' will be added to these types!
\item Identify files that need to be output only once per generation task (as
      opposed to one or more times for each component or operation in an input
      IDL file, for example). These files are referred to as ``environment
      files'' and need to be stored in a special array. Figure out the relative
      paths of the environment files (relative to the generated code root
      directory) and store these files in your class in a {\tt private final
      static File[]} array. See the {\tt local\_environment\_files} array in the
      C++ Python generator for an example of how this works.
\item Create a set of language mappings in a {\tt private final static String[]}
      array. This language map array must be the same length as the {\tt
      MPrimitiveKind} enumeration (located in {\tt
      Metamodel/BaseIDL/MPrimitiveKind.java} in the source tree). The language
      map array provides the strings that will be used to translate IDL language
      types into the data types for the target language. Thus the entries in
      this language mapping array must be in the same order as the entries in
      the {\tt MPrimitiveKind} enumeration.
\item Create templates for your environment files. Since environment files are
      usually static from project to project, these templates are often just
      straight code written in the target language. If you absolutely need to
      include dynamic data in an environment file, you can use the defines
      variable and provide -D flags on the command line to the ccmtools-generate
      front end.
\item Create a set of templates for your generator. These templates are the core
      of generated code. You must, at a minimum, create a template for
      ``MContainer'' and for any node types you defined as top level node types.
      The template creation process is important enough to warrant its own
      section in this manual; see section~\cite{subsec:template-writing} for
      details.
\item Write a {\tt writeOutput} function. This function is called for each top
      level node type encountered in the graph. This function will produce all
      generated code. It should accept a {\tt Template} object and have a void
      return type. This function can be as simple or as complex as you wish; it
      is the generator's primary source of control over the generation process.
\item Write a {\tt finalize} function. This function is called when a set of
      graphs has been completely traversed and provides a code generator the
      opportunity to generate files based on the input IDL source files. From
      the user perspective, the {\tt finalize} function is thus called once per
      run of the ``ccmtools-generate'' command. Normally this function is used
      to create a set of global (i.e., per-package) header files that include
      other files that might have been created during each separate graph
      traversal.
\item Write a {\tt getLanguageType} function. This function provides the
      generator with a mapping between IDL data types and the data types in the
      target language. Sometimes this can be a basic function that simply
      provides the mapped value from the language map you created earlier. (See
      the IDL generator base class for an example of a relatively simple
      language type function implementation.) More often, however, the complex
      data types will require more special treatment. (See the implementation in
      the C++ local generator for a complex example.)
\end{enumerate}

set of language templates generally proceeds from the top down, starting with a
template for top level elements such as MContainer or MModuleDef, and proceeding
through the CCM MOF Library in order of node specificity.

Using specific code examples can help with syntax when writing templates. Try to
find some example code go help guide the writing process.

Generally, template writing involves a combination of thinking about what types
of objects may be contained in a given object, and looking at code examples to
see how these contained objects are expressed in the target language. Usually,
to complete a template set, you must write some custom code in the code
generator class for the target language.

This section presents three types of information. First, it presents a
description of the process for writing a new template set, using a small IDL3
file as a guiding example. Next, it shows how to use the new example template
set to guide development of an example code generator class. This code generator
class generally includes custom code needed for the target language. Finally,
this section presents a small reference for template writers, including a
reference of common keys available for use in templates.

%------------------------------------------------------------------------------
\subsection{Process overview}
%------------------------------------------------------------------------------

Writing a template set usually starts by writing templates for more globally
scoped CCM MOF Library elements (e.g. MContainer and MModuleDef). Whenever a
potential subelement is encountered (for example, an MInterfaceDef instance
could be contained in an MModuleDef instance), the template can simply indicate
so by including a `tag' for the element type, as described below.

Template writing can theoretically proceed in this way from general elements
through the entire CCM MOF Library to more specific elements (e.g. MParameterDef
and MField) by following this process. Just by following this template process,
you can often write a near--complete template set. In the ideal case, the code
generator class will be a simple code skeleton, relying completely on the parent
classes to generate code. In practice, however, you will need to write some
pieces of custom code in the derived code generator class to complete the code
generator and template set combination required to generate code.

%---------------------------------------
\subsubsection{Example template writing task}
%---------------------------------------

For purposes of illustration, the remainder of this section will use the IDL3
file shown in Example~\ref{example:idl3-code} as an example for template
writing. The parse tree produced by parsing such an IDL file, with just the node
types and identifiers indicated, is shown in
Example~\ref{example:component-parse-tree}. The target language for the example
will be Java. For comparison, Example~\ref{example:component-generated-java}
shows the generated Java code that should result from the example IDL3 file.

\begin{Example}
\begin{minifbox}
\begin{verbatim}
interface MyInterface {
  double MyOperation ( in int MyParameter );
  int    AnotherOperation ( inout char Letter,
                            inout int Number );
};
\end{verbatim}
\caption{Example IDL3 source file.}
\label{example:component-idl3-code}
\end{minifbox}
\end{Example}

\begin{Example}
\begin{minifbox}
\begin{verbatim}
+ MInterfaceDef (MyInterface)
  + MOperationDef (MyOperation)
    + MParameterDef (MyParameter)
  + MOperationDef (AnotherOperation)
    + MParameterDef (Letter)
    + MParameterDef (Number)
\end{verbatim}
\end{minifbox}
\caption{CCM MOF graph resulting from parsing the example IDL file.}
\label{example:component-parse-tree}
\end{Example}

\begin{Example}
\begin{minifbox}
\begin{verbatim}
interface MyInterface
{
  float
  MyOperation
    ( int MyParameter );
  int
  AnotherOperation
    ( char Letter, int Number );
}
\end{verbatim}
\caption{Target Java code that should be generated from the example IDL file.}
\label{example:component-generated-java}
\end{minifbox}
\end{Example}

For clarity, this template section uses some typographical conventions. CCM MOF
object types will be printed in bold roman text (e.g. MParameterDef). CCM
MOF object variable and function names are printed in italicized roman text
(e.g. {\it isAbstract\/}). Tag names in templates are indicated by a sans serif
font (e.g. {\sf MParameterDef}). Note that tag names can be (and indeed often
are) names of objects in the CCM MOF library. Finally, file names and code
excerpts are printed in monospaced (e.g. {\tt filename}).

%------------------------------------------------------------------------------
\subsection{Top down template writing}
%------------------------------------------------------------------------------

As stated earlier, template writing can generally proceed from more global
library elements to more specific elements. Given the example IDL file as a
guide, we need to write a template for MInterfaceDef (since it is the highest
level element in our IDL3 code example).

The first step is to create a directory to hold the templates. The directory
needs to be named {\tt <language>-templates} and should be somewhere where the
code generator can find it. (See the notes in the code generator documentation
for more details on template paths.) The template for a node type needs to have
the same name as the node type, so we need to make a new file called {\tt
java-templates/MInterfaceDef}.

A code generator template is basically a piece of code written in the target
language (for this example, Java). Instead of specific identifiers and
constants, however, the template contains keys that the code generator will fill
in when the code is generated.

A tag is just a text string of the form {\tt \%(name)s}, because this is the
form that Python uses to retrieve values from a hash table when printing a
string. The \ref{subsection-template-keys} section below lists some common keys
available for templates. At the moment, it is only important to know that, in
general, a {\sf Name} tag is available for any CCM MOF Library element that has
a {\it getName\/} or {\it isName\/} function (note that capitalization is
important).

Applying the process to the example code generation task, we might get a
template for MInterfaceDef that looks something like this:

\begin{verbatim}
interface %(Identifier)s
{
%(MOperationDef)s
}
\end{verbatim}

Because an MInterfaceDef node does not have a {\it getMOperationDef\/} function,
the {\sf MOperationDef} tag in this template indicates that the code generator
should attempt to load a template for MOperationDef and fill it with the
contents of any {\tt MOperationDef} nodes that are children of the current node
before replacing the appropriate tag in the template. This process is explained
in greater detail in the next section.


%---------------------------------------
\subsubsection{Recursive template loading and substitution}
%---------------------------------------

The template substitution process goes even further than basic translation
directly from graph nodes. Consider, for example, a code template for an IDL3
operation. This template will need keys for things like the operation's
identifier and the data type that the operation returns. The values for these
keys come directly from each operation node in a given graph traversal.

But an operation also has parameters and can throw exceptions. The number of
parameters and exceptions is not fixed for all operations. That is, a given
operation might take three parameters and throw four types of exceptions, while
another operation might only take one parameter and throw no exceptions. The
template for an operation cannot hold the code for all possibilities in this
respect.

In fact, the specific code to implement these types of variables needs to be
created after all appropriate nodes in the graph are visited. More specifically,
for an operation, the operation template needs to know information contained in
the child parameter and exception nodes in the graph. Luckily, though, all the
the relevant nodes (parameters and exceptions) are all immediate children of the
operation node, so the operation needs just the information from its child
nodes.

To support this type of template interaction, the code generator implementation
supports recursive template substitution. Keys in a template just need to follow
a specific naming convention, and the code generator will automatically
substitute template information from other nodes in the graph. The specifics of
this substitution process are described below during the tutorial on template
creation.

%---------------------------------------
\subsubsection{Code generator classes}
%---------------------------------------

This recursive substitution process is generally robust enough to handle most
code generation tasks. But if all code generation information goes in a template
set, what code is needed for the generator class itself? Indeed, sometimes a
code generator (in particular the IDL generators) might need very minimal code
when combined with a good template set.

Each code generator must understand how to physically write its generated code
to an output source tree. This output processing must be custom written for each
code generator, since each component generation task is unique to a given
language and component type. So at a minimum, a code generator will require some
sort of specific output functionality.

In addition, there are times when the filled--in templates need some additional
processing before they are fully correct. Quite often, these times are matters
of syntax correction. For example, in many programming languages, an operation's
parameters are separated by commas, but the last parameter in the list must not
be followed by a comma. It is impossible for a template set alone to know which
parameter is the last in a list; only the code generator can calculate this,
because the code generator receives graph information from the graph traverser.

To fix this problem of too many commas, the code generator class itself must
supervise the template substitution process, removing the last comma from a
paremeter list before it gets passed to an operation's template. Such template
supervision makes up a large part of the code that goes in a code generator
implementation.
















Because an {\tt MInterfaceDef} object has a variable called {\it identifier\/}
(and a corresponding access function named {\it getIdentifier\/}), it is easy
for the code generator to simply substitute the value of the current node's
identifier for the {\sf Identifier} tag in a template.

The difficulty with a top down template like the one shown in the previous
section is that it is not clear how to generically generate code for a more
complex tag like {\sf MOperationDef}: {\tt MInterfaceDef} class instances do not
have variables and access functions for things like this. To support such keys,
the code generator uses a recursive template loading and substitution process.
This scheme simplifies template development in many cases and allows for more
general template keys. However, it also requires some extra coding in some
cases.

Consider the parse tree for the example code generation task. When the graph
traverser starts reading the {\tt MyInterface} node, it will proceed to the {\tt
MyOperation} node and on to the {\tt MyParameter} node before returning back up
the tree, leaving the {\tt MyParameter} node, then leaving the {\tt MyOperation}
node. Next it will visit the {\tt OtherOperation} node (and also that node's
child elements), and finally it will go all the way back up and leave the {\tt
MyInterface} node at the top.

At each point during this process, the code generator stores information about
the nodes it has visited so far. In this way, when the code generator returns to
the {\tt MyInterface} node after visiting its child nodes, it has all the
necessary information to fill in an {\tt MOperationDef} tag in the interface
template.

The process that the code generator uses to gather this information is described
next. Following the description is an explanation of how to use this information
in template creation.

%---------------------------------------
\subsubsection{Template loading and substitution in the example}
%---------------------------------------

When the code generator receives an endNode message from the traverser, it
attempts to load a template for the given node type. Because the {\tt
MyParameter} node in the example is a {\tt MParameterDef} instance, the code
generator will try to load a template from disk located at {\tt
java-templates/MParameterDef}. If the template for {\tt MParameterDef} looks
like
\begin{verbatim}
%(LanguageType)s %(Identifier)s,
\end{verbatim}
then after doing tag substitution we would get
\begin{verbatim}
int MyParameter,
\end{verbatim}
and the code generator would store that information in its internal variable
hash.

The important thing to note here is that the substituted template value will be
added to the {\em parent node's\/} information, indexed using the node type as a
key in the hash table. So the above string will be added to the code generator's
variable hash, indexed under the {\it MParameterDef\/} variable of the {\tt
MyOperation} node.

After descending to read the first parameter node, the graph traverser will exit
the {\tt MyOperation} node, at which point it will load the template from {\tt
java-templates/MOperationDef} (because {\tt MyOperation} is an instance of {\tt
MOperationDef}) and substitute the variables for this node. The template for
{\tt MOperationDef} nodes should look like the target Java code, with specific
identifiers replaced by keys:
\begin{verbatim}
  %(LanguageType)s
  %(Identifier)s
    ( %(MParameterDef)s );
\end{verbatim}
Then substituting the variables in this template will yield:
\begin{verbatim}
  float
  MyOperation
    ( int MyParameter, );
\end{verbatim}
Again, the important thing to keep in mind is that this information will be
added to the parent node's {\it MOperationDef\/} variable, so the node
information for {\tt MyInterface} will contain an {\it MOperationDef\/} variable
that contains this string.

The graph traverser will then continue on and start the {\tt AnotherOperation}
node. When it has ended the second {\tt MParameterDef} child node, the {\it
MParameterDef\/} variable for the {\tt AnotherOperation} node will look like:
\begin{verbatim}
char Letter, int Number, 
\end{verbatim}
Then when the graph traverser has visited all children of the {\tt MyOperation}
node and finally ascends up one layer and signals the end of the {\tt
MyOperation} node itself, the code generator will load the template from {\tt
java-templates/MOperationDef} from disk. After substituting the values for the
second operation, the code generator adds the resulting value to the {\it
MOperationDef\/} variable in the parent element. This yields an {\it
MOperationDef\/} value for the {\tt MyInterface} node:
\begin{verbatim}
  float
  MyOperation
    ( int MyParameter, );
  int
  AnotherOperation
    ( char Letter, int Number, );
\end{verbatim}
and, as before, this value will be added to the parent node's information. So
this string will get added to the {\it MOperationDef\/} variable of the {\tt
MyInterface} node. When the traverser then exits the {\tt MyInterface} node, the
code generator again loads a template, this time from {\tt
java-templates/MInterfaceDef}:

\begin{verbatim}
interface %(Identifier)s
{
%(MOperationDef)s
}
\end{verbatim}
which, after substituting values, yields:
\begin{verbatim}
interface MyInterface
{
  float
  MyOperation
    ( int MyParameter, );
  int
  AnotherOperation
    ( char Letter, int Number, );
}
\end{verbatim}

This recursive substitution process is what enables short, top down style
templates that can handle a variety of input trees.

%------------------------------------------------------------------------------
\subsection{Customizing the code generator class}
\label{subsection-template-component-generator}
%------------------------------------------------------------------------------

%------------------------------------------------------------------------------
\subsection{Template keys}
\label{subsection-template-keys}
%------------------------------------------------------------------------------

%---------------------------------------
\subsubsection{Generic keys}
%---------------------------------------

The code generator library supports many generic keys for templates. The keys
supported are as follows:

\begin{description}

\item [Identifier] The identifier of the current node, as returned from the
      node's `getIdentifier' method.

\item [LanguageType] The type of the current node, mapped to a type for the
      target language.

      For example, an MParameterDef object has an `IdlType' variable associated
      with it. If, for example, the associated IdlType object is an
      MPrimitiveKind object of type {\tt PK\_LONG}, and the target language is
      Java, the resulting LanguageType will be `int'. Language mappings can be
      found in the local language type list in each language's abstract base
      class.

\item [ComponentType] The identifier of the corresponding component. This is
      generally valid for MFactoryDef, MFinderDef, MUsesDef, MProvidesDef,
      MEmitsDef, MPublishesDef, MConsumesDef, and MHomeDef objects.

\item [UsesType] For an MUsesDef object, gives the identifier of the interface
      used. In this sense, a uses definition in IDL3 is of the form:

\begin{verbatim}
uses [multiple] %(UsesType)s %(Identifier)s;
\end{verbatim}

\item [ProvidesType] For an MProvidesDef object, gives the identifier of the
      interface provided. In this sense, a provides definition in IDL3 is of the
      form:

\begin{verbatim}
provides %(ProvidesType)s %(Identifier)s;
\end{verbatim}

\item [HomeType] For a component, gives the identifier of the component's home.
      Generally valid for the same node types as the ComponentType template key.

\item [BaseTypes] For a component, home, or interface, gives a comma separated
      list of identifiers of parent classes (other components or interfaces).

\item [SupportTypes] For a component or home, gives a comma separated list of
      identifiers of supported interfaces.

\end{description}

%==============================================================================
\section{Component generators}
%==============================================================================

The CCM MOF Code Generator Library contains one derived class and one template
set for each target output component type. Example ``target output component
types'' might be, for example, local C++ components, Java test components, or
remote Python components.

%------------------------------------------------------------------------------
\subsection{IDL2 generator}
%------------------------------------------------------------------------------



%------------------------------------------------------------------------------
\subsection{IDL3 mirror generator}
%------------------------------------------------------------------------------



%------------------------------------------------------------------------------
\section{C++ component generator}
%------------------------------------------------------------------------------










