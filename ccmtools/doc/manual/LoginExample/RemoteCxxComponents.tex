% $Id$
%==============================================================================
\section{Use Case 2: Remote C++ Components}
\label{section:RemoteC++ComponentImplementation}
%==============================================================================

In the second CCM Tools use case, we implement a remote C++ component with a
remote unit test client based on CORBA middleware. 
This use case is adequate for a developers who implements large and distributed
C++ applications.

\vspace{3mm}
The implementation of remote C++ components requires the following activities:
\begin{itemize}
	\item Model the component's structure in IDL (see section~\ref{section:ComponentDefinition}). 
	\item Implement the local component (see section~\ref{section:LocalC++ComponentImplementation}).
	\item Generate the remote component logic.
	\item Implement a minimal CORBA server.
	\item Implement a remote component client.
\end{itemize}

For a given local C++ component implementation, a set of CORBA
adapters and converters can be generated which establish a remote component logic.
This step from local to remote C++ components is completely automated by
the CCM Tools.


%------------------------------------------------------------------------------
\subsection{Generate the remote component logic}
\label{subsection:GenerateRemoteComponentLogic}
%------------------------------------------------------------------------------

Currently, CORBA middleware is used for inter--process communication, thus,
local C++ interfaces must be adapted to CORBA objects and vice versa.

\vspace{3mm}
To realize CORBA interactions, we need CORBA stub and skeleton classes 
generated by a particular IDL compiler. While components are modeled in
IDL3, usual IDL compilers assume IDL2 (without keywords like {\tt component} or 
{\tt home}).
For that reason, a CCM Tools generator transforms IDL3 to IDL2, as defined in
the CCM specification:
\begin{footnotesize}
\begin{verbatim}
> ccmidl -idl2 -I../../idl3repo/interface -I../../idl3repo/component \
         -o src/component/Server/CCM_corba_stubs                     \  
         ../../idl3repo/interface/application/*.idl

> ccmidl -idl2 -I../../idl3repo/interface -I../../idl3repo/component \
         -o src/component/Server/CCM_corba_stubs                     \
         ../../idl3repo/component/application/Server*.idl
\end{verbatim}
\end{footnotesize}

In this example, all generated IDL2 files are stored in a directory called {\tt
CCM\_corba\_stubs}:
\begin{footnotesize}
\begin{verbatim}
    Login/c++/server
    |-- component
    |   `-- Server
    |       |-- CCM_corba_stubs
\end{verbatim}
\end{footnotesize}

In this {\tt CCM\_corba\_stubs} directory we call the IDL compiler for
every single file (the CCM Tools provide a script that can do this
in a single call):
\begin{footnotesize}
\begin{verbatim}
> cd src/component/Server/CCM_corba_stubs
> ccmtools-idl -mico -I${CCMTOOLS_HOME}/idl *.idl
> cd ../../../../
\end{verbatim}
\end{footnotesize}

The transformed IDL2 files include interfaces which are part of the
installed CCM Tools, therefore, the IDL compiler needs the include path set to
{\tt CCMTOOLS\_HOME/idl}.

\vspace{3mm}
As a glue between the local C++ interfaces and the CORBA stubs and skeletons, we
generate CORBA adapters and converters:
\begin{footnotesize}
\begin{verbatim}
> ccmtools c++remote -I../../idl3repo/interface -I../../idl3repo/component \
                     -o src/component/Server/                              \
                     ../../idl3repo/interface/application/*.idl

> ccmtools c++remote -I../../idl3repo/interface -I../../idl3repo/component \
                     -o src/component/Server/                              \
                     ../../idl3repo/component/application/Server*.idl
\end{verbatim}
\end{footnotesize}

All generated source files are stored in {\tt CCM\_*\_remote\_*} directories:
\begin{footnotesize}
\begin{verbatim}
Login/c++/server
`-- src
    |-- component
    |   `-- Server
    |       |-- CCM_application_ccm_remote_component_Server
    |       |-- CCM_application_ccm_remote_corba_converter
    |       `-- CCM_corba_stubs
\end{verbatim}
\end{footnotesize}

Remember, there is no reason to check--in generated component logic files into a
CVS like system because this code can be generated from the IDL repository
at every time.

\vspace{3mm}
That's it, we have extended the local C++ component from 
section~\ref{section:LocalC++ComponentImplementation} to a remote component 
that can be accessed via CORBA
\footnote{
There is no technical reason for using CORBA as remote communication mechanism.
Future versions of CCM Tools could provide other middleware (e.g. SOAP)
adapters too. } 
middleware.

%------------------------------------------------------------------------------
\subsection{Implement a minimal CORBA server}
\label{subsection:ImplementMinimalCorbaAserver}
%------------------------------------------------------------------------------
Before implementing a remote client, the remote component must be started as a
stand-alone CORBA server.
To keep things simple, we implement this CORBA server in a single 
{\tt \_check\_*.cc} file:
\begin{footnotesize}
\begin{lstlisting}[language=C++]
#include <string>
#include <WX/Utils/debug.h>
#include <CCM/CCMContainer.h>

#include <CORBA.h>
#include <coss/CosNaming.h>

#include <application/ccm/remote/component/Server/ServerHome_remote.h>
#include <application_Server.h>

using namespace std;
using namespace WX::Utils;

int main (int argc, char *argv[])
{
  char* argv_[] = { "", 
                    "-ORBInitRef", 
                    "NameService=corbaloc:iiop:1.2@localhost:5050/NameService"}; 
  int   argc_ = 3;
  CORBA::ORB_var orb = CORBA::ORB_init(argc_, argv_);

  // Register all value type factories with the ORB  
  CCM::register_all_factories(orb);

  // Deploy local and remote component homes	
  int error = 0;
  error += deploy_application_ccm_local_component_Server_ServerHome("ServerHome");
  error += deploy_application_ccm_remote_component_Server_ServerHome(orb, 
                                                                    "ServerHome");
  if(!error) 
  {
      cout << "ServerHome server is running..." << endl;
  }
  else 
  {
      cerr << "ERROR: Can't deploy components!" << endl;
      return -1;
  }
  orb->run();
}
\end{lstlisting}
\end{footnotesize}

We save this {\tt \_check\_application\_ccm\_remote\_component\_Server.cc} file
into the component's {\tt test} directory:
\begin{footnotesize}
\begin{verbatim}
Login/c++/server
`-- src
    |-- component
    |   `-- Server
    |       `-- test
    |           `-- _check_application_ccm_remote_component_Server.cc
\end{verbatim}
\end{footnotesize}

This minimal CORBA server code initializes the ORB and deploys the local and
remote component. Remote component deployment also implies the registration of
the component home object at the CORBA name service. 

\vspace{3mm}
Make sure that a CORBA name service is running on your box (e.g. {\tt orbd}
which ist a Java tool):
\begin{footnotesize}
\begin{verbatim}
> orbd -ORBInitialPort 5050
\end{verbatim}
\end{footnotesize}

Finally, we run Confix to build all source files and to start the unit test:
\begin{footnotesize}
\begin{verbatim}
> ccmconfix -makefiles -o src -pname "login" -pversion "1.0.0"

> confix.py --packageroot=`pwd`/src --bootstrap --configure \
            --make --targets=check
\end{verbatim}
\end{footnotesize}

At the end of this build process, you should see the following output:
\begin{footnotesize}
\begin{verbatim}
ServerHome server is running...
\end{verbatim}
\end{footnotesize}


%------------------------------------------------------------------------------
\subsection{Implement a remote component client}
\label{subsection:ImplementRemoteComponentClient}
%------------------------------------------------------------------------------
We implement a remote component client as a simple unit test.
Because this client runs in a separate process (probably on a different machine), we
have to generate and build the CORBA stub and skeleton classes for the client--side 
again:
\begin{footnotesize}
\begin{verbatim}
> ccmidl -idl2 -I../../idl3repo/interface -I../../idl3repo/component \
         -o src/component/Server/CCM_corba_stubs                     \  
         ../../idl3repo/interface/application/*.idl

> ccmidl -idl2 -I../../idl3repo/interface -I../../idl3repo/component \
         -o src/component/Server/CCM_corba_stubs                     \
         ../../idl3repo/component/application/Server*.idl
\end{verbatim}
\end{footnotesize}

In addition to the generated stubs and skeletons, we store the remote test
client in a file named {\tt \_check\_client.cc} in the following directory structure:
\begin{footnotesize}
\begin{verbatim}
Login/c++/client
`-- src
    |-- component
    |   `-- Server
    |       `-- CCM_corba_stubs
    `-- test
        `-- _check_client.cc
\end{verbatim}
\end{footnotesize}

The remote client's implementation follows the structure of a local client but
uses the IDL to C++ mapping specified by the OMG.

\begin{footnotesize}
\begin{lstlisting}[language=C++]
#include <string>
#include <WX/Utils/debug.h>
#include <CCM/CCMContainer.h>

#include <CORBA.h>
#include <coss/CosNaming.h>

#include <application_Server.h>
#include <application_ServerHome.h>

using namespace std;
using namespace WX::Utils;

int main (int argc, char *argv[])
{
    int   argc_   = 3;
    char* argv_[] = { "", 
                    "-ORBInitRef", 
                    "NameService=corbaloc:iiop:1.2@localhost:5050/NameService"};
 
    CORBA::ORB_var orb = CORBA::ORB_init(argc_, argv_);

    CORBA::Object_var obj = orb->resolve_initial_references("NameService");
    CosNaming::NamingContextExt_var nc = CosNaming::NamingContextExt::_narrow(obj);

    // Find ComponentHomes in the Naming-Service
    obj = nc->resolve_str("ServerHome");
    ::application::ServerHome_var home = ::application::ServerHome::_narrow(obj);

    // Create component instances
    ::application::Server_var server = home->create();
    ::application::Login_var login = server->provide_login();
    server->configuration_complete();

	// Run test cases
    try 
    {
      ::application::PersonData person;
      person.id = 277;
      person.name = CORBA::string_dup("eteinik");
      person.password = CORBA::string_dup("eteinik");   
      person.group =  ::application::USER;       
      
      CORBA::Boolean result = login->isValidUser(person);
      
      if(result) 
      {
          cout << "Welcome " << person.name << endl;
      }
      else 
      {
          cout << "We don't know you !!!" << endl;
      }
    }
    catch(::application::InvalidPersonData& e)
    {
      cout << "Error: InvalidPersonData" << endl;	
    }

    try 
    {
      ::application::PersonData person;
      person.id = 0;
      person.name = CORBA::string_dup(""); // Here we create an error!!!
      person.password = CORBA::string_dup("");   
      person.group =  ::application::USER;       
      
      login->isValidUser(person);
      assert(false); 
    }
    catch(::application::InvalidPersonData& e)
    {
      cout << "OK, caught InvalidPersonData exception!" << endl;	
    }

    // Destroy component instances
    server->remove();
}
\end{lstlisting}
\end{footnotesize}

Again, we use Confix to build and run the test client:
\begin{footnotesize}
\begin{verbatim}
> ccmconfix -makefiles -o src -pname "login-remote-client" -pversion "1.0.0"

> confix.py --packageroot=`pwd`/src --bootstrap --configure \
            --make --targets=check
\end{verbatim}
\end{footnotesize}

When you see the following output on the console, you have successfully
implemented the first distributed component application:
\begin{footnotesize}
\begin{verbatim}
Welcome eteinik
OK, caught InvalidPersonData exception!
PASS: login-remote-client__check_client
==================
All 1 tests passed
==================
\end{verbatim}
\end{footnotesize}

The important point is that we did not change the business logic implementation.
Instead, we reused the local component and generated a remote layer using the
CCM Tools.

\newpage