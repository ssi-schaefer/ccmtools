% $Id$
%==============================================================================
\section{Use Case 2: Remote C++ Components}
\label{section:RemoteC++ComponentImplementation}
%==============================================================================

In the second CCM Tools use case, we implement a remote C++ component and a
remote unit test client based on CORBA middleware. 
This use case is adequate for a developers who implements large and distributed
C++ applications.

\vspace{3mm}
The implementation of remote C++ components requires the following activities:
\begin{itemize}
	\item Model a component's structure in IDL 
			(see section~\ref{section:ComponentDefinition}). 
	\item Implement a local C++ component (see section~\ref{section:LocalC++ComponentImplementation}).
	\item Generate remote component logic.
	\item Implement a remote component client.
\end{itemize}

For a given local C++ component implementation, you can generate a set of CORBA
adapters and converters which establish a remote component.
Thus, the step from local to remote C++ components is completely automated by
the CCM Tools.


%------------------------------------------------------------------------------
\subsection{Generate remote component logic}
\label{subsection:GenerateRemoteComponentLogic}
%------------------------------------------------------------------------------

Currently, we use CORBA middleware for inter--process communications, thus, local
interfaces must be adapted to CORBA objects and vice versa.

\vspace{3mm}
To implement CORBA interactions, we need CORBA stub and skeleton classes which
are generated by a particular IDL compiler. While components are modeled in
IDL3, usual IDL compilers assume IDL2 (no keywords like {\tt component} or 
{\tt home}).
For that reason, a separate CCM Tools generator transforms IDL3 to IDL2, as defined in
the CCM specification:
\begin{footnotesize}
\begin{verbatim}
> ccmidl -idl2 -I../../idl3repo/interface -I../../idl3repo/component \
         -o src/component/Server/CCM_corba_stubs                     \  
         ../../idl3repo/interface/application/*.idl

> ccmidl -idl2 -I../../idl3repo/interface -I../../idl3repo/component \
         -o src/component/Server/CCM_corba_stubs                     \
         ../../idl3repo/component/application/Server*.idl
\end{verbatim}
\end{footnotesize}

All generated IDL2 files are stored in a directory called {\tt CCM\_corba\_stubs}:
\begin{footnotesize}
\begin{verbatim}
    Login/c++/server
    |-- component
    |   `-- Server
    |       |-- CCM_corba_stubs
\end{verbatim}
\end{footnotesize}

We go into this {\tt CCM\_corba\_stubs} directory and call the IDL compiler for
every single file (fortunately, the CCM Tools provide a script that can do this
in a single call):
\begin{footnotesize}
\begin{verbatim}
> cd src/component/Server/CCM_corba_stubs
> ccmtools-idl -mico -I${CCMTOOLS_HOME}/idl *.idl
> cd ../../../../
\end{verbatim}
\end{footnotesize}

The transformed IDL2 files include interfaces which are part of the
installed CCM Tools, thus, the IDL compiler needs the include path to {\tt CCMTOOLS\_HOME/idl} .

\vspace{3mm}
As a glue between the local C++ interfaces and the CORBA stubs and skeletons, we
generate some adapters and converters:
\begin{footnotesize}
\begin{verbatim}
> ccmtools c++remote -I../../idl3repo/interface -I../../idl3repo/component \
                     -o src/component/Server/                              \
                     ../../idl3repo/interface/application/*.idl

> ccmtools c++remote -I../../idl3repo/interface -I../../idl3repo/component \
                     -o src/component/Server/                              \
                     ../../idl3repo/component/application/Server*.idl
\end{verbatim}
\end{footnotesize}

All new source files are stored in {\tt CCM\_*\_remote\_*} directories (we call
it remote component logic).
\begin{footnotesize}
\begin{verbatim}
Login/c++/server
`-- src
    |-- component
    |   `-- Server
    |       |-- CCM_application_ccm_remote_component_Server
    |       |-- CCM_application_ccm_remote_corba_converter
    |       `-- CCM_corba_stubs
\end{verbatim}
\end{footnotesize}

Remember, there is no reason to check--in generated component logic into a CVS
like system because this code can be generated from the IDL repository directly.

\vspace{3mm}
That's it. We have extended our local C++ component from 
section~\ref{section:LocalC++ComponentImplementation} to a real remote component 
that can be accessed via CORBA
\footnote{
There is no technical reason to use only CORBA for remote communications.
Future versions of CCM Tools could provide other middleware (e.g. SOAP)
adapters too. } 
middleware.

%------------------------------------------------------------------------------
\subsection{Implement minimal CORBA server}
\label{subsection:ImplementMinimalCorbaAserver}
%------------------------------------------------------------------------------

Before implementing a remote client, we start the remote component as a
stand-alone CORBA server.
To keep things simple, we implement this CORBA server in a single 
{\tt \_check\_*.cc} file:
\begin{footnotesize}
\begin{lstlisting}[language=C++]
#include <string>
#include <WX/Utils/debug.h>
#include <CCM/CCMContainer.h>

#include <CORBA.h>
#include <coss/CosNaming.h>

#include <application/ccm/remote/component/Server/ServerHome_remote.h>
#include <application_Server.h>

using namespace std;
using namespace WX::Utils;

int main (int argc, char *argv[])
{
  char* argv_[] = { "", 
                    "-ORBInitRef", 
                    "NameService=corbaloc:iiop:1.2@localhost:5050/NameService"}; 
  int   argc_ = 3;
  CORBA::ORB_var orb = CORBA::ORB_init(argc_, argv_);

  // Register all value type factories with the ORB  
  CCM::register_all_factories(orb);

  // Deploy local and remote component homes	
  int error = 0;
  error += deploy_application_ccm_local_component_Server_ServerHome("ServerHome");
  error += deploy_application_ccm_remote_component_Server_ServerHome(orb, 
                                                                    "ServerHome");
  if(!error) 
  {
      cout << "ServerHome server is running..." << endl;
  }
  else 
  {
      cerr << "ERROR: Can't deploy components!" << endl;
      return -1;
  }
  orb->run();
}
\end{lstlisting}
\end{footnotesize}

We save this {\tt \_check\_application\_ccm\_remote\_component\_Server.cc} file
into the component's {\tt test} directory:
\begin{footnotesize}
\begin{verbatim}
Login/c++/server
`-- src
    |-- component
    |   `-- Server
    |       `-- test
    |           `-- _check_application_ccm_remote_component_Server.cc
\end{verbatim}
\end{footnotesize}

A minimal CORBA server code initializes the ORB and deploys the local and
remote components. Remote component deployment implies the registration of the
component home object at the CORBA name service. 

\vspace{3mm}
Make sure that you run a CORBA name service on your box (e.g. {\tt orbd} which 
ist a Java tool):
\begin{footnotesize}
\begin{verbatim}
> orbd -ORBInitialPort 5050
\end{verbatim}
\end{footnotesize}

Finally, we run Confix to build all source files and to start the unit test:
\begin{footnotesize}
\begin{verbatim}
> ccmconfix -makefiles -o src -pname "login" -pversion "1.0.0"

> confix.py --packageroot=`pwd`/src --bootstrap --configure \
            --make --targets=check
\end{verbatim}
\end{footnotesize}

At the end of the build process, you should see the following line:
\begin{footnotesize}
\begin{verbatim}
ServerHome server is running...
\end{verbatim}
\end{footnotesize}


%------------------------------------------------------------------------------
\subsection{Implement remote component client}
\label{subsection:ImplementRemoteComponentClient}
%------------------------------------------------------------------------------

We implement the remote component client as a simple unit test.
Because this client runs in a separate process (probably on a different machine), we
have to generate and build the CORBA stub and skeleton classes for the client 
again:
\begin{footnotesize}
\begin{verbatim}
> ccmidl -idl2 -I../../idl3repo/interface -I../../idl3repo/component \
         -o src/component/Server/CCM_corba_stubs                     \  
         ../../idl3repo/interface/application/*.idl

> ccmidl -idl2 -I../../idl3repo/interface -I../../idl3repo/component \
         -o src/component/Server/CCM_corba_stubs                     \
         ../../idl3repo/component/application/Server*.idl
\end{verbatim}
\end{footnotesize}

In addition to the generated stubs and skeletons, we store the remote test
client in a file named {\tt \_check\_client.cc} within the following directory structure:
\begin{footnotesize}
\begin{verbatim}
Login/c++/client
`-- src
    |-- component
    |   `-- Server
    |       `-- CCM_corba_stubs
    `-- test
        `-- _check_client.cc
\end{verbatim}
\end{footnotesize}

The remote client's implementation follows the local client's structure but uses
the IDL to C++ mapping specified by the OMG.

\begin{footnotesize}
\begin{lstlisting}[language=C++]
#include <string>
#include <WX/Utils/debug.h>
#include <CCM/CCMContainer.h>

#include <CORBA.h>
#include <coss/CosNaming.h>

#include <application_Server.h>
#include <application_ServerHome.h>

using namespace std;
using namespace WX::Utils;

int main (int argc, char *argv[])
{
    int   argc_   = 3;
    char* argv_[] = { "", 
                    "-ORBInitRef", 
                    "NameService=corbaloc:iiop:1.2@localhost:5050/NameService"};
 
    CORBA::ORB_var orb = CORBA::ORB_init(argc_, argv_);

    CORBA::Object_var obj = orb->resolve_initial_references("NameService");
    CosNaming::NamingContextExt_var nc = CosNaming::NamingContextExt::_narrow(obj);

    // Find ComponentHomes in the Naming-Service
    obj = nc->resolve_str("ServerHome");
    ::application::ServerHome_var home = ::application::ServerHome::_narrow(obj);

    // Create component instances
    ::application::Server_var server = home->create();
    ::application::Login_var login = server->provide_login();
    server->configuration_complete();

	// Run test cases
    try 
    {
      ::application::PersonData person;
      person.id = 277;
      person.name = CORBA::string_dup("eteinik");
      person.password = CORBA::string_dup("eteinik");   
      person.group =  ::application::USER;       
      
      CORBA::Boolean result = login->isValidUser(person);
      
      if(result) 
      {
          cout << "Welcome " << person.name << endl;
      }
      else 
      {
          cout << "We don't know you !!!" << endl;
      }
    }
    catch(::application::InvalidPersonData& e)
    {
      cout << "Error: InvalidPersonData" << endl;	
    }

    try 
    {
      ::application::PersonData person;
      person.id = 0;
      person.name = CORBA::string_dup(""); // Here we create an error!!!
      person.password = CORBA::string_dup("");   
      person.group =  ::application::USER;       
      
      login->isValidUser(person);
      assert(false); 
    }
    catch(::application::InvalidPersonData& e)
    {
      cout << "OK, caught InvalidPersonData exception!" << endl;	
    }

    // Destroy component instances
    server->remove();
}
\end{lstlisting}
\end{footnotesize}

Again, we use Confix to build and run the test client:
\begin{footnotesize}
\begin{verbatim}
> ccmconfix -makefiles -o src -pname "login-remote-client" -pversion "1.0.0"

> confix.py --packageroot=`pwd`/src --bootstrap --configure \
            --make --targets=check
\end{verbatim}
\end{footnotesize}

When we see the following output on the console, we have successfully
implemented our first distributed component application:
\begin{footnotesize}
\begin{verbatim}
Welcome eteinik
OK, caught InvalidPersonData exception!
PASS: login-remote-client__check_client
==================
All 1 tests passed
==================
\end{verbatim}
\end{footnotesize}

The important point is that we did not change the business logic implementation.
Instead, we reused the local component and generated a remote layer using the
CCM Tools.

\newpage