% $Id$
%==============================================================================
\section{Component Definition}
\label{section:ComponentDefinition}
%==============================================================================

We define components using the CCM Tools 
{\bf Interface Definition Language (IDL)}, which is actually a subset of the
CORBA IDL3 specification.
As shown in the following listing, a component definition may imply the
definition of a component home, one or more interfaces, operation parameters and
exceptions. 

\begin{footnotesize}
\begin{lstlisting}[language=IDL]
    module application
    {
        enum Group { GUEST, USER, ADMIN };

        struct PersonData
        {
            long id;
            string name;
            string password;
            Group group;
        };

        exception InvalidPersonData
        {
            string message;
        };

        interface Login
        {
            boolean isValidUser(in PersonData person)
              raises(InvalidPersonData);
        };

        component Server
        {
            provides Login login; 
        };

        home ServerHome manages Server { };
    };
\end{lstlisting}
\end{footnotesize}

We store these IDL definitions in a file called {\tt Login.idl}:
\begin{footnotesize}
\begin{verbatim}
        Login
        `-- Login.idl
\end{verbatim}
\end{footnotesize}

Here we can give only a short description of these IDL artifacts, you can find 
more information in chapter~\ref{chapter:InterfaceDefinitionLanguage} of this manual.

\begin{itemize}
\item {\bf Modules} (e.g. {\tt application}).\\
Modules combine related IDL definitions into a logical group and prevent
pollution of the global namespace.   
   
\item {\bf User Defined Types} (e.g. {\tt Group}, {\tt PersonData}). \\
In addition to build--in types like {\tt long}, {\tt boolean}, {\tt string}, etc. a 
component designer can define its own types using, for example, {\tt enum} and {\tt struct} declarations.
Such user defined types can act as operation parameters as well as attribute types. 

\item {\bf Exceptions} (e.g. {\tt InvalidPersonData}). \\
To report an error condition, operations can throw one or more exceptions. 
Before we can declare an exception as part of an operation's raises section, we have to
define the exception which is pretty similar to defining a structure type.

\item {\bf Interfaces} (e.g. {\tt Login}). \\
An interface defines a named set of operations and attributes.
Each operation definition contains a result type, operation name, 
parameter list (which can also be empty) and an optional exception list.
In IDL, each operation parameter includes a passing direction:
	\begin{itemize}
	\item {\tt in}: the parameter is passed from the caller to the 
					callee.
	\item {\tt out}: the parameter is passed from the callee back 
					to the caller.
	\item {\tt inout}: the parameter is passed from the caller to 
					the callee, modified and sent back to the caller.
	\end{itemize}

\item {\bf Components} (e.g. {\tt Server}): \\
A component uses interfaces to define input and output ports called facets 
and receptacles. 
While a facet's interface is implemented in the same component, a 
receptacle's interface uses implementations of connected facets of other 
components.

\item {\bf Component Homes} (e.g. {\tt ServerHome}): \\
To have an entry point for component instantiation, we define a component 
home. In the case of an empty home definition, a standard {\tt create()} 
operation will be generated from the CCM Tools.
\end{itemize}

From these few lines of IDL, we can generate a lot of structural code which 
implements the features of the CCM Tools component model.

\newpage
