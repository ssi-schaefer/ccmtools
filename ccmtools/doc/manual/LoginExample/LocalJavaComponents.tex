% $Id$
%==============================================================================
\section{Use Case 3: Local Java Components}
\label{section:LocalJavaComponentImplementation}
%==============================================================================

This CCM Tools use case is very similar to the implementation of local C++
components (see section~\ref{section:LocalC++ComponentImplementation}), and is
intended for developers who implement large but modular Java applications. 

\vspace{3mm}
The implementation of local Java components requires the following activities:
\begin{itemize}
	\item Model a component's structure in IDL 
			(see section~\ref{section:ComponentDefinition}). 
	\item Generate Java component logic (= component skeletons).
	\item Implement a component's business logic in Java.
	\item Implement a component's client in Java.
\end{itemize}

Because of the similarities to local C++ component development, we give a very
brief description of these steps in the next few sections.

%------------------------------------------------------------------------------
\subsection{Generate Java component logic}
\label{subsection:GenerateJavaComponentLogic}
%------------------------------------------------------------------------------

We generate component skeletons from the IDL repository directory:

\begin{verbatim}
> mkdir java
> mkdir java/server
> cd java/server
 
> ccmjava -iface -local                                         \
          -I../../idl3repo/interface -I../../idl3repo/component \ 
          -o ./src-gen                                          \
          ../../idl3repo/interface/application/*.idl

> ccmjava -iface -local                                         \
          -I../../idl3repo/interface -I../../idl3repo/component \
          -o ./src-gen                                          \
          ../../idl3repo/component/application/Server*.idl
\end{verbatim}

After this code generation, the resulting file structure looks like:
\begin{verbatim}
Login/java/server
`-- src-gen
    `-- application
        `-- ccm
            `-- local
\end{verbatim}


%------------------------------------------------------------------------------
\subsection{Implement business logic in Java}
\label{subsection:ImplementBusinessLogicInJava}
%------------------------------------------------------------------------------

We generate the application class skeletons in a separate {\tt src} directory: 
\begin{verbatim}
> ccmjava -app                                                  \
          -I../../idl3repo/interface -I../../idl3repo/component \
          -o ./src                                              \
          ../../idl3repo/component/application/Server*.idl      
\end{verbatim}

In Java, we strictly separate generated component logic ({\tt src-gen})
from business logic ({\tt src}). 
So, as a developer you are responsible for the whole {\tt src} directory tree.

\begin{verbatim}
Login/java/server
|-- src
|   `-- application
|       `-- ccm
|           `-- local
|               |-- ServerHomeFactory.java
|               |-- ServerHomeImpl.java
|               |-- ServerImpl.java
|               `-- ServerloginImpl.java
`-- src-gen
\end{verbatim}


\vspace{3mm}
There is a direct relationship between IDL and generated business logic skeleton
classes:

\begin{itemize}
	\item {ServerHomeFactory.java} \\
	For each component home, a factory class is generated which implements a {\tt create()}
	method that acts as entry point for business logic instantiations.
		  
	\item {\tt ServerHomeImpl.java}\\
	For each component home, an implementation class is generated which provides an
	implementation of the default {\tt create()} operation.

\item {\tt ServerImpl.java}\\
	For each component, an implementation class is generated which provides 
	default implementations of the component's callback operations.
	
\item {\tt ServerloginImpl.*}\\
	For each facet, an implementation class is generated which provides operation
	skeletons for hosting business logic implementations.
\end{itemize}

\vspace{3mm}
Note that these implementation files are not overwritten by the CCM Tools.
The generator replaces only untouched source files, otherwise the new
generated files are stored with a {\tt .new} suffix.

 \vspace{3mm}
To implement the Login example's business logic, you open the 
{\tt ServerloginImpl.java} file and implement the following code snippet:

\begin{footnotesize}
\begin{lstlisting}[language=Java]
public boolean isValidUser(PersonData person)
    throws CCMException, InvalidPersonData
{
    if(person.getName().length() == 0)
       throw new InvalidPersonData();
        
    if(person.getId() == 277
       && person.getName().equals("eteinik")
       && person.getGroup() == Group.USER)
    {
        return true;
    }
    else
    {
        return false;
    }
}    
\end{lstlisting}
\end{footnotesize}

We use Ant to build our Java component example. Here is the adequate
{\tt build.xml} file:
\begin{footnotesize}
\begin{verbatim}
<project name="LoginServer" default="jar">

  <property name="dest" location="." />
  <property name="idl2" location="${dest}/idl2" />
  <property name="build" location="${dest}/build" />
  <property name="src" location="${dest}/src" />
  <property name="src-gen" location="${dest}/src-gen" />
  <property name="lib" location="${dest}/lib" />
  <property name="jarname" location="${lib}/LoginServer" />

  <path id="compile.classpath">
      <pathelement path="${java.class.path}" />
  </path>

  <!-- Create the build directory-->
  <target name="init" description="" >
      <mkdir dir="${build}" />
      <mkdir dir="${lib}" />
  </target>
 
  <!-- Compile generated Java files-->
  <target name="compile" depends="init" description="" >
      <javac srcdir="${src-gen}:${src}" destdir="${build}" 
             debug="on" source="1.5" target="1.5">
          <classpath refid="compile.classpath" />  
      </javac>
  </target>

  <target name="jar" depends="compile" >
      <jar jarfile="${jarname}.jar" basedir="${build}" />
  </target>    

  <!-- Clean up -->
  <target name="clean" description="" >
      <delete dir="${build}" />
      <delete dir="${lib}" />
  </target>
</project>
\end{verbatim}
\end{footnotesize}

You start the build process for this local Java component example with:
\begin{verbatim}
> ant
\end{verbatim}

OK, you have implemented your firts Java component using CCM Tools.


%------------------------------------------------------------------------------
\subsection{Implement a local component client in Java}
\label{subsection:ImplementLocalComponentClient}
%------------------------------------------------------------------------------

To test our local component, we implement a simple {\tt ClientLocal} class
within the {\tt src} directory:
\begin{verbatim}
Login/java/server
|-- src
|   |-- ClientLocal.java
|   `-- application
`-- src-gen
\end{verbatim}

The Java implementation follows the C++ client structure 
(see section~\ref{subsection:ImplementC++BusinessLogic}), 
thus, you can compare both APIs easily.

\begin{footnotesize}
\begin{lstlisting}[language=Java]
import application.ccm.local.*;
import Components.ccm.local.HomeFinder;
import ccm.local.ServiceLocator;

public class ClientLocal
{
    public static void main(String[] args)
    {
        try
        {
            application.ccm.local.ServerHomeDeployment.deploy("ServerHome");
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        try
        {            
            HomeFinder homeFinder = ccm.local.HomeFinder.instance();
            ServerHome home = 
                (ServerHome) homeFinder.find_home_by_name("ServerHome");
            Server server = home.create();
            server.configuration_complete();
            Login login = server.provide_login();
                        
            try
            {
                PersonData person = 
                    new PersonData(277, "eteinik", "eteinik", Group.USER);
                boolean result = login.isValidUser(person);

                if (result)
                {
                    System.out.println("Welcome " + person.getName());
                }
                else
                {
                    System.out.println("We don't know you...");
                }
            }
            catch (InvalidPersonData e)
            {
                System.err.println("Error: InvalidPersonData!");
            }

            try
            {
                PersonData person = new PersonData(0, "", "", Group.USER);
                login.isValidUser(person);
                assert(false);
            }
            catch (InvalidPersonData e)
            {
                System.err.println("OK, caught InvalidPersonData exception!");
            }

            server.remove();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        try
        {
            application.ccm.local.ServerHomeDeployment.undeploy("ServerHome");
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
}
\end{lstlisting}
\end{footnotesize}

To run this test, we start the Ant build and execute the local client
from the command line:

\begin{verbatim}
> ant

> java -enableassertions                              \
       -cp $CCMTOOLS_HOME/lib/ccm-runtime.jar:./build \
       ClientLocal
\end{verbatim}

Now you should see the following console output:
\begin{verbatim}
Welcome eteinik
OK, caught InvalidPersonData exception!
\end{verbatim}

Well done ;-)

\newpage