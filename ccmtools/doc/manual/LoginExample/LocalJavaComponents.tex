% $Id$
%==============================================================================
\section{Use Case 3: Local Java Components}
\label{section:LocalJavaComponentImplementation}
%==============================================================================

In this section, we implement a local Java component and a collocated test
client.
This CCM Tools use case is intended for developers who implement large and
modular Java applications. 

\vspace{3mm}
The implementation of local Java components requires the following activities:
\begin{itemize}
	\item Model a component's structure in IDL 
			(see section~\ref{section:ComponentDefinition}). 
	\item Generate local component logic in Java.
	\item Implement component business logic in Java.
	\item Implement a collocated client in Java.
\end{itemize}

In the following sections, we use the IDL definitions stored in the IDL
repository directory as starting point for all Java code generations. 


%------------------------------------------------------------------------------
\subsection{Generate local component logic in Java}
\label{subsection:GenerateJavaComponentLogic}
%------------------------------------------------------------------------------

A local Java component logic includes a set of Java interfaces ({\tt -iface}
option) and a pure Java implementation ({\tt -local}) of these interfaces which
delegates client calls to the business logic. 
The local Java component logic can be generated from the IDL repository using
CCM Tools:
\begin{footnotesize}
\begin{verbatim}
> mkdir java
> mkdir java/server
> cd java/server
 
> ccmjava -iface -local                                         \
          -I../../idl3repo/interface -I../../idl3repo/component \ 
          -o ./src-gen                                          \
          ../../idl3repo/interface/application/*.idl

> ccmjava -iface -local                                         \
          -I../../idl3repo/interface -I../../idl3repo/component \
          -o ./src-gen                                          \
          ../../idl3repo/component/application/Server*.idl
\end{verbatim}
\end{footnotesize}

This code generation steps result in the following file structure:
\begin{footnotesize}
\begin{verbatim}
Login/java/server
`-- src-gen
    `-- application
        `-- ccm
            `-- local
\end{verbatim}
\end{footnotesize}

In contrast to C++ component logic, in Java we store all generated files into a
temporary directory called {\tt src-gen}.


%------------------------------------------------------------------------------
\subsection{Implement component business logic in Java}
\label{subsection:ImplementBusinessLogicInJava}
%------------------------------------------------------------------------------

A set of generated interfaces act as a defined borderline between component
and business logic. A business logic developer is free to name the
implementation classes as long as the right interfaces will be implemented. 

\vspace{3mm}
As a CCM Tools feature, these implementation classes can be generated with
default implementations (mostly empty method skeletons).
We generate these application class skeletons in a separate directory called {\tt src}: 
\begin{footnotesize}
\begin{verbatim}
> ccmjava -app                                                  \
          -I../../idl3repo/interface -I../../idl3repo/component \
          -o ./src                                              \
          ../../idl3repo/component/application/Server*.idl      
\end{verbatim}
\end{footnotesize}
Note that we strictly separate generated component logic ({\tt src-gen})
from business logic ({\tt src}). 
As a developer, you are responsible for the {\tt src} directory tree - you
better use a CVS like code versioning system to check this directory in.
\begin{footnotesize}
\begin{verbatim}
Login/java/server
|-- src
|   `-- application
|       `-- ccm
|           `-- local
|               |-- ServerHomeFactory.java
|               |-- ServerHomeImpl.java
|               |-- ServerImpl.java
|               `-- ServerloginImpl.java
`-- src-gen
\end{verbatim}
\end{footnotesize}

\vspace{3mm}
There is a direct relationship between IDL definitions and generated business
logic skeleton classes:
\begin{itemize}
	\item {ServerHomeFactory.java} \\
	For each component home, a factory class is generated which implements a {\tt create()}
	method that acts as entry point for business logic instantiations.
		  
	\item {\tt ServerHomeImpl.java}\\
	For each component home, an implementation class is generated which provides an
	implementation of the default {\tt create()} operation.

\item {\tt ServerImpl.java}\\
	For each component, an implementation class is generated which provides 
	default implementations of the component's callback operations.
	
\item {\tt ServerloginImpl.*}\\
	For each facet, an implementation class is generated which provides operation
	skeletons for hosting business logic implementations.
\end{itemize}

\vspace{3mm}
Note that these implementation files are not overwritten by the CCM Tools.
The generator replaces only untouched implementation files, otherwise the 
re--generated files are stored with a {\tt .new} suffix.

 \vspace{3mm}
To implement the Login example's business logic, you open the 
{\tt ServerloginImpl.java} file and implement the following code snippet:
\begin{footnotesize}
\begin{lstlisting}[language=Java]
public boolean isValidUser(PersonData person)
    throws CCMException, InvalidPersonData
{
    if(person.getName().length() == 0)
       throw new InvalidPersonData();
        
    if(person.getId() == 277
       && person.getName().equals("eteinik")
       && person.getGroup() == Group.USER)
    {
        return true;
    }
    else
    {
        return false;
    }
}    
\end{lstlisting}
\end{footnotesize}

We use Ant to build our Java component example. Here is the adequate
{\tt build.xml} file:
\begin{footnotesize}
\begin{verbatim}
<project name="LoginServer" default="compile">

  <property name="build" location="${dest}/build" />
  <property name="src" location="${dest}/src" />
  <property name="src-gen" location="${dest}/src-gen" />

  <path id="compile.classpath">
      <pathelement path="${java.class.path}" />
  </path>

  <target name="init" description="" >
      <mkdir dir="${build}" />
  </target>
 
  <target name="compile" depends="init" description="" >
      <javac srcdir="${src-gen}:${src}" destdir="${build}" 
             debug="on" source="1.5" target="1.5">
          <classpath refid="compile.classpath" />  
      </javac>
  </target>

  <target name="clean" description="" >
      <delete dir="${build}" />
  </target>
</project>
\end{verbatim}
\end{footnotesize}

As you know, you start the Ant build process with:
\begin{footnotesize}
\begin{verbatim}
> ant
\end{verbatim}
\end{footnotesize}

OK, you have implemented your firts Java component using CCM Tools.


%------------------------------------------------------------------------------
\subsection{Implement a collocated client in Java}
\label{subsection:ImplementLocalComponentClient}
%------------------------------------------------------------------------------

To test our local component, we implement a simple {\tt ClientLocal} class
within the component's {\tt src} directory:
\begin{footnotesize}
\begin{verbatim}
Login/java/server
|-- src
|   |-- ClientLocal.java
|   `-- application
`-- src-gen
\end{verbatim}
\end{footnotesize}

The first listing shows a client's setup and tear down code. Before we can use
a component type, we have to call the components {\tt deploy()} method which
instantiates the component's home object and register it to the local {\tt HomeFinder}.
On the other hand, before we terminate an application we have to call a
component's {\tt undeploy()} method to free a component's home object. 
	
\begin{footnotesize}
\begin{lstlisting}[language=Java]
import application.ccm.local.*;
import Components.ccm.local.HomeFinder;
import ccm.local.ServiceLocator;

public class ClientLocal
{
    public static void main(String[] args)
    {
        try
        {
            ServerHomeDeployment.deploy("ServerHome");
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        // TODO: client's business logic implementation

        try
        {
            ServerHomeDeployment.undeploy("ServerHome");
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
}
\end{lstlisting}
\end{footnotesize}

The second listing shows a client's business logic implementation. Note that all
interactions between client and component are based on generated interfaces.

\begin{footnotesize}
\begin{lstlisting}[language=Java]
try
{            
    HomeFinder homeFinder = ccm.local.HomeFinder.instance();
    ServerHome home = (ServerHome) homeFinder.find_home_by_name("ServerHome");
    Server server = home.create();
    server.configuration_complete();
    Login login = server.provide_login();
                        
    try
    {
        PersonData person = new PersonData(277, "eteinik", "eteinik", Group.USER);
        boolean result = login.isValidUser(person);

       if (result)
       {
           System.out.println("Welcome " + person.getName());
       }
       else
       {
           System.out.println("We don't know you...");
       }
    }
    catch (InvalidPersonData e)
    {
        System.err.println("Error: InvalidPersonData!");
    }

    try
    {
        PersonData person = new PersonData(0, "", "", Group.USER);
        login.isValidUser(person);
        assert(false);
    }
    catch (InvalidPersonData e)
    {
        System.err.println("OK, caught InvalidPersonData exception!");
    }

    server.remove();
}
catch (Exception e)
{
    e.printStackTrace();
}
\end{lstlisting}
\end{footnotesize}

To run this test, we start the Ant build process and execute the local client
from the command line:
\begin{footnotesize}
\begin{verbatim}
> ant

> java -enableassertions                              \
       -cp $CCMTOOLS_HOME/lib/ccm-runtime.jar:./build \
       ClientLocal
\end{verbatim}
\end{footnotesize}

Now you should see the following console output:
\begin{footnotesize}
\begin{verbatim}
Welcome eteinik
OK, caught InvalidPersonData exception!
\end{verbatim}
\end{footnotesize}

Well done! 

\newpage
