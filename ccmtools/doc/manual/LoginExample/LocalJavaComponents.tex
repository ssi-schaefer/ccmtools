%==============================================================================
\section{Use Case 3: Local Java Components}
\label{section:LocalJavaComponentImplementation}
%==============================================================================

In this section, we implement a local Java component and a collocated test
client.
This CCM Tools use case is intended for developers who implement large and
modular Java applications. 

\vspace{3mm}
The implementation of local Java components requires the following activities:
\begin{itemize}
	\item Model the component's structure in IDL (see section~\ref{section:ComponentDefinition}). 
	\item Generate the local component logic.
	\item Implement the component business logic.
	\item Implement a collocated component client.
\end{itemize}

In the following sections, we use the IDL definitions stored in the IDL
repository directory as starting point for all Java code generations. 


%------------------------------------------------------------------------------
\subsection{Generate the local component logic}
\label{subsection:GenerateJavaComponentLogic}
%------------------------------------------------------------------------------
A local Java component logic includes a set of Java interfaces ({\tt -iface}
option) and a pure Java implementation ({\tt -local}) which
delegates client calls to the hosted business logic. 
Local Java component logic can be generated from the IDL repository using
the CCM Tools:
\begin{footnotesize}
\begin{verbatim}
> mkdir java
> mkdir java/server
> cd java/server
 
> ccmjava -iface -local                                         \
          -I../../idl3repo/interface -I../../idl3repo/component \ 
          -o ./src-gen                                          \
          ../../idl3repo/interface/application/*.idl

> ccmjava -iface -local                                         \
          -I../../idl3repo/interface -I../../idl3repo/component \
          -o ./src-gen                                          \
          ../../idl3repo/component/application/Server*.idl
\end{verbatim}
\end{footnotesize}

These code generation steps result in the following file structure:
\begin{footnotesize}
\begin{verbatim}
Login/java/server
`-- src-gen
    `-- application
\end{verbatim}
\end{footnotesize}

In contrast to C++ component logic, in Java we store all generated files in a
temporary {\tt src-gen} directory.


%------------------------------------------------------------------------------
\subsection{Implement the component business logic}
\label{subsection:ImplementBusinessLogicInJava}
%------------------------------------------------------------------------------
A set of generated interfaces act as the borderline between component-
and business logic. A business logic developer is free to realize the
implementation classes as long as the right interfaces will be implemented. 

\vspace{3mm}
As a CCM Tools feature, these implementation classes can be generated with
default implementations (mostly empty method skeletons).
These application class skeletons are generated in a separate directory called
{\tt src}: 
\begin{footnotesize}
\begin{verbatim}
> ccmjava -app                                                  \
          -I../../idl3repo/interface -I../../idl3repo/component \
          -o ./src                                              \
          ../../idl3repo/component/application/Server*.idl      
\end{verbatim}
\end{footnotesize}
Note the strict separation between generated component logic ({\tt src-gen})
and business logic ({\tt src}). 
As a developer, you are responsible for the {\tt src} directory tree - you
should use a CVS like code versioning system for this directory.
\begin{footnotesize}
\begin{verbatim}
Login/java/server
|-- src
|   `-- application
|         |-- ServerHomeFactory.java
|         |-- ServerHomeImpl.java
|         |-- ServerImpl.java
|         `-- ServerloginImpl.java
`-- src-gen
\end{verbatim}
\end{footnotesize}

\vspace{3mm}
There is a direct relationship between IDL definitions and generated business
logic skeleton classes:
\begin{itemize}
	\item {\tt ServerHomeFactory.java} \\
	For each component home, a factory class is generated which implements a {\tt create()}
	method that acts as entry point for business logic instantiation.
		  
	\item {\tt ServerHomeImpl.java}\\
	For each component home, an implementation class is generated which provides an
	implementation of the default {\tt create()} method.

\item {\tt ServerImpl.java}\\
	For each component, an implementation class is generated which provides 
	default implementations of the component's callback operations.
	
\item {\tt ServerloginImpl.*}\\
	For each facet, an implementation class is generated which provides
	skeletons for business logic implementations.
\end{itemize}

\vspace{3mm}
Note that these implementation files can not be overwritten by the CCM Tools.
Generators replaces only untouched implementation files, otherwise the 
re--generated files are stored with a '{\tt .new}' suffix.

\vspace{3mm}
To implement the Login example's business logic, you can open the 
{\tt ServerloginImpl.java} file and implement the following code snippet:
\begin{footnotesize}
\begin{lstlisting}[language=Java]
public boolean isValidUser(PersonData person)
    throws CCMException, InvalidPersonData
{
    if(person.getName().length() == 0)
       throw new InvalidPersonData();
        
    if(person.getId() == 277
       && person.getName().equals("eteinik")
       && person.getGroup() == Group.USER)
    {
        return true;
    }
    else
    {
        return false;
    }
}    
\end{lstlisting}
\end{footnotesize}

Ant is used to build the Java component example. Here is an adequate
{\tt build.xml} file:
\begin{footnotesize}
\begin{verbatim}
<project name="LoginServer" default="compile">

  <property name="build" location="build" />
  <property name="src" location="src" />
  <property name="src-gen" location="src-gen" />

  <path id="compile.classpath">
      <pathelement path="${java.class.path}" />
  </path>

  <target name="init" description="" >
      <mkdir dir="${build}" />
  </target>
 
  <target name="compile" depends="init" description="" >
      <javac srcdir="${src-gen}:${src}" destdir="${build}" 
             debug="on" source="1.5" target="1.5">
          <classpath refid="compile.classpath" />  
      </javac>
  </target>

  <target name="clean" description="" >
      <delete dir="${build}" />
  </target>
</project>
\end{verbatim}
\end{footnotesize}

You can start the Ant build process with:
\begin{footnotesize}
\begin{verbatim}
> ant
\end{verbatim}
\end{footnotesize}

OK, you have implemented the firts Java component.


%------------------------------------------------------------------------------
\subsection{Implement a collocated component client}
\label{subsection:ImplementLocalComponentClient}
%------------------------------------------------------------------------------
To test the local component, a simple {\tt ClientLocal} class is implemented in 
the component's {\tt src} directory:
\begin{footnotesize}
\begin{verbatim}
Login/java/server
|-- src
|   |-- ClientLocal.java
|   `-- application
`-- src-gen
\end{verbatim}
\end{footnotesize}

The following listing shows a client's setup and tear down code. Before 
a component type can be used, we call the component's {\tt deploy()} method
which instantiates the component home object and register it to the local {\tt
HomeFinder} singleton.
On the other hand, before we terminate an application we call a
component's {\tt undeploy()} method to free the registered component home
object. 
	
\begin{footnotesize}
\begin{lstlisting}[language=Java]
import application.*;
import Components.HomeFinder;
import ccmtools.local.ServiceLocator;

public class ClientLocal
{
    public static void main(String[] args)
    {
        try
        {
            ServerHomeDeployment.deploy("ServerHome");
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        // TODO: client's business logic implementation

        try
        {
            ServerHomeDeployment.undeploy("ServerHome");
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
}
\end{lstlisting}
\end{footnotesize}

The next listing shows a client's business logic implementation. Note that all
interactions between client and component are based on generated interfaces.

\begin{footnotesize}
\begin{lstlisting}[language=Java]
try
{            
    HomeFinder homeFinder = HomeFinder.instance();
    ServerHome home = (ServerHome) homeFinder.find_home_by_name("ServerHome");
    Server server = home.create();
    server.configuration_complete();
    Login login = server.provide_login();
                        
    try
    {
        PersonData person = new PersonData(277, "eteinik", "eteinik", Group.USER);
        boolean result = login.isValidUser(person);

       if (result)
       {
           System.out.println("Welcome " + person.getName());
       }
       else
       {
           System.out.println("We don't know you...");
       }
    }
    catch (InvalidPersonData e)
    {
        System.err.println("Error: InvalidPersonData!");
    }

    try
    {
        PersonData person = new PersonData(0, "", "", Group.USER);
        login.isValidUser(person);
        assert(false);
    }
    catch (InvalidPersonData e)
    {
        System.err.println("OK, caught InvalidPersonData exception!");
    }

    server.remove();
}
catch (Exception e)
{
    e.printStackTrace();
}
\end{lstlisting}
\end{footnotesize}

To run this test, start the Ant build process and execute the local client
from the command line:
\begin{footnotesize}
\begin{verbatim}
> ant

> java -enableassertions                              \
       -cp $CCMTOOLS_HOME/lib/ccm-runtime.jar:./build \
       ClientLocal
\end{verbatim}
\end{footnotesize}

Now, you should see the following console output:
\begin{footnotesize}
\begin{verbatim}
Welcome eteinik
OK, caught InvalidPersonData exception!
\end{verbatim}
\end{footnotesize}

Well done! 

\newpage
