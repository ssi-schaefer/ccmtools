% $Id$
%==============================================================================
\section{Use Case 4: Remote Java Components}
\label{section:RemoteJavaComponentImplementation}
%==============================================================================

In this CCM Tools use case, we implement a remote Java component and a local
test client which uses a Java client library component.
This use case is adequate for developers who implement large and distributed
Java applications.
 
\vspace{3mm}
The implementation of remote Java components requires the following activities:
\begin{itemize}
	\item Model a component's structure in IDL 
			(see section~\ref{section:ComponentDefinition}). 
	\item Implement a local Java component (see section~\ref{section:LocalJavaComponentImplementation}).
	\item Generate remote component logic in Java.
	\item Implement a minimal CORBA server in Java.
	\item Generate a client library component in Java.
	\item Implement a local component client in Java.
\end{itemize}

You will see in the next sections that most of the development steps from local
to remote Java components is completely automated by the CCM Tools.

\vspace{3mm}
This section assumes that there is already a local Java component implementation
which we can transform into a remote one.


%------------------------------------------------------------------------------
\subsection{Generate remote component logic in Java}
\label{subsection:GenerateRemoteComponentLogicJava}
%------------------------------------------------------------------------------
For remote Java components, we use CORBA middleware to overcome process
boundaries, thus, for noncritical applications you can simply use the Java
build--in ORB.
To turn a local Java component into a remote component, we have to generate CORBA
stubs and skeletons as well as a bunch of adapter and converter classes.

\vspace{3mm}
Generation of CORBA stubs and skeletons includes an IDL3 to IDL2 transformation
and calls to an extern IDL compiler. Here we use the CCM Tools script {\tt ccmtools-idl}
to call Java's build--in IDL compiler:
\begin{footnotesize}
\begin{verbatim}
> ccmidl -idl2                                                 \
         -I../../idl3repo/interface -I../../idl3repo/component \ 
         -o ./src-gen/idl2                                     \
         ../../idl3repo/interface/application/*.idl

> ccmidl -idl2                                                 \ 
         -I../../idl3repo/interface -I../../idl3repo/component \
         -o ./src-gen/idl2                                     \
         ../../idl3repo/component/application/Server*.idl

> ccmtools-idl -java                                    \
               -I${CCMTOOLS_HOME}/idl -I./src-gen/idl2  \ 
               -o ./src-gen                             \
               ./src-gen/idl2/*.idl
\end{verbatim}
\end{footnotesize}

Another pair of CCM Tools calls create the adapter and converter classes:
\begin{footnotesize}
\begin{verbatim}
> ccmjava -remote                                               \
          -I../../idl3repo/interface -I../../idl3repo/component \
          -o ./src-gen                                          \
          ../../idl3repo/interface/application/*.idl 

> ccmjava -remote                                               \
          -I../../idl3repo/interface -I../../idl3repo/component \ 
          -o ./src-gen                                          \
          ../../idl3repo/component/application/Server*.idl
\end{verbatim}
\end{footnotesize}

After all, we see the following directory structure: 
\begin{footnotesize}
\begin{verbatim}
Login/java/server
`-- src-gen
    |-- application
    |   `-- ccm
    |       |-- local
    |       `-- remote
    `-- idl2
\end{verbatim}
\end{footnotesize}

Each single file in this {\tt src-gen} directory has been generated, therefore, 
there is no need for a CVS like check--in.


%------------------------------------------------------------------------------
\subsection{Implement minimal CORBA server in Java}
\label{subsection:ImplementMinimalCorbaServerJava}
%------------------------------------------------------------------------------

To startup the remote component, we implement a minimal CORBA server which
simply initialize the ORB with passed command line parameters, deploys the remote
component home and runs the ORB.

\begin{footnotesize}
\begin{lstlisting}[language=Java]
import org.omg.CORBA.ORB;
import ccm.local.ServiceLocator;

public class Server
{
    public static void main(String[] args)
    {
        try
        {
            // Set up the ServiceLocator singleton
            ORB orb = ORB.init(args, null);
            ServiceLocator.instance().setCorbaOrb(orb);

            application.ccm.remote.ServerHomeDeployment.deploy("ServerHome");
            System.out.println("ServerHome server is running...");
            orb.run();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
\end{lstlisting}
\end{footnotesize}

This server class called {\tt Server} is stored in the {\tt src} directory:
\begin{footnotesize}
\begin{verbatim}
Login/java/server
|-- src
|   |-- Server.java
|   `-- application
\end{verbatim}
\end{footnotesize}

Don't forget to start a CORBA name service, because a component deployment
implies the registration of the component's home object.
\begin{footnotesize}
\begin{verbatim}
> orbd -ORBInitialPort 5050
\end{verbatim}
\end{footnotesize}

We run the same Ant build script we have already used for building the
local Java component. 
\begin{footnotesize}
\begin{verbatim}
> ant
\end{verbatim}
\end{footnotesize}

Finally, we can start the minimal CORBA server to activate our remote component:
\begin{footnotesize}
\begin{verbatim}
> java -enableassertions                               \
       -cp $CCMTOOLS_HOME/lib/ccm-runtime.jar:./build  \
       Server                                          \
       -ORBInitRef NameService=corbaloc:iiop:1.2@localhost:5050/NameService
\end{verbatim}
\end{footnotesize}

Your console output should look like:
\begin{footnotesize}
\begin{verbatim}
ServerHome server is running...
\end{verbatim}
\end{footnotesize}


%------------------------------------------------------------------------------
\subsection{Generate a client library component in Java}
\label{subsection:GenerateClientLibComponentInJava}
%------------------------------------------------------------------------------

We have seen that a local component can be extended to a remote component
without any business logic changes.
To bring the same advantage to the client side, CCM Tools support so called
{\bf Client Library Components} which are a local proxies for remote components.
Client library components implement the same interfaces as local components and
delegate each local call to the corresponding remote components.
 
\vspace{3mm}
Remote clients need CORBA stubs and skeletons of the used IDL interfaces.
As a matter of course, this redundant step can be skipped if you develop both
remote component and client on the same box.
\begin{footnotesize}
\begin{verbatim}
> ccmidl -idl2                                                 \
         -I../../idl3repo/interface -I../../idl3repo/component \ 
         -o ./src-gen/idl2                                     \
         ../../idl3repo/interface/application/*.idl

> ccmidl -idl2                                                 \ 
         -I../../idl3repo/interface -I../../idl3repo/component \
         -o ./src-gen/idl2                                     \
         ../../idl3repo/component/application/Server*.idl

> ccmtools-idl -java                                   \
               -I${CCMTOOLS_HOME}/idl -I./src-gen/idl2 \ 
               -o ./src-gen                            \
               ./src-gen/idl2/*.idl
\end{verbatim}
\end{footnotesize}

On top of CORBA stubs and skeletons we generate the client library component:
\begin{footnotesize}
\begin{verbatim}
> ccmjava -iface -clientlib                                     \
          -I../../idl3repo/interface -I../../idl3repo/component \
          -o ./src-gen                                          \
          ../../idl3repo/interface/application/*.idl

> ccmjava -iface -clientlib                                     \
          -I../../idl3repo/interface -I../../idl3repo/component \
          -o ./src-gen                                          \
          ../../idl3repo/component/application/Server*.idl
\end{verbatim}
\end{footnotesize}

As you can see from the CCM Tools calls, all generated files are collected in
the temporary {\tt src-gen} directory.



%------------------------------------------------------------------------------
\subsection{Implement local component client in Java}
\label{subsection:ImplementRemoteComponentClientInJava}
%------------------------------------------------------------------------------

Based on the generated client library component, we can implement a
component's client much like a regular local Java component client.

\vspace{3mm}
As you can see in the following listing, only the client's setup and tear down
sections are different to the local component client implementation:
\begin{footnotesize}
\begin{lstlisting}[language=Java]
import org.omg.CORBA.ORB;
import application.ccm.local.*;
import Components.ccm.local.HomeFinder;
import ccm.local.ServiceLocator;

public class Client
{
    public static void main(String[] args)
    {
        try
        {
            ORB orb = ORB.init(args, null);
            ServiceLocator.instance().setCorbaOrb(orb);
            ServerHomeClientLibDeployment.deploy("ServerHome");
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        // TODO: client's business logic implementation 
        //       (see collocated client implementation)
        
        try
        {
            ServerHomeClientLibDeployment.undeploy("ServerHome");
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
}
\end{lstlisting}
\end{footnotesize}

We store the client class in a {\tt src} directory:
\begin{footnotesize}
\begin{verbatim}
Login/java/client
|-- src
|   `-- Client.java
`-- src-gen
\end{verbatim}
\end{footnotesize}

As a client--side Ant build script we can reuse the script from the server--side.
\begin{footnotesize}
\begin{verbatim}
> ant
\end{verbatim}
\end{footnotesize}

Make sure that the remote component is running before you start the client with:
\begin{footnotesize}
\begin{verbatim}
> java -enableassertions                               \
       -cp $CCMTOOLS_HOME/lib/ccm-runtime.jar:./build  \
       Client                                          \
       -ORBInitRef NameService=corbaloc:iiop:1.2@localhost:5050/NameService
\end{verbatim}
\end{footnotesize}

\begin{footnotesize}
\begin{verbatim}
Welcome eteinik
OK, caught InvalidPersonData exception!
\end{verbatim}
\end{footnotesize}
Congratulations, your remote Java component is working now!

\newpage
