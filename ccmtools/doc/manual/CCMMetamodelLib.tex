%******************************************************************************
\chapter{CCM Metamodel Library}
\label{chapter:ccm-metamodel-library}
%******************************************************************************

%==============================================================================
\section{Introduction}
%==============================================================================

The CORBA Component Model (CCM) specification defines a CCM metamodel
(\cite{CCMSpecification}, chapter 8 ``Interface Repository Metamodel'') that can
be used to represent the syntax of an IDL3 file.

The CCM Tools implement a CCM metamodel library that can be used to establish a
CCM model in memory. The CCM metamodel library is very similar to the UML
metamodel library from NovoSoft~\cite{FIXME}. The library supports navigation
between the different objects of the model as well as access methods to their
attributes.

\begin{figure}[htbp]
\centering
\includegraphics [width=13cm,angle=0] {CCMMetamodelLib}
\caption{CCM metamodel library.}
\label{fig:metamodel-CCMMetamodelLib}
\end{figure}

As shown in Figure~\ref{fig:metamodel-CCMMetamodelLib} the CCM metamodel library
can be used by a IDL3 parser to represent the syntax in memory. On the other
side a code generator tool can use the model to create code fragments.

Figure~\ref{fig:metamodel-CCMMetamodelLib} actually describes the particular
case where the IDL3 parser (see Chapter~\cite{chapter:idl3-parser}reads the IDL3
source code and generates a CCM model in memory, while the code generator uses
the CCM model to generate IDL3 source code. This generation task is proof that
the CCM metamodel describes the IDL3 syntax exhaustively.

%==============================================================================
\section{CCM Metamodel Library API}
%==============================================================================

This chapter describes how to use the CCM metamodel library (written in Java) to
create a CCM model in memory and navigate in this model to get some information
about its entries. The library is strongly based on chapter 8 of the CCM
specification, so it would be useful to have a copy of the specification next to
you.

There is also {\tt javadoc} documentation in the {\tt
ccm/tools/Metamodel/doc/api} directory that can be used as an API reference.

%==============================================================================
\subsection{Implementation details}
%==============================================================================

The CCM metamodel library is separated into two parts (representing the classic
and the component based parts of the IDL):

\begin{description}
\item [{\tt ccm.mof.BaseIDL}] Contains all classes to model the classic CORBA
      IDL syntax.
\item [{\tt ccm.mof.ComponentIDL}] Contains the ccm extensions from the CORBA
      Component Model to model components, homes etc.
\end{description}

These two parts are available in the {\tt ccmtools.jar} file, or as individual
source code files. To use the library, the {\tt ccmtools.jar} file needs to be
added to the Java {\tt CLASSPATH} environment variable. Programs using the
library need to include the following import statements:

\begin{verbatim}
import ccm.mof.BaseIDL.*;
import ccm.mof.ComponentIDL.*;
\end{verbatim}

Based on the CCM MOF metamodel specification, this implementation defines an
interface for every class in the metamodel. The name of the interface is the
same as the name of the class, with an `{\tt M}' prepended. For example, the
interface for the {\tt HomeDef} class in the metamodel is defined show in
Example~\ref{example:metamodel-mhomedef-interface}.

\begin{Example}
\begin{minifbox}
\begin{verbatim}
public interface MHomeDef
    extends MInterfaceDef
{
    //...
}
\end{verbatim}
\caption{Definition of MHomeDef interface.}
\label{example:metamodel-mhomedef}
\end{minifbox}
\end{Example}

To use the metamodel library, there must be an implementation of the defined
interface functionality. So there is an implementation class for every
interface. The implementation classes have the same name as the interface, with
the string `{\tt Impl}' appended. For example, the implementation class for {\tt
HomeDef} is defined as shown in Example~\ref{example:metamodel-mhomedefimpl}.

\begin{Example}
\begin{minifbox}
\begin{verbatim}
public class MHomeDefImpl
    implements MHomeDef
{
    /...
}
\end{verbatim}
\caption{Definition of MHomeDefImpl implementation class.}
\label{example:metamodel-mhomedefimpl}
\end{minifbox}
\end{Example}

It is good Java programming style to use an interface---not the implementation
class---to define the type of an object. This allows for multiple realizations
of a given interface. So, for example, a CCM MOF Library client application
should create an instance of {\tt HomeDef} as follows:

\begin{verbatim}
MHomeDef myHome = new MHomeDefImpl();
\end{verbatim}

For debugging, you can use the {\tt toString()} method of every implementation
class to get information about the specific object. All \verb+toString()+
methods in the CCM MOF Library start with interface type, followed by a colon
(:). To use these methods, just use a metamodel object in a printing context:

\begin{verbatim}
System.out.println(myHome);
\end{verbatim}

%==============================================================================
\subsection{Access to attributes}
%==============================================================================

Metamodel classes may contain attributes whose types are boolean, non--boolean
or an array. Each attribute in a metamodel class is mapped to a set of accessor
methods in the library.

%------------------------------------------------------------------------------
\subsubsection{Access to boolean attributes}
%------------------------------------------------------------------------------

If a metamodel class contains a boolean attribute, the attribute name will
always start with `{\tt is}'. The get--method has the same name as the
attribute. The set--method replaces `{\tt is}' with the prefix `{\tt set}'. For
example, the {\tt isAbstract} attribute in the {\tt InterfaceDef} class of the
metamodel is mapped to the code shown in
Example~\ref{example:metamodel-boolean-attribute}. The implementation class of
{\tt InterfaceDef} is shown in
Example~\ref{example:metamodel-boolean-attribute-impl}.

\begin{Example}
\begin{minifbox}
\begin{verbatim}
public interface MInterfaceDef
    extends MContainer
{
    // attribute isAbstract:boolean
    boolean isAbstract();
    void setAbstract(boolean __arg);

    //...
}
\end{verbatim}
\end{minifbox}
\caption{Boolean--attribute access functions in the InterfaceDef interface.}
\label{example:metamodel-boolean-attribute}
\end{Example}

\begin{Example}
\begin{minifbox}
\begin{verbatim}
public class MInterfaceDefImpl
    implements MInterfaceDef
{
    private boolean isAbstract_;

    // attribute isAbstract:boolean
    public boolean isAbstract()
    { return isAbstract_; }
    public void setIsAbstract(boolean __arg)
    { isAbstract_ = __arg; }

    //...
}
\end{verbatim}
\end{minifbox}
\caption{Boolean--attribute access functions in the InterfaceDef class
implementation.}
\label{example:metamodel-boolean-attribute-impl}
\end{Example}

%------------------------------------------------------------------------------
\subsubsection{Access to non--boolean attributes}
%------------------------------------------------------------------------------

If a metamodel class contains a non--boolean attribute, the get--method has the
prefix `{\tt get}' followed by the capitalized name of the attribute. The
set--method has the prefix `{\tt set}' followed by the capitalized name of the
attribute. For example, the {\tt identifier} attribute in the {\tt OperationDef}
class of the metamodel is mapped to the code shown in
Example~\ref{example:metamodel-non-boolean-attribute}. The implementation class
of {\tt OperationDef} is shown in
Example~\ref{example:metamodel-non-boolean-attribute-impl}.

\begin{Example}
\begin{minifbox}
\begin{verbatim}
public interface MOperationDef
    extends MContained, MTyped
{
    // attribute identifier:string
    String getIdentifier();
    void setIdentifier(String __arg);

    // ...
}
\end{verbatim}
\end{minifbox}
\caption{Non--boolean--attribute access functions for the OperationDef
interface.}
\label{example:metamodel-non-boolean-attribute}
\end{Example}

\begin{Example}
\begin{minifbox}
\begin{verbatim}
public class MOperationDefImpl
    implements MOperationDef
{
    private String identifier_;

    // attribute identifier:string
    public String getIdentifier()
    { return identifier_; }
    public void setIdentifier(String __arg)
    { identifier_ = __arg; }

    //...
}
\end{verbatim}
\end{minifbox}
\caption{Non--boolean--attribute access implementation for OperationDef.}
\label{example:metamodel-non-boolean-attribute-impl}
\end{Example}

%------------------------------------------------------------------------------
\subsubsection{Access to array attributes}
%------------------------------------------------------------------------------

If a metamodel class contains array attributes, then the class will also include
get-- and set--methods for single attributes. The class stores array attributes
internally in either a Set or a List, depending on the nature of the attribute.
The class also includes accessor methods for direct access to an attribute at a
specific position within the array. For example, the {\tt members} attribute in
the {\tt EnumDef} class of the metamodel is mapped to the code shown in
Example~\ref{example:metamodel-array-attribute}. The implementation of {\tt
EnumDef} is shown in Example~\ref{example:metamodel-array-attribute-impl}.

\begin{Example}
\begin{minifbox}
\begin{verbatim}
public interface MEnumDef
    extends MTypedefDef
{
    // attribute members:String[]
    List getMembers();
    void setMembers(List __arg);
    void addMember(String __arg);
    void removeMember(String __arg);
    void addMember(int __pos, String __arg);
    void removeMember(int __pos);
    void setMember(int __pos, String __arg);
    String getMember(int __pos);
}
\end{verbatim}
\end{minifbox}
\caption{Array--attribute access functions in the EnumDef interface.}
\label{example:metamodel-array-attribute}
\end{Example}

\begin{Example}
\begin{minifbox}
\begin{verbatim}
public class MEnumDefImpl
    implements MEnumDef
{
    private List MemberList_;

    public List getMembers()
    { return MemberList_; }
    public void setMembers(List __arg)
    { MemberList_ = new ArrayList(__arg); }
    public void addMember(String __arg)
    { MemberList_.add(__arg); }
    public void removeMember(String __arg)
    { MemberList_.remove(__arg); }

    public void addMember(int __pos, String __arg)
    { MemberList_.add(__pos, __arg);}
    public void removeMember(int __pos)
    { MemberList_.remove(__pos); }
    public void setMember(int __pos, String __arg)
    { MemberList_.set(__pos, __arg); }
    public String getMember(int __pos)
    { return (String)MemberList_.get(__pos); }

    //...
}
\end{verbatim}
\end{minifbox}
\caption{Array--attribute access implementation in the EnumDef class.}
\label{example:metamodel-array-attribute-impl}
\end{Example}

%==============================================================================
\subsection{Access to associations}
%==============================================================================

Each association in the metamodel has two roles, where each role has a name and
a multiplicity. The role attached to an element is the {\em direct role}, and
the role on the other side of the association is called the {\em opposite role}.
There are three different types of roles in the CCM metamodel: reference, bag,
and list. Each type of association has its own set of navigation methods.

%------------------------------------------------------------------------------
\subsubsection{Reference role}
%------------------------------------------------------------------------------

A reference role has a multiplicity of {\tt 1} or {\tt 0..1}. These roles have
the same access methods as seen by non--boolean attributes. For example, the
association between the {\tt Typed} and {\tt IDLType} class of the metamodel is
mapped to the code shown in Example~\ref{example:metamodel-reference-attribute}. The
implementation of {\tt EnumDef} is shown in
Example~\ref{example:metamodel-reference-attribute-impl}.

\begin{Example}
\begin{minifbox}
\begin{verbatim}
public interface MTyped
{
    // ...

    // association: direct role: [*] -->
    //              opposide role: idlType[1]
    MIDLType getIdlType();
    void setIdlType(MIDLType __arg);

    // ...
}
\end{verbatim}
\end{minifbox}
\caption{Reference attribute access functions in the MTyped interface.}
\label{example:metamodel-reference-attribute}
\end{Example}

\begin{Example}
\begin{minifbox}
\begin{verbatim}
public class MTypedImpl
    implements MTyped
{
    // ...

    private MIDLType TypedBy_;

    // ...

    // association: direct role: [*] -->
    //              opposite role: idlType[1]
    public MIDLType getIdlType()
    { return TypedBy_; }
    public void setIdlType(MIDLType __arg)
    { TypedBy_ = __arg; }

    // ...
}
\end{verbatim}
\end{minifbox}
\caption{Reference attribute access functions in the MTypedImpl class.}
\label{example:metamodel-reference-attribute-impl}
\end{Example}

%------------------------------------------------------------------------------
\subsubsection{Bag role}
%------------------------------------------------------------------------------

A bag role has an unordered multiplicity different from {\tt 1} or {\tt 0..1}.
Bag roles refer to attributes stored internally as Sets, where order is
unimportant. For example, the association between the {\tt Container} and {\tt
Contained} classes of the metamodel is mapped to the code shown in in
Example~\ref{example:metamodel-bag-attribute}. The implementation of {\tt
EnumDef} is shown in Example~\ref{example:metamodel-bag-attribute-impl}.

\begin{Example}
\begin{minifbox}
\begin{verbatim}
public interface MContainer
    extends MContained
{
    // ...

    // assocation: direct role: definedIn[0..1] <->
    //             opposite role: contents[*]
    Set getContentss();
    void setContentss(Set __arg);
    void addContents(MContained __arg);
    void removeContents(MContained __arg);

    //...
}
\end{verbatim}
\end{minifbox}
\caption{Bag role access functions in the MContainer interface.}
\label{example:metamodel-bag-attribute}
\end{Example}

\begin{Example}
\begin{minifbox}
\begin{verbatim}
public class MContainerImpl
    implements MContainer
{
    // ...

    private Set ContainsSet_;

    // ...

    // assocation: direct role: definedIn[0..1] <->
    //             opposite role: contents[*]
    public Set getContentss()
    { return ContainsSet; }
    public void setContentss(Set __arg)
    { ContainsSet = new HashSet(__arg); }
    public void addContents(MContained __arg)
    { ContainsSet.add(__arg); }
    public void removeContents(MContained __arg)
    { ContainsSet.remove(__arg); }

    //...
}
\end{verbatim}
\end{minifbox}
\caption{Bag role attribute access functions in the MContainerImpl
implementation class.}
\label{example:metamodel-bag-attribute-impl}
\end{Example}

%------------------------------------------------------------------------------
\subsubsection{List role}
%------------------------------------------------------------------------------

A list role has an ordered multiplicity other than {\tt 1} or {\tt 0..1}. List
roles refer to attributes stored internally as Lists, where order is important.
Thus, these roles have the same set of access functions as ordered array
attributes. For example, the association between the {\tt OperationDef} and {\tt
ParameterDef} classes is mapped to the code shown in
Example~\ref{example:metamodel-list-attribute}. The implementation of {\tt
EnumDef} is shown in Example~\ref{example:metamodel-list-attribute-impl}.

\begin{Example}
\begin{minifbox}
\begin{verbatim}
public interface MOperationDef
    extends MContained, MTyped
{
    // ...

    // aggregation: direct role: operation[0..1] <->
    //              opposite role: parameter[*]
    List getParameters();
    void setParameters(List __arg);
    void addParameter(MParameterDef __arg);
    void removeParameter(MParameterDef __arg);

    void addParameter(int __pos, MParameterDef __arg);
    void removeParameter(int __pos);
    void setParameter(int __pos, MParameterDef __arg);
    MParameterDef getParameter(int __pos);

    // ...
}
\end{verbatim}
\end{minifbox}
\caption{List role attribute access functions in the MOperationDef interface.}
\label{example:metamodel-list-attribute}
\end{Example}

The implementation class of {\tt Container} is shown below:

\begin{Example}
\begin{minifbox}
\begin{verbatim}
public class MOperationDefImpl
    implements MOperationDef
{
    // ...

    private List ParameterList_;

    // ...

    // aggregation: direct role: operation[0..1] <->
    //              opposite role: parameter[*]
    public List getParameters()
    { return ParameterList_; }
    public void setParameters(List __arg)
    { ParameterList_ = new ArrayList(__arg); }
    public void addParameter(MParameterDef __arg)
    { ParameterList_.add(__arg); }
    public void removeParameter(MParameterDef __arg)
    { ParameterList_.remove(__arg); }

    public void addParameter(int __pos,
                             MParameterDef __arg)
    { ParameterList_.add(__pos, __arg); }
    public void removeParameter(int __pos)
    { ParameterList_.remove(__pos); }
    public void setParameter(int __pos,
                             MParameterDef __arg)
    { ParameterList_.set(__pos, __arg); }
    public MParameterDef getParameter(int __pos)
    { return (MParameterDef)ParameterList_.get(__pos); }

    //...
}
\end{verbatim}
\end{minifbox}
\caption{List role attribute access functions in the MOperationDefImpl class.}
\label{example:metamodel-list-attribute-impl}
\end{Example}

%==============================================================================
\section{Examples}
%==============================================================================

%------------------------------------------------------------------------------
\subsection{Using the CCM to model IDL statements}
%------------------------------------------------------------------------------

This section shows the practical usage of the CCM metamodel library ({\tt
ccm.mof.BaseIDL} and {\tt ccm.mof.ComponentIDL}). In its current state, the
library can be used to create CCM models in memory and to navigate within these
models to get information about the model entities.

Each IDL statement can be modelled using the CCM metamodel library. For example,
a parser can read IDL source code and generate the corresponding CCM model.
Normally, this CCM model gets passed to a code generator tool to create C++,
Java, or Python.

%------------------------------------------------------------------------------
\subsection{Base IDL examples}
%------------------------------------------------------------------------------

All examples in this section can be implemented using just the {\tt
ccm.mof.BaseIDL} library. Only classic CORBA statements may be put into CCM
models that only use the Base IDL.

%---------------------------------------
\subsubsection{IDL Enum}
%---------------------------------------

Example~\ref{example:metamodel-baseidl-enum} shows the creation of an IDL enum
type. After creating the model, the {\tt toString()} method is used to print out
the model of the enum.

\begin{Example}
\begin{minifbox}
\begin{verbatim}
  /*
   *  enum Color { red, green, blue, black );
   */

   MEnumDef enum = new MEnumDefImpl();
   enum.setIdentifier("Color");
   enum.addMember("red");
   enum.addMember("green");
   enum.addMember("blue");
   enum.addMember("black");

   System.out.println(enum);
\end{verbatim}
\end{minifbox}
\caption{Example enumeration instantiation using the Base IDL.}
\label{example:metamodel-baseidl-enum}
\end{Example}

%---------------------------------------
\subsubsection{IDL Struct}
%---------------------------------------

Example~\ref{example:metamodel-baseidl-struct} shows the creation of an IDL
struct and two exception types in the method {\tt createModel()}. The {\tt
printModel()} method in Example~\ref{example:metamodel-baseidl-struct-print}
iterates through the model and prints the contained items.

\begin{Example}
\begin{minifbox}
\begin{verbatim}
public static MContainer createModel()
{
  /*
   * struct LbaRecord
   * {
   *    string AuftragsNr;
   *    string WENr;
   * };
   *
   * exception LbaReadException {};
   * exception LbaWriteException {};
   */

   MContainer idl = new MContainerImpl();

   MStructDef struct1 = new MStructDefImpl();
   struct1.setIdentifier("LbaRecord");

   MPrimitiveDef pd1 = new MPrimitiveDefImpl();
   pd1.setKind(MPrimitiveKind.PK_STRING);
   MField f1 = new MFieldImpl();
   f1.setIdentifier("AuftragsNr");
   f1.setIdlType(pd1);
   struct1.addMember(f1);

   MPrimitiveDef pd2 = new MPrimitiveDefImpl();
   pd2.setKind(MPrimitiveKind.PK_STRING);
   MField f2 = new MFieldImpl();
   f2.setIdentifier("WENr");
   f2.setIdlType(pd2);
   struct1.addMember(f2);

   MExceptionDef e1 = new MExceptionDefImpl();
   e1.setIdentifier("LbaReadException");

   MExceptionDef e2 = new MExceptionDefImpl();
   e2.setIdentifier("LbaWriteException");

   idl.addContents(struct1);
   idl.addContents(e1);
   idl.addContents(e2);

   return idl;
}
\end{verbatim}
\end{minifbox}
\caption{Example struct instantiation using the Base IDL.}
\label{example:metamodel-baseidl-struct}
\end{Example}

\begin{Example}
\begin{minifbox}
\begin{verbatim}
public static void printModel(MContainer c)
{
   Iterator it = c.getContentss().iterator();
   while(it.hasNext()) {
      MContained element =(MContained)it.next();
      if(element instanceof MStructDef) {
         MStructDef struct = (MStructDef)element;
         System.out.println(struct);
         Iterator elementIterator =
            struct.getMembers().iterator();
         while(elementIterator.hasNext()) {
            MField field =
               (MField)elementIterator.next();
            System.out.println(" + " + field + " : " +
                               field.getIdlType());
         }
      }
      else {
         System.out.println(element);
      }
   }
}
\end{verbatim}
\end{minifbox}
\caption{Example method to print out the fields of a struct model.}
\label{example:metamodel-baseidl-struct-print}
\end{Example}

%------------------------------------------------------------------------------
\subsection{Component IDL examples}
%------------------------------------------------------------------------------

All examples in this section require both the {\tt ccm.mof.BaseIDL} and {\tt
ccm.mof.ComponentIDL} libraries.

%==============================================================================
\section{Extensions to the CCM specification}
%==============================================================================

While implementing and using the CCM metamodel library we encountered a few
errors, typos, and shortcomings in the specification. This section lists these
difficulties and describes our attempts to solve them for our project.

Our work with the library so far has only taken place in the context of
implementing a series of code generators, so we have been approaching the
library and CCM metamodel specification from only a few angles (mostly IDL
parsing and C++ code generation). These problems reflect our singular points of
view only and are mentioned here in the spirit of making the CCM metamodel
specification a solid, practical, complete standard. Also, this is not intended
to be a complete bug list for the CCM metamodel specification, but rather a
simple list of some points that have come up during our work.

%------------------------------------------------------------------------------
\subsection{Fields and union fields}
%------------------------------------------------------------------------------

We changed the MField and MUnionField classes to MFieldDef and MUnionFieldDef,
respectively. Along with this change, we added DK\_FIELD and DK\_UNIONFIELD to
the MDefinitionKind enumeration. The reasoning in these two cases basically
involves the following two points :

\begin{enumerate}
\item MField and MUnionField objects have an identifier member parameter and
      associated getIdentifier() and setIdentifier() methods. Thus, they should
      be locatable objects just like MParameterDef, MOperationDef, or
      MInterfaceDef (all of which also have an identifier member parameter and
      associated access member functions). However, without an associated
      DefinitionKind, it will be impossible to use the lookupName() functions to
      find MField and MUnionField objects when type limiting is enabled.
\item MField and MUnionField objects behave quite similarly to MParameterDef
      objects. MParameterDef objects have an associated DefinitionKind and
      should be treated in the same manner as the MField and MUnionField
      objects.
\end{enumerate}

%------------------------------------------------------------------------------
\subsection{Homes and components}
%------------------------------------------------------------------------------

As we have implemented them, a 1--to--many correspondence exists between
components and homes. That is, each component might have 1 or more homes, and a
home must have exactly one component. However, current navigation in the
metamodel specification is only possible from MHomeDef classes to their
corresponding MComponentDef classes (via the ``getComponent'' and
``setComponent'' functions).

For this 1--to--many correspondence to make more practical sense, we added a
series of functions to MComponentDef to allow direct navigation to associated
home(s). These functions are similar to the set of ``getSupportss'' functions
already in a component (but see \ref{} for notes about component supports).

%------------------------------------------------------------------------------
\subsection{Definition kinds}
%------------------------------------------------------------------------------

The MDefinitionKind implementation as specified makes little sense in the
context of the rest of the CCM metamodel specification. There are two major
points of interest here:

\begin{itemize}
\item There is no way to associate an MDefinitionKind value with each class type
      in the CCM metamodel specification (i.e. there is no static, constant
      ``definitionKind'' variable in the metamodel classes). This makes the
      ``lookupName'' and ``getFilteredContents'' functions impossible to
      implement (at least as we interpreted the purposes of these functions).
\item The enumeration for MDefinitionKind is incomplete.
\end{itemize}

%----------------------------------------
\subsubsection{Lack of association between classes and definition kinds}
%----------------------------------------

To solve the first item, we introduced a ``definitionKind'' class variable into
the following classes:

\begin{itemize}
\item those whose names end with ``DefImpl'' (i.e. MModuleDefImpl,
      MParameterDefImpl, MPrimitiveDefImpl, MWstringDefImpl, etc.)
\item MContainer and MContained
\end{itemize}

The definitionKind variable is declared {\tt private final static} because it is
not variable for a given class. Each class has an associated
``getDefinitionKind'' function that returns the definitionKind constant. As
mentioned before, this addition was necessary to implement the ``lookupName''
and ``getFilteredContents'' functions.

%----------------------------------------
\subsubsection{Incomplete definition kind enumeration}
%----------------------------------------

The second point was easy enough to fix, but any solution will cause a small
disturbance in the force, given the separation between the Base IDL and
Component IDL metamodels. The MDefinitionKind enum as specified has many
inconsistencies:

\begin{itemize}
\item The enum has values for MStringDef, MParameterDef, and MPrimitiveDef, for
      example, but no values for MFieldDef or MUnionFieldDef.

      All of these classes inherit only from the Typed or IDLType classes (which
      have no ``identifier'' member variables). So, for example, MParameterDef
      has an ``identifier'' variable and an associated DefinitionKind value.
      MFieldDef and MUnionFieldDef also have ``identifier'' member variables
      (indicating that a library user might be able to use the ``lookupName''
      functions to look for instances of these classes), but there are no
      corresponding MDefinitionKind values.
\item The enum has values for MInterfaceDef, MExceptionDef, MTypedefDef, and
      MOperationDef, for example, but no values for MValueDef, MValueBoxDef, or
      MValueMemberDef.

      This seems to be a simple oversight, as all of these types should be
      treated equally in this regard.
\item The enum lacks values for classes in the ComponentIDL library, even though
      they inherit from, for example, MInterfaceDef. This has caused us some
      discomfort, as it should clearly be possible to call, for example,
\begin{verbatim}
someContainer.lookup("someHome")
\end{verbatim}
      But it is not clear where to put the MDefinitionKind values in this case.
\end{itemize}

Our solution to the first two problems was to add the missing values to the
MDefinitionKind enum (see the tables below). Our solution to the third problem
was also to add the missing values to the MDefinitionKind enum in the BaseIDL
library. However, this removes the strict subset/superset relationship between
the BaseIDL and the ComponentIDL: BaseIDL is no longer a logical proper subset
of ComponentIDL.

Nonetheless, we felt this was the best solution: the alternative is to create an
empty MDefinitionKind interface in BaseIDL, and then implement that interface
with an MDefinitionKindImpl class in the BaseIDL and a second
MDefinitionKindImpl class in the ComponentIDL. The alternative requires
excessive typecasting (for a Java, C, or C++ implementation) and would be
difficult to maintain. The maintenance difficulty is especially true in the
sense of coordinating integer values between the two sets of ``Impl''. As
further justification for our solution, this maintenance requirement for the
two--enum solution also removes the proper subset relationship between the two
metamodels.

\begin{table}
\centering
\begin{tabular}{|l|c|c|}
\hline
Element           & Specification & Implementation \\ \hline \hline
DK\_ALIAS         & $\star$ & $\star$    \\
DK\_ALL           & $\star$ &            \\
DK\_ARRAY         & $\star$ & $\star$    \\
DK\_ATTRIBUTE     & $\star$ & $\star$    \\
DK\_COMPONENT     &         & $\oplus$   \\ \hline
DK\_CONSTANT      & $\star$ & $\star$    \\
DK\_CONSUMES      &         & $\oplus$   \\
DK\_EMITS         &         & $\oplus$   \\
DK\_ENUM          & $\star$ & $\star$    \\
DK\_EVENT         &         & $\oplus$   \\ \hline
DK\_EVENTPORT     &         & $\oplus$   \\
DK\_EXCEPTION     & $\star$ & $\star$    \\
DK\_FACTORY       &         & $\oplus$   \\
DK\_FINDER        &         & $\oplus$   \\
DK\_FIXED         & $\star$ & $\star$    \\ \hline
DK\_HOME          &         & $\oplus$   \\
DK\_INTERFACE     & $\star$ & $\star$    \\
DK\_MODULE        & $\star$ & $\star$    \\
DK\_NONE          & $\star$ & $\dagger$  \\
DK\_OPERATION     & $\star$ & $\star$    \\ \hline
DK\_PARAMETER     &         & $\star$    \\
DK\_PRIMITIVE     & $\star$ & $\star$    \\
DK\_PROVIDES      &         & $\oplus$   \\
DK\_PUBLISHES     &         & $\oplus$   \\
DK\_REPOSITORY    & $\star$ & $\ddagger$ \\ \hline
DK\_SEQUENCE      & $\star$ & $\star$    \\
DK\_STRING        & $\star$ & $\star$    \\
DK\_STRUCT        & $\star$ & $\star$    \\
DK\_TYPEDEF       & $\star$ & $\star$    \\
DK\_UNION         & $\star$ & $\star$    \\ \hline
DK\_USES          &         & $\oplus$   \\
DK\_VALUE         &         & $\star$    \\
DK\_VALUEBOX      &         & $\star$    \\
DK\_VALUEMEMBER   &         & $\star$    \\
DK\_WSTRING       & $\star$ & $\star$    \\ \hline
\end{tabular}
\begin{tabular}{l}
\\
$^\oplus\;\mbox{corresponds to a class in the ComponentIDL library}$ \\
$^\dagger\;\mbox{used for MContained}$ \\
$^\ddagger\;\mbox{used for MContainer}$
\end{tabular}
\label{table:component-definition-kinds}
\caption{Definition kind enumeration elements, as defined in the CCM metamodel
specification and as used by our project.}
\end{table}

%------------------------------------------------------------------------------
\subsection{Primitive kinds}
%------------------------------------------------------------------------------

The MWstringDefImpl and MStringDefImpl classes need to have a ``kind'' data
member, just like the MPrimitiveDefImpl class. The MPrimitiveKind enum contains
values for wstring and string (PK\_WSTRING and PK\_STRING, respectively), so it
seems like these types should behave similarly to the other primitive kind data
types.

%------------------------------------------------------------------------------
\subsection{Language mappings}
%------------------------------------------------------------------------------

This section describes some difficulties or inconsistencies encountered with the
language mappings.

%----------------------------------------
\subsubsection{IDL 2 language mapping}
%----------------------------------------

\paragraph{Publishes}

The language mapping template for event publishers is difficult to read. In
addition, the template appears to contain the same text two times, with
different indentation.

