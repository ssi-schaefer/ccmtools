%==============================================================================
\chapter{Hello World Example}
\label{HelloWorldComponent}
%==============================================================================

As a quick tour through CCM Tools, we implement a simple Hello World 
component example. 
Each development step and developer role will be described 
in more detail in one of the next sections, here we give a general overview.

\vspace{5mm}
\noindent
{\bf Step 1:} We define a component using the 
{\it Interface Definition Language} (IDL). 
This simple component only provides a single interface containing a single
method. Don't forget to define a home for this component type.
The following IDL definitions are stored in
a file called {\tt Hello.idl}:
\begin{small}
\begin{verbatim}
module world
{ 
    interface Hello 
    { 
        string sayHello(); 
    }; 

    component Server 
    { 
        provides Hello hello;
    }; 

    home ServerHome manages Server
    {
    };
};
\end{verbatim}
\end{small}


\noindent
{\bf Step 2:} Generate a uniform IDL3 structure from the single {\tt Hello.idl}
file:
\begin{small}
\begin{verbatim}
> ccmidl -idl3 -o server/idl idl3/Hello.idl
\end{verbatim}
\end{small}

\noindent
This uniform IDL3 structure separates between interfaces (including 
parameter type and exception definitions) and components (including their
homes). Such a separation makes sense because an interface can be used by
many component definitions.
\begin{small}
\begin{verbatim}
    server/
     |-- idl
     |   |-- component
     |   |   `-- world
     |   |       |-- Server.idl
     |   |       `-- ServerHome.idl
     |   `-- interface
     |       `-- world
     |           `-- Hello.idl
\end{verbatim}
\end{small}


\noindent
{\bf Step 3:} Generate an empty component skeleton from the uniform IDL3 
structure:
\begin{small}
\begin{verbatim}
> ccmtools c++local -o server/interface \
                    -Iserver/idl/interface \
                    -Iserver/idl/component \
                    server/idl/interface/world/*.idl

> ccmtools c++local -a -o server/component/Server \ 
                    -Iserver/idl/interface \
                    -Iserver/idl/component \
                    server/idl/component/world/Server*.idl  
\end{verbatim}
\end{small}

\noindent
CCM Tools generate the following file structure which represents a local
component's implementation.
Code contained in the {\tt GEN\_*} directories establishes the component's
structure (= {\it component logic}), while code stored in the {\tt Server} 
directory represents the functional part of a component (= {\it business
logic}).

\begin{small}
\begin{verbatim}
   server
    |-- idl
    |-- component
    |   `-- Server
    |       |-- GEN_ccmtools_local_world
    |       |-- GEN_ccmtools_local_world_share
    |       |-- ServerHome_impl.cc
    |       |-- ServerHome_impl.h
    |       |-- Server_hello_impl.cc
    |       |-- Server_hello_impl.h
    |       |-- Server_impl.cc
    |       |-- Server_impl.h
    |       `-- world_ServerHome_entry.h
    `-- interface
        |-- GEN_ccmtools_local_world
        `-- GEN_world
\end{verbatim}
\end{small}

\noindent
{\bf Step 4:} Implement the component's business logic.
The component's business logic must be embedded in the generated
component logic. 
To implement the {\tt sayHello()} method of the {\tt Hello} interface,
we extend the generated {\tt Server\_hello\_impl.cc} file:
\begin{small}
\begin{verbatim}
std::string
Server_hello_impl::sayHello()
    throw(Components::CCMException)
{
    // TODO : IMPLEMENT ME HERE !
    return "Hello from Server component!";
}
\end{verbatim}
\end{small}


\noindent
{\bf Step 5:} Now we can implement a client that uses the Hello World
component. For this simple case, we implement the client as a {\tt \_check*}
file that will be automatically executed from a {\tt make check} command.

\begin{small}
\begin{verbatim}
   server/component/server
    |-- test
    |   `-- _check_world_Server.cc
\end{verbatim}
\end{small}

\noindent
The following client code snippets are stored in the 
{\tt \_check\_world\_Server.cc} file:
\begin{small}
\begin{verbatim}
#include <cassert>
#include <iostream>

#include <Components/ccmtools.h>
#include <world/ServerHome_gen.h>

using namespace std;
using namespace world;

int main(int argc, char *argv[])
{
    int error = deploy_world_ServerHome("ServerHome");
    if(error)
    {
        cerr << "BOOTSTRAP ERROR: Can't deploy component homes!" << endl;
        return(error);
    }

    try
    {
        Components::HomeFinder* homeFinder = 
            Components::HomeFinder::Instance();

        ServerHome::SmartPtr home(dynamic_cast<ServerHome*>(
            homeFinder->find_home_by_name("ServerHome").ptr()));

        Server::SmartPtr component;
        Hello::SmartPtr hello;

        component = home->create();
        hello = component->provide_hello();
        component->configuration_complete();

        string s = hello->sayHello();
        cout << "sayHello(): " << s << endl;

        assert(s == "Hello from Server component!");

        component->remove();
    }
    catch(Components::Exception& e)
    {
        cerr << "CCMTOOLS ERROR: " << e.what() << endl;
        return -1;
    }
    catch(...)
    {
        cerr << "UNKNOWN ERROR!" << endl;
        return -1;
    }

    error = undeploy_world_ServerHome("ServerHome");
    if(error)
    {
        cerr << "TEARDOWN ERROR: Can't undeploy component homes!" << endl;
        return error;
    }

    Components::HomeFinder::destroy();
}
\end{verbatim}
\end{small}

\noindent
Additionally, we create some marker files which tell
{\tt confix} which package name, version and subdirectories
should be used.
\begin{small}
\begin{verbatim}
> ccmconfix -confix2 -o server -pname "hello_world" -pversion "1.0.0"
\end{verbatim}
\end{small}

\noindent
To compile the component and run the unit test, simply type: 
\begin{small}
\begin{verbatim}
> confix2.py --packageroot=`pwd`/server --bootstrap --configure \
            --make --targets=check
\end{verbatim}
\end{small}

\noindent
After all, we are happy to see the following output at the end of the client's
build process:

\begin{small}
\begin{verbatim}
sayHello(): Hello from Server component!
PASS: hello_world_component_Server_test__check_world_Server
==================
All 1 tests passed
==================
\end{verbatim}
\end{small}

\noindent
Of course, to implement a component for a simple 'Hello from Server component!'
message is somewhat academical, but this example shows how simple a component
development cycle can be. 
The intent of this section was to define the main activities in component 
development, which are:
\begin{itemize}
\item Define a component's structure using IDL.
\item Generate an empty component skeleton (called component logic).
\item Implement a component's business logic. 
\item Implement a component's (test) client.
\end{itemize}

\noindent
In the following sections, we will explore each of these steps in more
detail. However, keep this big picture in mind. 

