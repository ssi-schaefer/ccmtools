
/** Preliminary Declarations Section */

import java.util.*;
import java.math.*;
import java_cup.runtime.*;

import ccmtools.metamodel.BaseIDL.*;
import ccmtools.metamodel.ComponentIDL.*;

parser code 
{:
	/**
	 * This method overides the original report_error() method
	 * and generates a useful error message.
	 */
	public void report_error(String message, Object info)
	{
		StringBuilder out = new StringBuilder();
		if(info instanceof Symbol)
		{
			Symbol s = (Symbol)info;
			out.append(ParserHelper.getInstance().getCurrentSourceFile());
			out.append(" line " + ParserHelper.getInstance().getCurrentSourceLine());
		}
		out.append(": " + message);
		throw new RuntimeException(out.toString());
	}
	
	public void report_fatal_error(String message, Object info)
	{
		System.exit(1);
	}
	
:};


action code
{:
	private ParserHelper helper = ParserHelper.getInstance();
:}

/** Declaration of Terminals and Non Terminals Section */

terminal String		T_PRAGMA;
terminal String 		T_INCLUDE;

terminal 	T_LEFT_CURLY_BRACKET;
terminal 	T_RIGHT_CURLY_BRACKET;
terminal		T_LEFT_SQUARE_BRACKET;
terminal	 	T_RIGHT_SQUARE_BRACKET;
terminal		T_LEFT_PARANTHESIS;
terminal		T_RIGHT_PARANTHESIS;
terminal		T_COLON;
terminal 	T_COMMA;
terminal 	T_SEMICOLON;  
terminal	 	T_SCOPE;
terminal		T_EQUAL;
terminal 	T_SHIFTRIGHT;
terminal 	T_SHIFTLEFT;
terminal		T_PLUS_SIGN;
terminal 	T_MINUS_SIGN; 
terminal		T_ASTERISK; 
terminal		T_SOLIDUS;
terminal		T_PERCENT_SIGN;
terminal 	T_TILDE;
terminal 	T_VERTICAL_LINE; 
terminal		T_CIRCUMFLEX; 
terminal		T_AMPERSAND;
terminal		T_LESS_THAN_SIGN;
terminal 	T_GREATER_THAN_SIGN;

terminal		T_IMPORT;
terminal		T_CONST;
terminal		T_TYPEDEF;
terminal		T_FLOAT;
terminal		T_DOUBLE;
terminal		T_CHAR;
terminal		T_WCHAR;
terminal		T_FIXED;
terminal		T_BOOLEAN;
terminal		T_STRING;
terminal		T_WSTRING;
terminal		T_VOID;
terminal		T_UNSIGNED;
terminal		T_LONG;
terminal		T_SHORT;
terminal		T_FALSE;
terminal		T_TRUE;
terminal		T_STRUCT;
terminal		T_UNION;
terminal		T_SWITCH;
terminal		T_CASE;
terminal		T_DEFAULT;
terminal		T_ENUM;
terminal		T_IN;
terminal		T_OUT;
terminal		T_INTERFACE;
terminal		T_ABSTRACT;
terminal		T_VALUETYPE;
terminal		T_TRUNCATABLE;
terminal		T_SUPPORTS;
terminal		T_CUSTOM;
terminal		T_PUBLIC;
terminal		T_PRIVATE;
terminal		T_FACTORY;
terminal		T_NATIVE;
terminal		T_VALUEBASE;
terminal		T_TYPEID;
terminal		T_TYPEPREFIX;
terminal		T_GETRAISES;
terminal		T_SETRAISES;
terminal		T_LOCAL;

terminal		T_MODULE;
terminal		T_OCTET;
terminal		T_ANY;
terminal		T_SEQUENCE;
terminal		T_READONLY;
terminal		T_ATTRIBUTE;
terminal		T_EXCEPTION;
terminal		T_ONEWAY;
terminal		T_INOUT;
terminal		T_RAISES;
terminal		T_CONTEXT;

terminal		T_OBJECT;

terminal		T_COMPONENT;
terminal		T_PROVIDES;
terminal		T_USES;
terminal		T_MULTIPLE;
terminal		T_EMITS;
terminal		T_PUBLISHES;
terminal		T_CONSUMES;
terminal		T_HOME;
terminal		T_MANAGES;
terminal		T_PRIMARYKEY;
terminal		T_FINDER;
terminal		T_EVENTTYPE;

terminal 	String		T_IDENTIFIER;
terminal		Double		T_FLOATING_PT_LITERAL;
terminal		BigInteger	T_FIXED_PT_LITERAL;     
terminal		Integer		T_INTEGER_LITERAL;
terminal		Character 	T_CHARACTER_LITERAL;
terminal		Character 	T_WCHARACTER_LITERAL;
terminal  	String 		T_STRING_LITERAL;
terminal		String 		T_WSTRING_LITERAL;


/* 1 */
nonterminal	MContainer specification;
nonterminal List	 definitions;  				// List<MConatined>
nonterminal	Object definition;
nonterminal	MModuleDef module;

nonterminal	MInterfaceDef interface;
nonterminal	MInterfaceDef interface_dcl;
nonterminal	MInterfaceDef forward_dcl;
nonterminal	MInterfaceDef interface_header;
nonterminal	List interface_body;
nonterminal	List exports;
nonterminal	Object export;
nonterminal	List interface_inheritance_spec;  /* 10 */
nonterminal	List interface_names;

nonterminal	List scoped_names;
nonterminal ScopedName scoped_name;

nonterminal	MContained value;
nonterminal	MValueDef value_forward_dcl;
nonterminal	MValueBoxDef value_box_dcl;
nonterminal	MValueDef value_abs_dcl;
nonterminal List value_body;
nonterminal	MValueDef value_dcl;
nonterminal List value_elements;
nonterminal MValueDef value_header;
nonterminal MValueDef value_inheritance_spec;
nonterminal MValueDef value_inheritance_bases;
nonterminal List value_names;
nonterminal	ScopedName value_name;		/* 20 */
nonterminal Object value_element;
nonterminal List state_member;
nonterminal	MFactoryDef init_dcl;
nonterminal List init_param_decls;
nonterminal MParameterDef init_param_decl;
nonterminal MParameterMode init_param_attribute;

nonterminal	MConstantDef	 const_dcl;
nonterminal	MIDLType	 const_type;
nonterminal	Object const_exp;
nonterminal	Object or_expr;	 					/* 30 */		
nonterminal	Object xor_expr;
nonterminal	Object and_expr;
nonterminal	Object shift_expr;
nonterminal	Object add_expr;
nonterminal	Object mult_expr;
nonterminal	Object unary_expr;
nonterminal	Object primary_expr;
nonterminal	Object literal; 			
nonterminal	Integer	positive_int_const; 			/* 41 */

nonterminal	MIDLType	 type_dcl;
nonterminal	MIDLType type_spec;
nonterminal	MIDLType simple_type_spec;
nonterminal	MIDLType base_type_spec;
nonterminal	MIDLType template_type_spec;
nonterminal	MIDLType constr_type_spec;

nonterminal	List	 declarators;
nonterminal Declarator declarator;					/* 50 */
nonterminal	Declarator simple_declarator;
nonterminal	Declarator complex_declarator;

nonterminal	MPrimitiveDef floating_pt_type;
nonterminal	MPrimitiveDef integer_type;
nonterminal	MPrimitiveDef signed_int;
nonterminal	MPrimitiveDef signed_short_int;
nonterminal	MPrimitiveDef signed_long_int;
nonterminal	MPrimitiveDef signed_longlong_int;
nonterminal	MPrimitiveDef unsigned_int;
nonterminal	MPrimitiveDef unsigned_short_int;	/* 60 */
nonterminal	MPrimitiveDef unsigned_long_int;
nonterminal	MPrimitiveDef unsigned_longlong_int;
nonterminal	MPrimitiveDef char_type;
nonterminal	MPrimitiveDef wide_char_type;
nonterminal	MPrimitiveDef boolean_type;
nonterminal	MPrimitiveDef octet_type;
nonterminal	MPrimitiveDef any_type;
nonterminal	MPrimitiveDef object_type;

nonterminal	MStructDef struct_type;
nonterminal List member_list;					/* 70 */			
nonterminal	MFieldDef member;

nonterminal	MUnionDef union_type;
nonterminal	MIDLType switch_type_spec;
nonterminal	List switch_body;
nonterminal	MUnionFieldDef case;
nonterminal	Object case_label;
nonterminal	MUnionFieldDef element_spec;

nonterminal	MEnumDef	 enum_type;
nonterminal	List	 enumerators;
nonterminal	String enumerator;

nonterminal	MSequenceDef sequence_type;			/* 80 */	

nonterminal	MStringDef string_type;

nonterminal	MWstringDef wide_string_type;

nonterminal	Declarator array_declarator;
nonterminal List<Integer> fixed_array_sizes;
nonterminal	Integer fixed_array_size;

nonterminal	List attr_dcl;
nonterminal	MExceptionDef except_dcl;
nonterminal	List members;
nonterminal	MOperationDef op_dcl;
nonterminal	Boolean op_attribute;
nonterminal MIDLType op_type_spec;
nonterminal	List parameter_dcls;					/* 90 */
nonterminal List param_dcls;
nonterminal	MParameterDef param_dcl;
nonterminal	MParameterMode param_attribute;
nonterminal	List raises_expr;  		// List<MExceptionDef>
nonterminal	List context_expr;
nonterminal List string_literals;

nonterminal	String T_string_literal;
nonterminal	String T_wstring_literal;

nonterminal	MIDLType param_type_spec;

nonterminal MFixedDef fixed_pt_type;

nonterminal	MFixedDef fixed_pt_const_type;
nonterminal	MIDLType value_base_type;
nonterminal	MIDLType constr_forward_decl;

nonterminal		import_dcl;			/* 100 */
nonterminal		imported_scope;
nonterminal		type_id_dcl;
nonterminal		type_prefix_dcl;

nonterminal	List readonly_attr_spec;  		// List<MAttributeDef>
nonterminal	List readonly_attr_declarator;  // List<Declarator>
nonterminal	List simple_declarators;        // List<Declarator>
nonterminal List attr_spec; 					// List<MAttributeDef>
nonterminal	List attr_declarator;           // List<Declarator>
nonterminal	AttributeRaisesExpression attr_raises_expr;
nonterminal	List get_excep_expr;				// List<MExceptionDef>
nonterminal	List set_excep_expr;				// List<MExceptionDef>
nonterminal	List exception_list;				// List<MExceptionDef>		/* 110 */

nonterminal		component;
nonterminal		component_forward_dcl;
nonterminal		component_dcl;
nonterminal		component_header;
nonterminal		supported_interface_spec;
nonterminal		component_inheritance_spec;
nonterminal		component_body;
nonterminal		component_export;
nonterminal		provides_dcl;

/* 120 */
nonterminal		interface_type;		
nonterminal		uses_dcl;
nonterminal		emits_dcl;
nonterminal		publishes_dcl;
nonterminal		consumes_dcl;
nonterminal		home_dcl;
nonterminal		home_header;
nonterminal		home_inheritance_spec;
nonterminal		primary_key_spec;
nonterminal		home_body;

/* 130 */
nonterminal		home_exports;		
nonterminal		home_export;
nonterminal		factory_dcl;
nonterminal		finder_dcl;
nonterminal		event;
nonterminal		event_forward_dcl;
nonterminal		event_abs_dcl;
nonterminal		event_dcl;
nonterminal		event_header;



/** Precedence and Associatively of Terminals Section */


/** Grammar Section */

start with specification;

/* 1 */
specification 
	::= 
		definitions:l
		{:
			RESULT = helper.parseSpecification(l);
		:}
	;
		
						
/* 2 */	
definitions 
	::=
		definition:d
		{:
			RESULT = helper.parseDefinitions(d);
		:}
	| 
		definition:d definitions	:l
		{:
			RESULT = helper.parseDefinitions(d,l);
		:}
	;

definition 
	::=	
		T_INCLUDE
	|	
		T_PRAGMA
	|	
		type_dcl:t T_SEMICOLON
		{:
			RESULT = t;
		:}
	| 	
		const_dcl:d T_SEMICOLON
		{:
			RESULT = d;
		:}
	| 	
		except_dcl:d T_SEMICOLON
		{:
			RESULT = d;
		:}
	| 	
		interface:d T_SEMICOLON
		{:
			RESULT = d;
		:}		
	| 	
		module:d T_SEMICOLON
		{:
			RESULT = d;
		:}
	| 	
		value:d T_SEMICOLON
		{:
			RESULT = d;
		:}
	| 	
		type_id_dcl:d T_SEMICOLON
		{:
			RESULT = d;
		:}
	| 	
		type_prefix_dcl:d T_SEMICOLON
		{:
			RESULT = d;
		:}
	| 	
		event:d T_SEMICOLON
		{:
			RESULT = d;
		:}
	| 	
		component:d T_SEMICOLON
		{:
			RESULT = d;
		:}
	| 	
		home_dcl:d T_SEMICOLON
		{:
			RESULT = d;
		:}
	| 	
		import_dcl:d T_SEMICOLON
		{:
			RESULT = d;
		:}
	;

		
/* 3 */
module
	::= 
		T_MODULE T_IDENTIFIER:id 
		T_LEFT_CURLY_BRACKET 
		{:
			helper.getScope().pushModule(id);
		:}
		definitions:d
		{:

		:} 
		T_RIGHT_CURLY_BRACKET
		{:
			helper.getScope().popModule();
		:}
	;
	
	
/* 4 */	
interface
	::= 	
		interface_dcl:t
		{:
			RESULT = t;
		:}
	| 
		forward_dcl:t
		{:
			RESULT = t;
		:}
 	;
	
	
/* 5 */
interface_dcl
	::= 
		interface_header:i T_LEFT_CURLY_BRACKET interface_body:l T_RIGHT_CURLY_BRACKET
		{:
			RESULT = helper.parseInterfaceDcl(i, l);
		:}
	;
	
	
/* 6 */
forward_dcl
	::= 
		T_INTERFACE T_IDENTIFIER:id
		{:
			helper.parseInterfaceForwardDeclaration(id);
		:}
	| 
		T_ABSTRACT T_INTERFACE T_IDENTIFIER:id
		{:
			helper.parseAbstractInterfaceForwardDeclaration(id);
		:}
	| 
		T_LOCAL T_INTERFACE T_IDENTIFIER:id
		{:
			helper.parseLocalInterfaceForwardDeclaration(id);
		:}
	;
	
	
/* 7 */
interface_header
	::= 
		T_INTERFACE T_IDENTIFIER:id
		{:
			RESULT = helper.parseInterfaceHeader(id);
		:}	
	| 	
		T_INTERFACE T_IDENTIFIER:id
		interface_inheritance_spec:l
		{:
			RESULT = helper.parseInterfaceHeader(id,l);
		:}		
	| 
		T_ABSTRACT T_INTERFACE T_IDENTIFIER:id
		{:
			RESULT = helper.parseAbstractInterfaceHeader(id);
		:}		
	| 
		T_ABSTRACT T_INTERFACE T_IDENTIFIER:id 
		interface_inheritance_spec:l
		{:
			RESULT = helper.parseAbstractInterfaceHeader(id,l);
		:}		
	| 
		T_LOCAL T_INTERFACE T_IDENTIFIER:id
		{:
			RESULT = helper.parseLocalInterfaceHeader(id);
		:}		
	| 
		T_LOCAL T_INTERFACE T_IDENTIFIER:id
		interface_inheritance_spec:l
		{:
			RESULT = helper.parseLocalInterfaceHeader(id, l);
		:}		
	; 


/* 8 */
interface_body
	::= 
		/*empty*/
		{:
			RESULT = helper.parseInterfaceBody();
		:}
	| 
		exports:l
		{:
			RESULT = helper.parseInterfaceBody(l);
		:}
	;

exports
	::= 	
		export:e
		{:
			RESULT = helper.parseExports(e);
		:}
	| 
		export:e exports:l
		{:
			RESULT = helper.parseExports(e, l);
		:}
	;


/* 9 */
export
	::= 
		type_dcl:t T_SEMICOLON
		{:
			RESULT = t;
		:}
	| 
		const_dcl:t T_SEMICOLON 
		{:
			RESULT = t;
		:}
	| 
		except_dcl:t T_SEMICOLON
		{:
			RESULT = t;
		:}
	| 
		attr_dcl:t T_SEMICOLON
		{:
			RESULT = t;
		:}
	| 
		op_dcl:t T_SEMICOLON 
		{:
			RESULT = t;
		:}
	| 
		type_id_dcl:t T_SEMICOLON
		{:
			RESULT = t;
		:}
	| 	
		type_prefix_dcl:t T_SEMICOLON
		{:
			RESULT = t;
		:}
	;


/* 10 */
interface_inheritance_spec
	::= 
		T_COLON interface_names:l
		{:
			RESULT = helper.parseInterfaceInheritanceSpec(l);
		:}
		
	;


/* 11 */
interface_names
	::= 
		scoped_names:l
		{:
			RESULT = l;
		:}
	;

scoped_names
	::= 
		scoped_name:id
		{:
			RESULT = helper.parseScopedNames(id);
		:}
	| 
		scoped_name:id T_COMMA scoped_names:l
		{:
			RESULT = helper.parseScopedNames(id, l);		
		:}
	;


/* 12 */
scoped_name
	::= 
		T_IDENTIFIER:id
		{:
			RESULT = helper.parseScopedName(id);
		:}	
	| 
		T_SCOPE T_IDENTIFIER:id
		{:
			RESULT = helper.parseScopedName("::" + id);
		:}
	| 
		scoped_name:sn T_SCOPE T_IDENTIFIER:id
		{:
			RESULT = helper.parseScopedName(sn + "::" + id);
		:}
	;


/* 13 */
value
	::= 
		value_dcl:v
		{:
			RESULT = v;
		:}
	| 
		value_abs_dcl:v
		{:
			RESULT = v;
		:}
	| 
		value_box_dcl:v
		{:
			RESULT = v;
		:}
	| 
		value_forward_dcl:v
		{:
			RESULT = v;
		:}
	;


/* 14 */
value_forward_dcl
	::= 
		T_VALUETYPE T_IDENTIFIER:id
		{:
			RESULT = helper.parseValueForwardDeclaration(id);
		:}		
	| 
		T_ABSTRACT T_VALUETYPE T_IDENTIFIER:id
		{:
			RESULT = helper.parseAbstractValueForwardDeclaration(id);	
		:}
	;


/* 15 */
value_box_dcl
	::= 
		T_VALUETYPE T_IDENTIFIER:id 	type_spec:t
		{:
			RESULT = helper.parseValueBoxDeclaration(id, t);
		:}		
	;


/* 16 */
value_abs_dcl
	::= 
		T_ABSTRACT T_VALUETYPE T_IDENTIFIER:id
		{:
			helper.registerTypeId(id);
		:}				
	 	T_LEFT_CURLY_BRACKET value_body:b T_RIGHT_CURLY_BRACKET
		{:
			RESULT = helper.parseValueAbstractDeclaration(id,b);			
		:}		
	| 
		T_ABSTRACT T_VALUETYPE T_IDENTIFIER:id value_inheritance_spec:l 
		{:
			helper.registerTypeId(id);
		:}				
		T_LEFT_CURLY_BRACKET value_body:b T_RIGHT_CURLY_BRACKET
		{:
			RESULT = helper.parseValueAbstractDeclaration(id,l,b);			
		:}		
	;

value_body
	::= 
		/*empty*/
		{:
			RESULT = new ArrayList();
		:}
	| 
		exports:e
		{:
			RESULT = e;
		:}
	;


/* 17 */
value_dcl
	::= 
		value_header:h T_LEFT_CURLY_BRACKET value_elements:l T_RIGHT_CURLY_BRACKET
		{:
			RESULT = helper.parseValueDeclaration(h,l);
		:}
	| 
		value_header:h T_LEFT_CURLY_BRACKET T_RIGHT_CURLY_BRACKET
		{:
			RESULT = helper.parseValueDeclaration(h);
		:}
	;

value_elements
	::= 
		value_element:e
		{:
			RESULT = helper.parseValueElements(e);
		:}
	| 
		value_element:e value_elements:l
		{:
			RESULT = helper.parseValueElements(e,l);
		:}
	;


/* 18 */
value_header
	::= 
		T_VALUETYPE T_IDENTIFIER:id 	value_inheritance_spec:v
		{:
			RESULT = helper.parseValueHeader(id,v);
		:}		
	| 
		T_CUSTOM T_VALUETYPE T_IDENTIFIER:id value_inheritance_spec:v
		{:
			RESULT = helper.parseCustomValueHeader(id,v);
		:}
	| 
		T_VALUETYPE T_IDENTIFIER:id
		{:
			RESULT = helper.parseValueHeader(id);
		:}				
	| 
		T_CUSTOM T_VALUETYPE T_IDENTIFIER:id
		{:
			RESULT = helper.parseCustomValueHeader(id);
		:}			
	;


/* 19 */
value_inheritance_spec
	::= 
		T_COLON value_inheritance_bases:v
		{:
			RESULT = v;
		:}
	| 
		T_COLON value_inheritance_bases:v T_SUPPORTS interface_names:s 
		{:
			RESULT = helper.parseValueSupportsInterfaces(v,s);
		:}
	| 
		T_SUPPORTS interface_names:l
		{:
			RESULT = helper.parseValueSupportsInterfaces(l);
		:}
	;


value_inheritance_bases
	::= 
		value_name:id
		{:
			RESULT = helper.parseValueInheritanceBases(id);
		:}
	| 
		value_name:id T_COMMA value_names:l
		{:
			RESULT = helper.parseValueInheritanceBases(id, l);
		:}
	| 
		T_TRUNCATABLE value_name:id
		{:
			RESULT = helper.parseTruncatableValueInheritanceBases(id);
		:}
	| 
		T_TRUNCATABLE value_name:id T_COMMA value_names:l
		{:
			RESULT = helper.parseTruncatableValueInheritanceBases(id, l);
		:}		
	;

value_names
	::= 
		scoped_names:l
		{:
			RESULT = l;  
		:}
	;


/* 20 */
value_name
	::= 
		scoped_name:id
		{:
			RESULT = id; 
		:}
	;


/* 21 */
value_element
	::= 
		export:e
		{:
			RESULT = e;
		:}
	| 
		state_member:m
		{:
			RESULT = m;
		:}
	| 
		init_dcl:f
		{:
			RESULT = f;
		:}
	;


/* 22 */
state_member
	::= 
		T_PUBLIC type_spec:t declarators:l T_SEMICOLON
		{:
			RESULT = helper.parsePublicStateMember(t, l);
		:}
	| 
		T_PRIVATE type_spec:t declarators:l T_SEMICOLON
		{:
			RESULT = helper.parsePrivateStateMember(t, l);		
		:}
	;


/* 23 */
init_dcl
	::= 
		T_FACTORY T_IDENTIFIER:id T_LEFT_PARANTHESIS init_param_decls:l T_RIGHT_PARANTHESIS T_SEMICOLON
		{:
			RESULT = helper.parseInitDeclaration(id,l);
		:}
	| 
		T_FACTORY T_IDENTIFIER:id T_LEFT_PARANTHESIS T_RIGHT_PARANTHESIS T_SEMICOLON
		{:
			RESULT = helper.parseInitDeclaration(id);
		:}
	;


/* 24 */
init_param_decls
	::= 
		init_param_decl:p
		{:
			RESULT = helper.parseInitParameterDeclarations(p);
		:}
	| 
		init_param_decl:p T_COMMA init_param_decls:l
		{:
			RESULT = helper.parseInitParameterDeclarations(p,l);
		:}
	;


/* 25 */
init_param_decl
	::= 
		init_param_attribute param_type_spec:t simple_declarator:d
		{:
			RESULT = helper.parseInitParameterDeclaration(t,d);
		:}
	;


/* 26 */
init_param_attribute
	::= 
		T_IN
	;


/* 27 */
const_dcl
	::= 
		T_CONST const_type:t T_IDENTIFIER:id
		{:
			helper.registerTypeId(id);
		:}		
	 	T_EQUAL const_exp:e
	 	{:
	 		RESULT = helper.parseConstDcl(t, id, e);
	 	:}
	;


/* 28 */
const_type
	::= 
		integer_type:t
		{:
			RESULT = t;
		:}
	| 
		char_type:t
		{:
			RESULT = t;
		:}
	| 
		wide_char_type:t
		{:
			RESULT = t;
		:}
	| 
		boolean_type:t
		{:
			RESULT = t;
		:}
	| 
		floating_pt_type:t
		{:
			RESULT = t;
		:}		
	| 
		string_type:t
		{:
			RESULT = t;
		:}		
	| 
		wide_string_type:t
		{:
			RESULT = t;
		:}
	| 
		fixed_pt_const_type:t
		{:
			RESULT = t;
		:}
	| 	
		scoped_name:id 
		{:
			RESULT = helper.getModelRepository().findIdlType(id);
		:}
	| 
		octet_type:t
		{:
			RESULT = t;
		:}
	;


/* 29 */
const_exp
	::= or_expr:e
		{:
			RESULT = e;
		:}
	;


/* 30 */
or_expr
	::= 
		xor_expr:e
		{:
			RESULT = e;		
		:}
	| 
		or_expr T_VERTICAL_LINE xor_expr
	;


/* 31 */
xor_expr
	::= 
		and_expr:e
		{:
			RESULT = e;
		:}
	| 
		xor_expr T_CIRCUMFLEX and_expr
	;


/* 32 */
and_expr
	::= 
		shift_expr:e
		{:
			RESULT = e;
		:}
	| 
		and_expr T_AMPERSAND shift_expr
	;


/* 33 */
shift_expr
	::= 
		add_expr:e
		{:
			RESULT = e;
		:}
	| 
		shift_expr T_SHIFTRIGHT add_expr
	| 
		shift_expr T_SHIFTLEFT add_expr
	;


/* 34 */
add_expr
	::= 
		mult_expr:e
		{:
			RESULT = e;
		:}
	| 
		add_expr T_PLUS_SIGN mult_expr
	| 
		add_expr T_MINUS_SIGN mult_expr
	;


/* 35 */
mult_expr
	::= 
		unary_expr:e
		{:
			RESULT = e;
		:}
	| 
		mult_expr T_ASTERISK unary_expr
	| 
		mult_expr T_SOLIDUS unary_expr
	| 
		mult_expr T_PERCENT_SIGN unary_expr
	;


/* 36 */
/* 37 */
unary_expr
	::= 
		T_MINUS_SIGN primary_expr:e
		{:
			RESULT = helper.parseUnaryExprMinusSign(e);
		:}
	| 
		T_PLUS_SIGN primary_expr:e
		{:
			helper.getLogger().fine("36: T_PLUS_SIGN primary_expr = " + e);		
			RESULT = e;
		:}
	| 
		T_TILDE primary_expr:e
		{:
			helper.getLogger().fine("36: T_TILDE primary_expr = " + e);		
			RESULT = e;		
		:}
	| 
		primary_expr:e
		{:
			helper.getLogger().fine("36: primary_expr = " + e);		
			RESULT = e;
		:}
	;


/* 38 */
primary_expr
	::= 
		scoped_name:id
		{:
			RESULT = id;
		:}
	| 
		literal:l
		{:
			helper.getLogger().fine("38: literal = " + l);		
			RESULT = l;
		:}
	| 
		T_LEFT_PARANTHESIS const_exp T_RIGHT_PARANTHESIS
	;


/* 39 */
/* 40 */
literal
	::= 
		T_INTEGER_LITERAL:i
		{:
			RESULT = i;
		:}
	| 
		T_string_literal:s
		{:
			RESULT = s;
		:}
	| 
		T_wstring_literal:ws
		{:
			RESULT = ws;
		:}
	| 
		T_CHARACTER_LITERAL:c
		{:
			RESULT = c;
		:}

	| 
		T_WCHARACTER_LITERAL:wc
		{:
			RESULT = wc;
		:}	
	| 
		T_FIXED_PT_LITERAL:fp
		{:
			RESULT = fp;
		:}		
	| 
		T_FLOATING_PT_LITERAL:f
		{:
			RESULT = f;
		:}		
	| 
		T_TRUE /*boolean_literal*/
		{:
			RESULT = Boolean.TRUE;
		:}
	| 
		T_FALSE /*boolean_literal*/
		{:
			RESULT = Boolean.FALSE;
		:}
	;


/* 41 */
positive_int_const
	::= 
		const_exp:e
		{:
			RESULT = helper.parsePositiveIntConst(e);
		:}
	;


/* 42 */
/* 43 */
type_dcl
	::= 
		T_TYPEDEF type_spec:t declarators:l
		{:
			RESULT = helper.parseTypeDcl(t,l);
		:}
	| 
		struct_type:t
		{:
			helper.getLogger().fine("42: struct_type = " + t);	
			RESULT = t;
		:}
	| 
		union_type:t
		{:
			RESULT = t;
		:}
	| 
		enum_type:t
		{:
			helper.getLogger().fine("42: enum_type = " + t);	
			RESULT = t;
		:}
	| 
		T_NATIVE simple_declarator:d
		{:
			RESULT = helper.parseNativeTypeDcl(d);
		:}
	| 
		constr_forward_decl:t
		{:
			helper.getLogger().fine("42: constr_forward_decl = " + t);	
			RESULT = t;
		:}
	;


/* 44 */
type_spec
	::= 
		simple_type_spec:t
		{:
			RESULT = t;
		:}		
	| 
		constr_type_spec:t
		{:
			RESULT = t;
		:}
	;


/* 45 */
simple_type_spec
	::= 
		base_type_spec:t
		{:
			helper.getLogger().fine("45: base_type_spec = " + t);
			RESULT = t;
		:}
	| 
		template_type_spec:t
		{:
			helper.getLogger().fine("45: template_type_spec = " + t);		
			RESULT = t;
		:}
	| 
		scoped_name:id
		{:
			RESULT = helper.getModelRepository().findIdlType(id);
		:}
	;


/* 46 */
base_type_spec
	::= 
		floating_pt_type:t
		{:
			RESULT = t;
		:}
	| 
		integer_type:t
		{:
			RESULT = t;
		:}
	| 
		char_type:t
		{:
			RESULT = t;
		:}
	| 
		wide_char_type:t
		{:
			RESULT = t;
		:}
	| 
		boolean_type:t
		{:
			RESULT = t;
		:}
	| 
		octet_type:t
		{:
			RESULT = t;
		:}
	| 
		any_type:t
		{:
			RESULT = t;
		:}
	| 
		object_type:t
		{:
			RESULT = t;
		:}
	| 
		value_base_type:t
		{:
			RESULT = t;
		:}
	;


/* 47 */
template_type_spec
	::= 
		sequence_type:t
		{:
			RESULT = t;
		:}
	| 
		string_type:t
		{:
			RESULT = t;
		:}
	| 
		wide_string_type:t
		{:
			RESULT = t;
		:}
	| 
		fixed_pt_type:t
		{:
			RESULT = t;
		:}
	;


/* 48 */
constr_type_spec
	::= 
		struct_type:t
		{:
			RESULT = t;
		:}
	| 
		union_type:t
		{:
			RESULT = t;
		:}
	| 
		enum_type:t
		{:
			RESULT = t;
		:}
	;


/* 49 */
declarators
	::= 
		declarator:d
		{:
			RESULT = helper.parseDeclarators(d);
		:}	
	| 
		declarator:d T_COMMA declarators:l
		{:
			RESULT = helper.parseDeclarators(d, l);
		:}
	;


/* 50 */
declarator
	::= 
		simple_declarator:d
		{:
			RESULT = d;
		:}
	| 
		complex_declarator:d
		{:
			RESULT = d;
		:}
	;

/* 51 */
simple_declarator
	::= 
		T_IDENTIFIER:id
		{:
			RESULT = helper.parseSimpleDeclarator(id);
		:}
	;


/* 52 */
complex_declarator
	::= 
		array_declarator:d
		{:
			RESULT = d;
		:}
	;


/* 53 */
floating_pt_type
	::= 
		T_FLOAT
		{:
			RESULT = helper.parseFloatType();
		:}	
	| 
		T_DOUBLE
		{:
			RESULT = helper.parseDoubleType();
		:}			
	| 
		T_LONG T_DOUBLE
		{:
			RESULT = helper.parseLongDoubleType();
		:}			
	;


/* 54 */
integer_type
	::= 
		signed_int:i
		{:
			RESULT = i;
		:}
	| 
		unsigned_int:i
		{:
			RESULT = i;
		:}
	;


/* 55 */
signed_int
	::= 
		signed_long_int:i
		{:
			RESULT = i;
		:}
	| 
		signed_short_int:i
		{:
			RESULT = i;
		:}
	| 
		signed_longlong_int:i
		{:
			RESULT = i;		
		:}
	;


/* 56 */
signed_short_int
	::= 
		T_SHORT 
		{:
			RESULT = helper.parseSignedShortType();
		:}
	;


/* 57 */
signed_long_int
	::= 
		T_LONG
		{:
			RESULT = helper.parseSignedLongType();
		:}		
	;


/* 58 */
signed_longlong_int
	::= 
		T_LONG T_LONG
		{:
			RESULT = helper.parseSignedLongLongType();
		:}
	;


/* 59 */
unsigned_int
	::= 
		unsigned_long_int:i
		{:
			RESULT = i;
		:}
		
	| 
		unsigned_short_int:i
		{:
			RESULT = i;
		:}
		
	| 
		unsigned_longlong_int:i
		{:
			RESULT = i;
		:}		
	;


/* 60 */
unsigned_short_int
	::= 
		T_UNSIGNED T_SHORT 
		{:
			RESULT = helper.parseUnsignedShortType();
		:}
	;


/* 61 */
unsigned_long_int
	::= 
		T_UNSIGNED T_LONG
		{:
			RESULT = helper.parseUnsignedLongType();
		:}		
	;

/* 62 */
unsigned_longlong_int
	::= 
		T_UNSIGNED T_LONG T_LONG
		{:
			RESULT = helper.parseUnsignedLongLongType();
		:}	
	;


/* 63 */
char_type
	::= 
		T_CHAR
		{:
			RESULT = helper.parseCharType();
		:}
	;


/* 64 */
wide_char_type
	::= 	
		T_WCHAR
		{:
			RESULT = helper.parseWideCharType();
		:}
	;


/* 65 */
boolean_type
	::= 		
		T_BOOLEAN
		{:
			RESULT = helper.parseBooleanType();
		:}		
	;


/* 66 */
octet_type
	::= 
		T_OCTET
		{:
			RESULT = helper.parseOctetType();
		:}				
	;


/* 67 */
any_type
	::= 
		T_ANY
		{:
			RESULT = helper.parseAnyType();
		:}				
	;


/* 68 */
object_type
	::= 
		T_OBJECT
		{:
			RESULT = helper.parseObjectType();
		:}				
	;


/* 69 */
struct_type
	::= 
		T_STRUCT T_IDENTIFIER:id
		{:
			helper.registerTypeId(id);
		:}		
	 	T_LEFT_CURLY_BRACKET member_list:l T_RIGHT_CURLY_BRACKET
	 	{:
	 		RESULT = helper.parseStructType(id, l);
	 	:}
	;


/* 70 */
member_list
	::= 
		member:m
		{:
			RESULT = helper.parseMemberList(m);
		:}
	| 
		member:m member_list:l
		{:
			RESULT = helper.parseMemberList(m,l);
		:}
	;


/* 71 */
member
	::= 
		type_spec:t declarators:d T_SEMICOLON
		{:
			RESULT = helper.parseMember(t,d);
		:}
	;


/* 72 */
union_type
	::= 	
		T_UNION T_IDENTIFIER:id
		{:
			helper.registerTypeId(id);
		:}				
		T_SWITCH T_LEFT_PARANTHESIS switch_type_spec:sw 
		T_RIGHT_PARANTHESIS T_LEFT_CURLY_BRACKET switch_body:b T_RIGHT_CURLY_BRACKET
		{:
			RESULT = helper.parseUnionType(id, sw, b);		
		:}
	; 


/* 73 */
switch_type_spec
	::= 
		integer_type:t
		{:
			RESULT = t;
		:}
	| 
		char_type:t
		{:
			RESULT = t;
		:}
	| 
		boolean_type:t
		{:
			RESULT = t;
		:}
	| 
		enum_type:t
		{:
			RESULT = t;
		:}
	| 
		scoped_name:id
		{:
			RESULT = helper.getModelRepository().findIdlType(id);
		:}
	;


/* 74 */
switch_body
	::= 
		case:c
		{:
			RESULT = helper.parseSwitchBody(c);
		:}
	| 
		case:c switch_body:l
		{:
			RESULT = helper.parseSwitchBody(c, l);
		:}
	;


/* 75 */
case	
	::= 
		case_label:l case:c
		{:
			RESULT = helper.parseCase(l, c);
		:}
	| 
		case_label:l element_spec:e T_SEMICOLON
		{:
			RESULT = helper.parseCase(l, e);
		:}
	;


/* 76 */
case_label
	::= 
		T_CASE const_exp:c T_COLON 
		{:
			RESULT = c;
		:}
	| 
		T_DEFAULT T_COLON
		{:
			RESULT = "default";
		:}
	;


/* 77 */
element_spec
	::= 
		type_spec:t declarator:id
		{:
			RESULT = helper.parseElementSpec(t, id);
		:}
	;


/* 78 */
enum_type
	::= T_ENUM T_IDENTIFIER:id 
		{:
			helper.registerTypeId(id);
		:}		
		T_LEFT_CURLY_BRACKET enumerators:l T_RIGHT_CURLY_BRACKET
		{:
			RESULT = helper.parseEnumType(id, l);
		:}
	;

enumerators
	::= 
		enumerator:e
		{:
			RESULT = helper.parseEnumerator(e); 
		:}
	| 
		enumerator:e T_COMMA enumerators:l
		{:
			RESULT = helper.parseEnumerators(e,l);
		:}
	;


/* 79 */
enumerator
	::= 
		T_IDENTIFIER:id
		{:
			RESULT = id;
		:}
	;


/* 80 */
sequence_type
	::= 
		T_SEQUENCE T_LESS_THAN_SIGN simple_type_spec:t T_COMMA positive_int_const:b T_GREATER_THAN_SIGN
		{:
			RESULT = helper.	parseSequenceType(t, b);
		:}
	| 
		T_SEQUENCE T_LESS_THAN_SIGN simple_type_spec:t T_GREATER_THAN_SIGN
		{:
			RESULT = helper.	parseSequenceType(t);
		:}
	;


/* 81 */
string_type
	::= 
		T_STRING T_LESS_THAN_SIGN positive_int_const:b T_GREATER_THAN_SIGN
		{:
			RESULT = helper.	parseBoundedStringType(b);
		:}
	| 
		T_STRING
		{:
			RESULT = helper.parseStringType();
		:}
	;


/* 82 */
wide_string_type
	::= 
		T_WSTRING T_LESS_THAN_SIGN positive_int_const:b T_GREATER_THAN_SIGN
		{:
			RESULT = helper.parseBoundedWideStringType(b);
		:}		
	| 
		T_WSTRING
		{:
			RESULT = helper.parseWideStringType();
		:}		
	;


/* 83 */
array_declarator
	::= T_IDENTIFIER:id
//		{:
//			helper.registerTypeId(id);
//		:}
		fixed_array_sizes:l
		{:
			
			RESULT = helper.parseArrayDeclarator(id, l);
		:}
	;

fixed_array_sizes
	::= 
		fixed_array_size:i
		{:
			RESULT = helper.parseFixedArraySizes(i);
		:}
	| 
		fixed_array_size:i fixed_array_sizes:l
		{:
			RESULT = helper.parseFixedArraySizes(i,l);
		:}
	;


/* 84 */
fixed_array_size
	::= 
		T_LEFT_SQUARE_BRACKET positive_int_const:i T_RIGHT_SQUARE_BRACKET
		{:
			RESULT = i;
		:}
	;


/* 85 */
attr_dcl
	::= 
		readonly_attr_spec:a
		{:
			RESULT = a;
		:}
	| 
		attr_spec:a
		{:
			RESULT = a;
		:}
	;


/* 86 */
except_dcl
	::= 
		T_EXCEPTION T_IDENTIFIER:id 
		{:
			helper.registerTypeId(id);
		:}			 	
		T_LEFT_CURLY_BRACKET members:l T_RIGHT_CURLY_BRACKET
		{:
			RESULT = helper.parseExceptionDcl(id, l);
		:}
	;

members
	::= 
		/*empty*/
		{:
			RESULT = new ArrayList();
		:}
	| 
		member:m members:l
		{:
			l.add(m);
			RESULT = l;
		:}
	;


/* 87 */
op_dcl
	::= 
		op_attribute:a op_type_spec:t T_IDENTIFIER:id parameter_dcls:pl raises_expr:el context_expr:cl
		{:
			RESULT = helper.parseOperationWithExceptionsAndContext(a,t,id,pl,el,cl);
		:}
	| 
		op_attribute:a op_type_spec:t T_IDENTIFIER:id parameter_dcls:pl context_expr:cl
		{:
			RESULT = helper.parseOperationWithContext(a,t,id,pl,cl);		
		:}
	| 
		op_attribute:a op_type_spec:t T_IDENTIFIER:id parameter_dcls:pl raises_expr:el
		{:
			RESULT = helper.parseOperationWithExceptions(a,t,id,pl,el);	
		:}
	| 
		op_attribute:a op_type_spec:t T_IDENTIFIER:id parameter_dcls:pl
		{:
			RESULT = helper.parseOperation(a,t,id,pl);
		:}
	;


/* 88 */
op_attribute
	::= 
		/*empty*/
		{:
			RESULT = Boolean.FALSE; // is oneway = false
		:}		
	| 
		T_ONEWAY
		{:
			RESULT = Boolean.TRUE; // is oneway = true
		:}
	;


/* 89 */
op_type_spec	
	::= 
		param_type_spec:t
		{:
			RESULT = t;
		:}
	| 
		T_VOID
		{:
			RESULT = helper.parseOpTypeVoid();
		:}
	;


/* 90 */
parameter_dcls
	::= 
		T_LEFT_PARANTHESIS param_dcls:l T_RIGHT_PARANTHESIS
		{:
			RESULT = l;
		:}
	| 
		T_LEFT_PARANTHESIS T_RIGHT_PARANTHESIS
		{:
			RESULT = helper.parseParameterDcls();
		:}
		
	;

param_dcls
	::= 
		param_dcl:p
		{:
			RESULT = helper.	parseParameterDcls(p);		
		:}
	| 
		param_dcl:p T_COMMA param_dcls:l
		{:
			RESULT = helper.	parseParameterDcls(p,l);	
		:}
	;


/* 91 */
param_dcl
	::= 
		param_attribute:a param_type_spec:t simple_declarator:id
		{:
			RESULT = helper.parseParameterDcl(a, t, id);
		:}
	;


/* 92 */
param_attribute
	::= 
		T_IN
		{:
			RESULT = MParameterMode.PARAM_IN;
		:}		
	| 
		T_OUT
		{:
			RESULT = MParameterMode.PARAM_OUT;
		:}		
	| 
		T_INOUT
		{:
			RESULT = MParameterMode.PARAM_INOUT;
		:}		
	;


/* 93 */
raises_expr
	::= 
		T_RAISES T_LEFT_PARANTHESIS scoped_names:l T_RIGHT_PARANTHESIS
		{:
			RESULT = helper.parseExceptionList(l);
		:}
	;


/* 94 */
context_expr
	::= 
		T_CONTEXT T_LEFT_PARANTHESIS string_literals:l T_RIGHT_PARANTHESIS
		{:
			RESULT = helper.parseContextExpr(l);
		:}
	;

string_literals
	::= 
		T_string_literal:s
		{:
			RESULT = helper.parseStringLiterals(s);
		:}
	| 
		T_string_literal:s T_COMMA string_literals:l
		{:
			RESULT = helper.parseStringLiterals(s,l);
		:}
	;

T_string_literal
	::= 
		T_STRING_LITERAL:s
		{:
			RESULT = helper.parseStringLiteral(s);
		:}
	| 
		T_STRING_LITERAL:s1 T_string_literal:s2
		{:
			RESULT = helper.parseStringConcatenation(s1, s2);
		:}
	;

T_wstring_literal
	::= 
		T_WSTRING_LITERAL:s
		{:
			RESULT = helper.parseWideStringLiteral(s);	
		:}
	| 
		T_WSTRING_LITERAL:s1 T_wstring_literal:s2
		{:
			RESULT = helper.parseWideStringConcatenation(s1, s2);
		:}
	;


/* 95 */
param_type_spec
	::= 
		base_type_spec:t
		{:
			RESULT = t;
		:}
	| 
		template_type_spec:t
		{:
			RESULT = t;
		:}
	| 
		scoped_name:id
		{:
			RESULT = helper.getModelRepository().findIdlType(id);	
		:}
	;


/* 96 */
fixed_pt_type
	::= 
		T_FIXED T_LESS_THAN_SIGN positive_int_const:d T_COMMA T_INTEGER_LITERAL:s T_GREATER_THAN_SIGN
		{:
			RESULT = helper.parseFixedType(d,s);
		:}
	;


/* 97 */
fixed_pt_const_type
	::= 
		T_FIXED
	;


/* 98 */
value_base_type
	::= 
		T_VALUEBASE
		{:
			RESULT = helper.parseValueBaseType();
		:}
	;


/* 99 A (from 2.4, not in CCM) */
constr_forward_decl
	::= 
		T_STRUCT T_IDENTIFIER:id
		{:
			RESULT = helper.parseStructForwardDeclaration(id);
		:}
	| 
		T_UNION T_IDENTIFIER:id
		{:
			RESULT = helper.parseUnionForwardDeclaration(id);
		:}
	;


/* 99 */
/* 100 */
import_dcl
	::= T_IMPORT imported_scope
	;

imported_scope
	::= scoped_name
	| T_string_literal
	;


/* 102 */
type_id_dcl
	::= 
		T_TYPEID scoped_name:ns T_string_literal:s
		{:
			helper.notSupported("repository identity declarations (e.g. " + s + "-> " + ns + ")");
		:}
	;


/* 103 */
type_prefix_dcl
	::= 
		T_TYPEPREFIX scoped_name T_string_literal:s
		{:
			helper.notSupported("repository identity prefix declarations (e.g. " + s + ")");
		:}		
	;


/* 104 */
readonly_attr_spec
	::= 	
		T_READONLY T_ATTRIBUTE param_type_spec:t readonly_attr_declarator:d
		{:
			RESULT = helper.parseReadonlyAttrSpec(t, d);
		:}
	;


/* 105 */
readonly_attr_declarator
	::= 
		simple_declarator:d raises_expr:r
		{:
			RESULT = helper.parseReadonlyAttrDeclarator(d, r);
		:}
	| 
		simple_declarators:l
		{:
			RESULT = l;
		:}
	;

simple_declarators
	::= 
		simple_declarator:d
		{:
			RESULT = helper.parseSimpleDeclarators(d);
		:}
	| 
		simple_declarator:d T_COMMA simple_declarators:l
		{:
			RESULT = helper.parseSimpleDeclarators(d, l);
		:}
	;


/* 106 */
attr_spec
	::= 
		T_ATTRIBUTE param_type_spec:t attr_declarator:d
		{:
			RESULT = helper.parseAttrSpec(t, d);
		:}
	;


/* 107 */
attr_declarator
	::= 
		simple_declarator:d attr_raises_expr:r
		{:
			RESULT = helper.parseAttrDeclarator(d, r);
		:}
	| 
		simple_declarators:l
		{:
			RESULT = l;
		:}
	;


/* 108 */
attr_raises_expr
	::= 
		get_excep_expr:g
		{:
			RESULT = helper.parseAttrGetRaisesExpr(g);
		:}		
	| 
		set_excep_expr:s
		{:
			RESULT = helper.parseAttrSetRaisesExpr(s);
		:}		
	| 
		get_excep_expr:g set_excep_expr:s
		{:
			RESULT = helper.parseAttrGetAndSetRaisesExpr(g,s);
		:}		
	| 
		set_excep_expr:s get_excep_expr:g
		{:
			RESULT = helper.parseAttrGetAndSetRaisesExpr(g,s);
		:}				
	;


/* 109 */
get_excep_expr
	::= 
		T_GETRAISES exception_list:l
		{:
			RESULT = l;
		:}
	;


/* 110 */
set_excep_expr
	::= 
		T_SETRAISES exception_list:l
		{:
			RESULT = l;
		:}
	;


/* 111 */
exception_list
	::= 
		T_LEFT_PARANTHESIS scoped_names:l T_RIGHT_PARANTHESIS
		{:
			RESULT = helper.parseExceptionList(l);
		:}
	;



/* 112 */
component
	::= component_dcl
	| component_forward_dcl
	;


/* 112 */
component_forward_dcl
	::= T_COMPONENT T_IDENTIFIER:id
		{:
//			helper.getModelRepository().registerForwardDeclaration(id);
		:}
	;


/* 113 */
component_dcl
	::= component_header T_LEFT_CURLY_BRACKET component_body T_RIGHT_CURLY_BRACKET
	| component_header T_LEFT_CURLY_BRACKET T_RIGHT_CURLY_BRACKET
	;


/* 114 */
component_header
	::= 
		T_COMPONENT T_IDENTIFIER:id
		{:
			helper.registerTypeId(id);
		:}				
	| 
		T_COMPONENT T_IDENTIFIER:id component_inheritance_spec
		{:
			helper.registerTypeId(id);
		:}				
	| 
		T_COMPONENT T_IDENTIFIER:id supported_interface_spec
		{:
			helper.registerTypeId(id);
		:}		
	| 
		T_COMPONENT T_IDENTIFIER:id component_inheritance_spec supported_interface_spec
		{:
			helper.registerTypeId(id);
		:}		
	;


/* 115 */
supported_interface_spec
	::= T_SUPPORTS interface_names
	;


/* 116 */
component_inheritance_spec
	::= T_COLON scoped_name
	;


/* 117 */
component_body
	::= component_export
	| component_export component_body
	;


/* 118 */
component_export
	::= provides_dcl T_SEMICOLON
	| uses_dcl T_SEMICOLON
	| emits_dcl T_SEMICOLON
	| publishes_dcl T_SEMICOLON
	| consumes_dcl T_SEMICOLON
	| attr_dcl T_SEMICOLON
	;


/* 119 */
provides_dcl
	::= T_PROVIDES interface_type T_IDENTIFIER
	;


/* 120 */
interface_type
	::= scoped_name
	| T_OBJECT
	;


/* 121 */
uses_dcl
	::= T_USES interface_type T_IDENTIFIER
	| T_USES T_MULTIPLE interface_type T_IDENTIFIER
	;


/* 122 */
emits_dcl
	::= T_EMITS scoped_name T_IDENTIFIER
	;


/* 123 */
publishes_dcl
	::= T_PUBLISHES scoped_name T_IDENTIFIER
	;


/* 124 */
consumes_dcl
	::= T_CONSUMES scoped_name T_IDENTIFIER
	;


/* 125 */
home_dcl
	::= home_header home_body
	;


/* 126 */
home_header
	::= 
		T_HOME T_IDENTIFIER:id 
			T_MANAGES scoped_name
		{:
			helper.registerTypeId(id);
		:}				
	| 
		T_HOME T_IDENTIFIER:id 
			home_inheritance_spec T_MANAGES scoped_name
		{:
			helper.registerTypeId(id);
		:}				
	| 
		T_HOME T_IDENTIFIER:id 
			T_MANAGES scoped_name primary_key_spec
		{:
			helper.registerTypeId(id);
		:}				
	| 
		T_HOME T_IDENTIFIER:id 
			home_inheritance_spec T_MANAGES scoped_name primary_key_spec
		{:
			helper.registerTypeId(id);
		:}				
	| 
		T_HOME T_IDENTIFIER:id 
			supported_interface_spec T_MANAGES scoped_name
		{:
			helper.registerTypeId(id);
		:}		
	| 
		T_HOME T_IDENTIFIER:id 
			home_inheritance_spec supported_interface_spec T_MANAGES scoped_name
		{:
			helper.registerTypeId(id);
		:}				
	| 
		T_HOME T_IDENTIFIER:id 
			supported_interface_spec T_MANAGES scoped_name primary_key_spec
		{:
			helper.registerTypeId(id);
		:}		
	| 
		T_HOME T_IDENTIFIER:id 
			home_inheritance_spec supported_interface_spec T_MANAGES scoped_name primary_key_spec 
		{:
			helper.registerTypeId(id);
		:}				
	;


/* 127 */
home_inheritance_spec
	::= T_COLON scoped_name
	;


/* 128 */
primary_key_spec
	::= T_PRIMARYKEY scoped_name
	;


/* 129 */
home_body
	::= T_LEFT_CURLY_BRACKET home_exports T_RIGHT_CURLY_BRACKET
	| T_LEFT_CURLY_BRACKET T_RIGHT_CURLY_BRACKET
	;


/* 130 */
home_exports
	::= home_export
	| home_export home_exports
	;

home_export
	::= export
	| factory_dcl T_SEMICOLON
	| finder_dcl T_SEMICOLON
	;


/* 131 */
factory_dcl
	::= T_FACTORY T_IDENTIFIER T_LEFT_PARANTHESIS init_param_decls T_RIGHT_PARANTHESIS raises_expr
	| T_FACTORY T_IDENTIFIER T_LEFT_PARANTHESIS T_RIGHT_PARANTHESIS raises_expr
	| T_FACTORY T_IDENTIFIER T_LEFT_PARANTHESIS init_param_decls T_RIGHT_PARANTHESIS
	| T_FACTORY T_IDENTIFIER T_LEFT_PARANTHESIS T_RIGHT_PARANTHESIS
	;


/* 132 */
finder_dcl
	::= T_FINDER T_IDENTIFIER T_LEFT_PARANTHESIS init_param_decls T_RIGHT_PARANTHESIS raises_expr
	| T_FINDER T_IDENTIFIER T_LEFT_PARANTHESIS T_RIGHT_PARANTHESIS raises_expr
	| T_FINDER T_IDENTIFIER T_LEFT_PARANTHESIS init_param_decls T_RIGHT_PARANTHESIS
	| T_FINDER T_IDENTIFIER T_LEFT_PARANTHESIS T_RIGHT_PARANTHESIS
	;


/* 134 */
event
	::= event_dcl
	| event_abs_dcl
	| event_forward_dcl
	;


/* 135 */
event_forward_dcl
	::= 
		T_EVENTTYPE T_IDENTIFIER:id
		{:
//			helper.getModelRepository().registerForwardDeclaration(id);
		:}
	| 
		T_ABSTRACT T_EVENTTYPE T_IDENTIFIER:id
		{:
//			helper.getModelRepository().registerForwardDeclaration(id);
		:}
	;


/* 136 */
event_abs_dcl
	::= 
		T_ABSTRACT T_EVENTTYPE T_IDENTIFIER:id 
		{:
			helper.registerTypeId(id);
		:}			 	
		T_LEFT_CURLY_BRACKET value_body T_RIGHT_CURLY_BRACKET
	| 
		T_ABSTRACT T_EVENTTYPE T_IDENTIFIER:id value_inheritance_spec 
		{:
			helper.registerTypeId(id);
		:}				
		T_LEFT_CURLY_BRACKET value_body T_RIGHT_CURLY_BRACKET
	;


/* 137 */
event_dcl
	::= event_header T_LEFT_CURLY_BRACKET value_elements T_RIGHT_CURLY_BRACKET
	| event_header T_LEFT_CURLY_BRACKET T_RIGHT_CURLY_BRACKET
	;


/* 138 */
event_header
	::= 
		T_EVENTTYPE T_IDENTIFIER:id value_inheritance_spec 
		{:
			helper.registerTypeId(id);
		:}		
	| 
		T_CUSTOM T_EVENTTYPE T_IDENTIFIER:id value_inheritance_spec
		{:
			helper.registerTypeId(id);
		:}		
		
	| 
		T_EVENTTYPE T_IDENTIFIER:id
		{:
			helper.registerTypeId(id);
		:}				
	| 
		T_CUSTOM T_EVENTTYPE T_IDENTIFIER:id
		{:
			helper.registerTypeId(id);
		:}		
	;
