/*
 * This file was automatically generated by %(CcmToolsVersion)s 
 * <http://ccmtools.sourceforge.net>
 * DO NOT EDIT! 
 */

//==============================================================================
// %(Identifier)s - component logic
//==============================================================================

#ifndef __COMPONENT_%(PreprocIdentifier)s_GEN__H__
#define __COMPONENT_%(PreprocIdentifier)s_GEN__H__

#include <string>
#include <map>
#include <wamas/platform/utils/smartptr.h>
#include <Components/ccm/local/CCM.h>

#include <%(SelfInclude)s_share.h>
#include <%(HomeInclude)s_share.h>

%(MAttributeDefInclude)s
%(MConstantDefInclude)s
%(MSupportsDefInclude)s
%(MProvidesDefInclude)s
%(MConsumesDefInclude)s
%(MEmitsDefInclude)s
%(MPublishesDefInclude)s
%(MUsesDefInclude)s
%(BaseInclude)s

%(OpenNamespace)s

class %(HomeType)s;

//==============================================================================
// %(Identifier)s local component adapter class
//==============================================================================

class %(Identifier)s
    : virtual public ::Components::ccm::local::CCMObject 
      %(MSupportsDefBase)s
      %(BaseType)s 	
{
  public:
    %(Identifier)s();
    %(Identifier)s(%(HomeType)s* h, 
        CCM_%(Identifier)s* lc,  
        wamas::platform::utils::SmartPtr< ::Components::ccm::local::Assembly> a);
    virtual ~%(Identifier)s();

%(MAttributeDefPrototype)s
%(MProvidesDefProvidePrototype)s
%(MUsesDefConnectPrototype)s
%(MUsesDefGetConnectionPrototype)s

    // Navigation functions
    wamas::platform::utils::SmartPtr< ::Components::ccm::local::Object> 
    provide_facet(const std::string& name)
        throw(::Components::ccm::local::InvalidName);

    // Receptacle functions
    ::Components::ccm::local::Cookie 
    connect(const ::Components::ccm::local::FeatureName& name, 
        wamas::platform::utils::SmartPtr< ::Components::ccm::local::Object> connection)
        throw(::Components::ccm::local::InvalidName, 
              ::Components::ccm::local::InvalidConnection,
              ::Components::ccm::local::AlreadyConnected, 
              ::Components::ccm::local::ExceededConnectionLimit);

    void 
    disconnect(const ::Components::ccm::local::FeatureName& name, 
        const ::Components::ccm::local::Cookie& ck)
        throw(::Components::ccm::local::InvalidName, 
              ::Components::ccm::local::InvalidConnection,
              ::Components::ccm::local::CookieRequired, 
              ::Components::ccm::local::NoConnection );

    // CCMObject functions
    ::Components::ccm::local::HomeExecutorBase* get_ccm_home();

    void configuration_complete()
        throw(::Components::ccm::local::InvalidConfiguration);

    void configuration_complete(CCM_%(Identifier)s_Context* ctx)
        throw(::Components::ccm::local::InvalidConfiguration);

    void remove()
        throw(::Components::ccm::local::RemoveFailure);
 
   protected:
    %(HomeType)s* home_local_adapter;
    CCM_%(Identifier)s* local_component;
    CCM_%(Identifier)s_Context* context;
    wamas::platform::utils::SmartPtr< ::Components::ccm::local::Assembly> assembly;
    bool ValidConnection;

%(MProvidesDefAdapterVariable)s
%(MUsesDefAdapterVariable)s
        
  private:
    void operator=(const %(Identifier)s&);
};


//==============================================================================
// context adapter class
//==============================================================================

class CCM_%(Identifier)s_Context_impl
    : public CCM_%(Identifier)s_Context
{
  public:
    CCM_%(Identifier)s_Context_impl(%(Identifier)s* c);
    virtual ~CCM_%(Identifier)s_Context_impl();

%(MUsesDefGetCtxConnectionPrototype)s

    // CCMContext function
    ::Components::ccm::local::HomeExecutorBase* get_CCM_home();

    // SessionContext function	
    ::Components::ccm::local::Object* get_CCM_object()
        throw(::Components::ccm::local::IllegalState);

  protected:
    %(Identifier)s* component_local_adapter;
        
  private:
    void operator=(const CCM_%(Identifier)s_Context_impl&);
};

%(CloseNamespace)s

#endif


<<<<<<<SPLIT>>>>>>>
/*
 * This file was automatically generated by %(CcmToolsVersion)s
 * <http://ccmtools.sourceforge.net/>
 * DO NOT EDIT !
 */

//==============================================================================
// %(Identifier)s - component logic implementation
//==============================================================================

#include <cassert>
#include <iostream>
#include <sstream>
#include <wamas/platform/utils/debug.h>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

%(MProvidesDefAdapterInclude)s

#include "%(Identifier)s_gen.h"

%(OpenNamespace)s

using namespace std;
using namespace wamas::platform::utils;

//==============================================================================
// local component adapter implementation
//==============================================================================

%(Identifier)s::%(Identifier)s()
{
    home_local_adapter = NULL;
    local_component = NULL;
    context = NULL;
    assembly = SmartPtr< ::Components::ccm::local::Assembly>();	
    ValidConnection = false;
%(MProvidesDefAdapterVariableInitDefault)s
%(MUsesDefAdapterVariableInitDefault)s
}

%(Identifier)s::%(Identifier)s(%(HomeType)s* h, 
    CCM_%(Identifier)s* lc,
    SmartPtr< ::Components::ccm::local::Assembly> a)
    : %(MSupportsDefAdapterConstructor)s
    home_local_adapter(h), 
    local_component(lc), 
    assembly(a)
{
    context = NULL; 
    ValidConnection = true;
%(MProvidesDefAdapterVariableInit)s
%(MUsesDefAdapterVariableInit)s
}

%(Identifier)s::~%(Identifier)s()
{
    delete context;
    delete local_component;
    %(MProvidesDefAdapterVariableDestroy)s
}

%(MAttributeDefAdapterDefinition)s
%(MProvidesDefAdapterDefinition)s
%(MUsesDefAdapterDefinition)s

// Navigation functions

wamas::platform::utils::SmartPtr< ::Components::ccm::local::Object>
%(Identifier)s::provide_facet(const std::string& name)
    throw(::Components::ccm::local::InvalidName)
{
%(MProvidesDefProvideFacet)s
    throw ::Components::ccm::local::InvalidName();
}


// Receptacle functions

::Components::ccm::local::Cookie
%(Identifier)s::connect(const ::Components::ccm::local::FeatureName& name, 
                        SmartPtr< ::Components::ccm::local::Object> connection)
    throw(::Components::ccm::local::InvalidName, 
          ::Components::ccm::local::InvalidConnection,
          ::Components::ccm::local::AlreadyConnected, 
          ::Components::ccm::local::ExceededConnectionLimit)
{
%(MUsesDefConnectFacet)s
    throw ::Components::ccm::local::InvalidName();
}

void
%(Identifier)s::disconnect(const ::Components::ccm::local::FeatureName& name, 
                           const ::Components::ccm::local::Cookie& ck)
    throw(::Components::ccm::local::InvalidName, 
          ::Components::ccm::local::InvalidConnection,
          ::Components::ccm::local::CookieRequired, 
          ::Components::ccm::local::NoConnection )
{
    if(!ValidConnection) 
        throw ::Components::ccm::local::InvalidConnection();

%(MUsesDefDisconnectFacet)s
    throw ::Components::ccm::local::InvalidName();
}


// CCMObject functions

::Components::ccm::local::HomeExecutorBase*
%(Identifier)s::get_ccm_home (  )
{
    throw ::Components::ccm::local::NotImplemented();
}


void
%(Identifier)s::configuration_complete()
    throw(::Components::ccm::local::InvalidConfiguration)
{
    configuration_complete(new CCM_%(Identifier)s_Context_impl(this));
}


void
%(Identifier)s::configuration_complete(CCM_%(Identifier)s_Context* ctx)
    throw(::Components::ccm::local::InvalidConfiguration)
{
    if(!ValidConnection) 
        throw ::Components::ccm::local::InvalidConnection();
    if(!context)
      context = ctx;
    if(assembly != SmartPtr< ::Components::ccm::local::Assembly>()) { 
        assembly->configuration_complete(); 
    }
    local_component->set_session_context(context);
    local_component->ccm_activate();
}


void
%(Identifier)s::remove()
    throw(::Components::ccm::local::RemoveFailure)
{
    if(!ValidConnection) 
        throw ::Components::ccm::local::InvalidConnection();
    local_component->ccm_remove();
%(MProvidesDefImplRemove)s

    if(assembly != SmartPtr< ::Components::ccm::local::Assembly>()) { 
        assembly->tear_down(); 
        // To resolve a cyclic smart pointer reference between a component
        // and an assembly object, the assembly smart pointer must be cleaned.
        assembly = SmartPtr< ::Components::ccm::local::Assembly>();
    }
    ValidConnection = false;
}


//==============================================================================
// context adapter class implementation
//==============================================================================

CCM_%(Identifier)s_Context_impl::CCM_%(Identifier)s_Context_impl(%(Identifier)s* c)
    : component_local_adapter(c)
{
}

CCM_%(Identifier)s_Context_impl::~CCM_%(Identifier)s_Context_impl()
{
}

%(MUsesDefGetConnectionCtxImplDefinition)s

::Components::ccm::local::HomeExecutorBase*
CCM_%(Identifier)s_Context_impl::get_CCM_home()
{
    throw ::Components::ccm::local::NotImplemented();
}

::Components::ccm::local::Object*
CCM_%(Identifier)s_Context_impl::get_CCM_object()
    throw(::Components::ccm::local::IllegalState)
{
    throw ::Components::ccm::local::NotImplemented();
}

%(CloseNamespace)s


<<<<<<<SPLIT>>>>>>>
/*
 * This file was automatically generated by %(CcmToolsVersion)s
 * <http://ccmtools.sourceforge.net/>
 * DO NOT EDIT !
 */

//==============================================================================
// %(Identifier)s - shared class definitions
//==============================================================================

#ifndef __COMPONENT_%(PreprocIdentifier)s_SHARE__H__
#define __COMPONENT_%(PreprocIdentifier)s_SHARE__H__

#include <map>
#include <wamas/platform/utils/smartptr.h>
#include <Components/ccm/local/CCM.h>

%(MAttributeDefInclude)s
%(MConstantDefInclude)s
%(MSupportsDefInclude)s
%(MProvidesDefInclude)s
%(MConsumesDefInclude)s
%(MEmitsDefInclude)s
%(MPublishesDefInclude)s
%(BaseInclude)s
%(MUsesDefInclude)s

%(OpenNamespace)s

//==============================================================================
// Component class
//==============================================================================

class CCM_%(Identifier)s
    : virtual public ::Components::ccm::local::SessionComponent%(BaseType)s%(MSupportsDefBase)s
{
  public:
    virtual ~CCM_%(Identifier)s() {}
    
%(MAttributeDefPrototypeVV)s
%(MProvidesDefGetFacetPrototypeVV)s
%(MSupportsDefImplPrototypeVV)s
};


//==============================================================================
// Context class
//==============================================================================

%(MUsesDefConnectionMap)s

class CCM_%(Identifier)s_Context
    : virtual public ::Components::ccm::local::SessionContext
{
  public:
    virtual ~CCM_%(Identifier)s_Context() {}
    
%(MUsesDefGetConnectionPrototypeVV)s
};

%(CloseNamespace)s

#endif // __COMPONENT_%(PreprocIdentifier)s_SHARE__H__


<<<<<<<SPLIT>>>>>>>
/***
 * This file was automatically generated by %(CcmToolsVersion)s
 * <http://ccmtools.sourceforge.net/>
 *
 * %(Identifier)s component business logic definition.
 * 
 * // TODO: WRITE YOUR DESCRIPTION HERE! 
 *
 * @author
 * @version 
 ***/

#ifndef __COMPONENT_%(PreprocIdentifier)s_IMPL__H__
#define __COMPONENT_%(PreprocIdentifier)s_IMPL__H__

#include <%(ComponentInclude)s/%(Identifier)s_share.h>

%(OpenNamespace)s

/**
 * This class implements a component's equivalent and supported interfaces
 * as well as component attributes. Additionally, session component callback 
 * methods must be implemented.  
 *
 * %(Identifier)s component class 
 *
 * // TODO: WRITE YOUR DESCRIPTION HERE! 
 *
 * @author
 * @version 
 **/
class %(Identifier)s_impl
    : virtual public CCM_%(Identifier)s%(BaseType)s
{
  private:
%(MAttributeDefVariable)s
%(MSupportsDefVariable)s

  public:
    CCM_%(Identifier)s_Context* ctx;

    %(Identifier)s_impl();
    virtual ~%(Identifier)s_impl();

%(MAttributeDefPrototype)s
%(MProvidesDefGetFacetPrototype)s
%(MSupportsDefImplPrototype)s

    // CCM callback methods
    virtual void set_session_context(::Components::ccm::local::SessionContext* ctx)
        throw(::Components::ccm::local::CCMException);
    virtual void ccm_activate()
        throw(::Components::ccm::local::CCMException);
    virtual void ccm_passivate()
        throw(::Components::ccm::local::CCMException);
    virtual void ccm_remove()
        throw(::Components::ccm::local::CCMException);
};

%(CloseNamespace)s

#endif


<<<<<<<SPLIT>>>>>>>
/***
 * This file was automatically generated by %(CcmToolsVersion)s
 * <http://ccmtools.sourceforge.net/>
 *
 * %(Identifier)s component business logic implementation.
 * 
 * // TODO: WRITE YOUR DESCRIPTION HERE! 
 *
 * @author
 * @version 
 ***/

#include <cassert>
#include <iostream>
#include <wamas/platform/utils/debug.h>

#include "%(Identifier)s_impl.h"
%(MProvidesDefImplInclude)s

%(OpenNamespace)s

using namespace std;
using namespace wamas::platform::utils;

//==============================================================================
// %(Identifier)s - component implementation
//==============================================================================

%(Identifier)s_impl::%(Identifier)s_impl()
{
    // OPTIONAL : IMPLEMENT ME HERE !
}

%(Identifier)s_impl::~%(Identifier)s_impl()
{
    // OPTIONAL : IMPLEMENT ME HERE !
}

%(MAttributeDefImplDefinition)s
%(MSupportsDefImplDefinition)s

void
%(Identifier)s_impl::set_session_context(
    ::Components::ccm::local::SessionContext* context)
    throw(::Components::ccm::local::CCMException)
{
    ctx = dynamic_cast<CCM_%(Identifier)s_Context*>(context);
}

void
%(Identifier)s_impl::ccm_activate()
    throw(::Components::ccm::local::CCMException)
{
    // OPTIONAL : IMPLEMENT ME HERE !
}

void
%(Identifier)s_impl::ccm_passivate()
    throw(::Components::ccm::local::CCMException)
{
    // OPTIONAL : IMPLEMENT ME HERE !
}

void
%(Identifier)s_impl::ccm_remove()
    throw(::Components::ccm::local::CCMException)
{
    // OPTIONAL : IMPLEMENT ME HERE !
}

%(MProvidesDefGetFacetDefinition)s

%(CloseNamespace)s

