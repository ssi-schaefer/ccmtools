//==============================================================================
// %(Identifier)s - interface Python wrapper prototypes
//==============================================================================

#ifndef __CCM_TEST__PYTHON__IFACE__%(PreprocIdentifier)s__H__
#define __CCM_TEST__PYTHON__IFACE__%(PreprocIdentifier)s__H__

#include <%(SelfInclude)s.h>
#include <Python.h>
#include "structmember.h"

%(MAttributeDefInclude)s
%(MOperationDefInclude)s
%(BaseInclude)s

%(OpenNamespace)s

PyObject *convert_%(Identifier)s_to_python           (       %(Identifier)s  arg );
PyObject *convert_const_%(Identifier)s_to_python     ( const %(Identifier)s  arg );
PyObject *convert_const_%(Identifier)s_ref_to_python ( const %(Identifier)s& arg );

%(Identifier)s  convert_%(Identifier)s_from_python     ( PyObject *arg );
%(Identifier)s *convert_%(Identifier)s_ptr_from_python ( PyObject *arg );

%(CloseNamespace)s

#endif

<<<<<<<SPLIT>>>>>>>
//==============================================================================
// %(Identifier)s - interface Python wrapper definitions
//==============================================================================

#include "%(Identifier)s.h"

%(OpenNamespace)s

// internal Python wrappers, data structures and memory management

typedef struct {
  PyObject_HEAD
  %(Identifier)s iface;
} Py%(Identifier)s_object;

%(MAttributeDefWrapper)s
%(MOperationDefWrapper)s

static PyMethodDef Py%(Identifier)s_methods[] = {
%(MAttributeDefMethod)s
%(MOperationDefMethod)s
  {NULL, 0, 0, NULL}  /* Sentinel */
};

static PyTypeObject Py%(Identifier)s_Type = {
  PyObject_HEAD_INIT ( NULL )

  0, /* ob_size */

  "%(PythonNamespace)s.%(Identifier)s", /* tp_name */
  sizeof ( Py%(Identifier)s_object ), /* tp_basicsize */

  0, /* tp_itemsize */
  0, /* tp_dealloc */
  0, /* tp_print */
  0, /* tp_getattr */
  0, /* tp_setattr */
  0, /* tp_compare */
  0, /* tp_repr */
  0, /* tp_as_number */
  0, /* tp_as_sequence */
  0, /* tp_as_mapping */
  0, /* tp_hash */
  0, /* tp_call */
  0, /* tp_str */
  0, /* tp_getattro */
  0, /* tp_setattro */
  0, /* tp_as_buffer */

  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */

  NULL, /* tp doc */

  0, /* tp_traverse */
  0, /* tp_clear */
  0, /* tp_richcompare */
  0, /* tp_weaklistoffset */
  0, /* tp_iter */
  0, /* tp_iternext */

  Py%(Identifier)s_methods, /* tp_methods */

  0, /* tp_members */
  0, /* tp_getset */
  0, /* tp_base */
  0, /* tp_dict */
  0, /* tp_descr_get */
  0, /* tp_descr_set */
  0, /* tp_dictoffset */
  0, /* tp_init */
  0, /* tp_alloc */
  0, /* tp_new */
};

// public conversion methods

PyObject *
convert_%(Identifier)s_to_python ( %(Identifier)s arg )
{
  Py%(Identifier)s_object *self = Py%(Identifier)s_new (  );
  if ( self == NULL ) return NULL;
%(MFieldDefTo)s
  Py_INCREF ( self );
  return ( PyObject * ) self;
}

PyObject *
convert_const_%(Identifier)s_to_python ( const %(Identifier)s arg )
{
  Py%(Identifier)s_object *self = Py%(Identifier)s_new (  );
  if ( self == NULL ) return NULL;
%(MFieldDefTo)s
  Py_INCREF ( self );
  return ( PyObject * ) self;
}

PyObject *
convert_const_%(Identifier)s_ref_to_python ( const %(Identifier)s& arg )
{
  Py%(Identifier)s_object *self = Py%(Identifier)s_new (  );
  if ( self == NULL ) return NULL;
%(MFieldDefTo)s
  Py_INCREF ( self );
  return ( PyObject * ) self;
}

%(Identifier)s
convert_%(Identifier)s_from_python ( PyObject *arg )
{
  %(Identifier)s result;
  if ( arg == NULL ) return result;
%(MFieldDefFrom)s
  Py_DECREF ( arg );
  return result;
}

%(Identifier)s *
convert_%(Identifier)s_ptr_from_python ( PyObject *arg )
{
  %(Identifier)s *result = new %(Identifier)s;
  if ( arg == NULL ) return NULL;
%(MFieldDefFromPointer)s
  Py_DECREF ( arg );
  return result;
}

%(CloseNamespace)s

#ifndef PyMODINIT_FUNC
#define PyMODINIT_FUNC void
#endif

%(OpenNamespace)s

PyMODINIT_FUNC
init_%(Identifier)s ( void )
{
  PyObject *module = NULL;
}

%(CloseNamespace)s
