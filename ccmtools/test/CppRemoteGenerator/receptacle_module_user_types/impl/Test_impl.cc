
/***
 * Test component business logic implementation.
 * 
 * // TODO: WRITE YOUR DESCRIPTION HERE! 
 *
 * @author
 * @version 
 *
 * This file structure was automatically generated by CCM Tools
 * <http://ccmtools.sourceforge.net/> and contains a component's
 * implementation classes. 
 ***/

#include <cassert>
#include <iostream>
#include <WX/Utils/debug.h>

#include "Test_impl.h"
#include "Test_inPort_impl.h"

using namespace std;
using namespace WX::Utils;
using namespace CCM_Local;

namespace CCM_Local {
namespace world {
namespace europe {
namespace austria {
namespace CCM_Session_Test {

//==============================================================================
// CCM_Test - component implementation
//==============================================================================

CCM_Test_impl::CCM_Test_impl()
{
    DEBUGNL("+CCM_Test_impl->CCM_Test_impl()");
}

CCM_Test_impl::~CCM_Test_impl()
{
    DEBUGNL("-CCM_Test_impl->~CCM_Test_impl()");
}

void
CCM_Test_impl::set_session_context(
    LocalComponents::SessionContext* context)
    throw(LocalComponents::CCMException)
{
    DEBUGNL(" CCM_Test_impl->set_session_context()");
    ctx = dynamic_cast<CCM_Test_Context*>(context);
}

void
CCM_Test_impl::ccm_activate()
    throw(LocalComponents::CCMException)
{
    DEBUGNL(" CCM_Test_impl->ccm_activate()");

    { // test case: long
      const long p1 = 7;
      long p2=3, p3, result;
      result = ctx->get_connection_outPort()->f1(p1, p2, p3);
      assert(p2 == 7);
      assert(p3 == 3);
      assert(result == 3+7);
    }


    { // test case: struct Person { long id; string name; };
      Person p1, p2, p3, result;
      p1.name = "Egon"; 
      p1.id = 3;
      p2.name = "Andrea"; 
      p2.id = 23;
      result = ctx->get_connection_outPort()->f2(p1,p2,p3);
      assert(p3.name == "Andrea");
      assert(p3.id == 23); 
      assert(p2.name == "Egon");
      assert(p2.id == 3); 
      assert(result.name  == "EgonAndrea");
      assert(result.id == 26);
    }

    { // test case: struct Address{ long id; string name; Person resident };
      Address p1, p2, p3, result;
      Person person;

      p1.street = "Waltendorf";   
      p1.number = 7;
      person.name = "Egon";   
      person.id   = 3;
      p1.resident = person;

      p2.street   = "Petersgasse"; 
      p2.number   =17;
      person.name = "Andrea";   
      person.id   = 23;
      p2.resident = person;

      result = ctx->get_connection_outPort()->f3(p1,p2,p3);
      
      assert(p3.street == "Petersgasse");
      assert(p3.number == 17);
      assert(p3.resident.name == "Andrea");
      assert(p3.resident.id == 23);

      assert(p2.street == "Waltendorf");
      assert(p2.number == 7);
      assert(p2.resident.name == "Egon");
      assert(p2.resident.id == 3);

      assert(result.street == "WaltendorfPetersgasse");
      assert(result.number == 24);
      assert(result.resident.name == "EgonAndrea");
      assert(result.resident.id == 26);
    }


    { // Test case: typedef sequence<list> LongList;
      LongList p1, p2, p3, result;
      const unsigned int size = 11;
      for(int i=0;i<(int)size;i++) {
        p1.push_back(i);
        p2.push_back(i+i);
      }

      result = ctx->get_connection_outPort()->f4(p1, p2, p3);

      assert(result.size() == size);
      for(unsigned int i=0;i<result.size();i++) {
        long p = result.at(i);
        assert(p == (long)i);
      }

      assert(p2.size() == size);
      for(unsigned int i=0;i<p2.size();i++) {
        long p = p2.at(i);
        assert(p == (long)i);
      }

      assert(p3.size() == size);
      for(unsigned int i=0;i<p3.size();i++) {
        long p = p3.at(i);
        assert(p == (long)(i+i));
      }
    }

    { // Test case: typedef sequence<string> StringList;
      StringList p1, p2, p3, result;
      const unsigned int size = 7;
      for(int i=0;i<(int)size;i++) {
        p1.push_back("one");
        p2.push_back("two");
      }

      result = ctx->get_connection_outPort()->f5(p1, p2, p3);

      assert(result.size() == size);
      for(unsigned int i=0;i<result.size();i++) {
        string p = result.at(i);
        assert(p == "Test");
      }

      assert(p2.size() == size);
      for(unsigned int i=0;i<p2.size();i++) {
        string p = p2.at(i);
        assert(p == "one");
      }

      assert(p3.size() == size);
      for(unsigned int i=0;i<p3.size();i++) {
        string p = p3.at(i);
        assert(p == "two");
      }
    }

    { // Test case: typedef sequence<Person> PersonList;
      PersonList pl1, pl2, pl3, result;
      const unsigned int size = 8;
      for(int i=0;i<(int)size;i++) {
        Person p1, p2;
        p1.name = "Egon";
        p1.id = i;
        pl1.push_back(p1);
        p2.name = "Andrea";
        p2.id = i+i;
        pl2.push_back(p2);
      }

      result = ctx->get_connection_outPort()->f6(pl1, pl2, pl3);

      assert(result.size() == size);
      for(unsigned int i=0;i<result.size();i++) {
        Person p = result.at(i);
        assert(p.id == (long)i);
        assert(p.name == "Test");
      }

      assert(pl2.size() == size);
      for(unsigned int i=0;i<pl2.size();i++) {
        Person p = pl2.at(i);
        assert(p.id == (long)i);
        assert(p.name == "Egon");
      }

      assert(pl3.size() == size);
      for(unsigned int i=0;i<pl3.size();i++) {
        Person p = pl3.at(i);
        assert(p.id == (long)(i+i));
        assert(p.name == "Andrea");
      }
    }

    { // test case: typedef long time_t;
      const CCM_Local::world::europe::austria::time_t p1 = 7;
      CCM_Local::world::europe::austria::time_t p2 = 3, p3, result;
      result = ctx->get_connection_outPort()->f7(p1, p2, p3);
      assert(p2 == 7);
      assert(p3 == 3);
      assert(result == 3+7);
    }

    { // test case: enum Color {red, green, blue, black, orange};
      const CCM_Local::world::europe::austria::Color p1 = 
	CCM_Local::world::europe::austria::red;
      CCM_Local::world::europe::austria::Color p2 = 
	CCM_Local::world::europe::austria::green;
      CCM_Local::world::europe::austria::Color p3;
      CCM_Local::world::europe::austria::Color result;
      result = ctx->get_connection_outPort()->f8(p1, p2, p3);
      assert(p2 == CCM_Local::world::europe::austria::red);
      assert(p3 == CCM_Local::world::europe::austria::green);
      assert(result == CCM_Local::world::europe::austria::orange);
    }
}

void
CCM_Test_impl::ccm_passivate()
    throw(LocalComponents::CCMException)
{
    DEBUGNL(" CCM_Test_impl->ccm_passivate()");

    // OPTIONAL : IMPLEMENT ME HERE !
}

void
CCM_Test_impl::ccm_remove()
    throw(LocalComponents::CCMException)
{
    DEBUGNL(" CCM_Test_impl->ccm_remove()");

    // OPTIONAL : IMPLEMENT ME HERE !
}

//==============================================================================
// CCM_Console facet implementation
//==============================================================================

CCM_Console*
CCM_Test_impl::get_inPort()
{
    DEBUGNL(" CCM_Test_impl->get_inPort()");
    inPort_impl* facet = new inPort_impl(this);
    return dynamic_cast<CCM_Console*>(facet);
}

} // /namespace CCM_Session_Test
} // /namespace austria
} // /namespace europe
} // /namespace world
} // /namespace CCM_Local

