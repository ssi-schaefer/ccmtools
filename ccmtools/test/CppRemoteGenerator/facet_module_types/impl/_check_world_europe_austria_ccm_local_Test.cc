/***
 * CCM Tools Test Client 
 *
 * This file was automatically generated by CCM Tools 
 *         <http://ccmtools.sourceforge.net/>
 *
 * This test client is part of the mirror component test concept. For each
 * component a corresponding mirror component will be instantiated. 
 * All component ports will be connected to the mirror component's ports. 
 * Additionally, developers can add some testing code to validate supported
 * interfaces as well as component attribute access.
 ***/

#include <cmath>
#include <cassert>
#include <iostream>

#include <wamas/platform/utils/smartptr.h>

#include <Components/CCM.h>
#include <Components/HomeFinder.h>

#include <world/europe/austria/TestHome_gen.h>

using namespace std;
using namespace wamas::platform::utils;

using world::europe::austria::Test;
using world::europe::austria::TestHome;
using world::europe::austria::BasicTypeInterface;
using world::europe::austria::UserTypeInterface;
using world::europe::austria::VoidTypeInterface;

using world::europe::austria::Color;
using world::europe::austria::Person;
using world::europe::austria::Address;
using world::europe::austria::LongList;
using world::europe::austria::StringList;
using world::europe::austria::PersonList;
using world::europe::austria::time_t;

int main(int argc, char *argv[])
{
    cout << ">>>> Start Test Client: " << __FILE__ << endl;

    SmartPtr<Test> myTest;

    SmartPtr<BasicTypeInterface> basicType;
    SmartPtr<UserTypeInterface> userType;
    SmartPtr<VoidTypeInterface> voidType;

    int error = 0;
    Components::HomeFinder* homeFinder = Components::HomeFinder::Instance();
    error = deploy_world_europe_austria_TestHome("TestHome");             
    if(error) 
    {
        cerr << "BOOTSTRAP ERROR: Can't deploy component homes!" << endl;
        return(error);
    }

    try 
    {
        SmartPtr<TestHome> myTestHome(dynamic_cast<TestHome*>(
			     homeFinder->find_home_by_name("TestHome").ptr()));

        myTest = myTestHome->create();

        basicType = myTest->provide_basicType();
        userType = myTest->provide_userType();
        voidType = myTest->provide_voidType();

        myTest->configuration_complete();
    
    		cout << "= Begin Local Test Case ===================================" << endl;

    		// ------------------------------------------------------------------
    		// Void Type Check
    		// ------------------------------------------------------------------
    {
      cout << "Void Type Check ...";

      long value = 7;
      long result;
      voidType->f1(value);
      result = voidType->f2();
      assert(value == result);

      cout << "OK" << endl;
    }


    // ------------------------------------------------------------------
    // Basic Types Check
    // ------------------------------------------------------------------
    {
      cout << "Basic Types Check ...";

      {
        short short_2=3, short_3, short_r;
        short_r = basicType->f1(7,short_2, short_3);
        assert(short_2 == 7);
        assert(short_3 == 3);
        assert(short_r == 3+7);
      }

      {
        long long_2=3, long_3, long_r;
        long_r = basicType->f2(7,long_2, long_3);
        assert(long_2 == 7);
        assert(long_3 == 3);
        assert(long_r == 3+7);
      }

      {
        unsigned short ushort_2=3, ushort_3, ushort_r;
        ushort_r = basicType->f3(7,ushort_2, ushort_3);
        assert(ushort_2 == 7);
        assert(ushort_3 == 3);
        assert(ushort_r == 3+7);
      }

      {
        unsigned long ulong_2=3, ulong_3, ulong_r;
        ulong_r = basicType->f4(7,ulong_2, ulong_3);
        assert(ulong_2 == 7);
        assert(ulong_3 == 3);
        assert(ulong_r == 3+7);
      }

      {
        float float_2=3.0, float_3, float_r;
        float_r = basicType->f5(7.0,float_2, float_3);
        assert(abs(float_2 - 7.0) < 0.001);
        assert(abs(float_3 - 3.0)< 0.001);
        assert(abs(float_r - (3.0+7.0)) < 0.001);
      }

      {
	double double_2=3.0, double_3, double_r;
        double_r = basicType->f6(7.0,double_2, double_3);
        assert(abs(double_2 - 7.0) < 0.000001);
        assert(abs(double_3 - 3.0) < 0.000001);
        assert(abs(double_r - (3.0+7.0)) < 0.000001);
      }

      {
        char char_2=3, char_3, char_r;
        char_r = basicType->f7(7,char_2, char_3);
        assert(char_2 == 7);
        assert(char_3 == 3);
        assert(char_r == 3+7);
      }

      {
        string string_2 = "drei";
        string string_3;
        string string_r;
        string_r = basicType->f8("sieben",string_2, string_3);
        assert(string_2 == "sieben");
        assert(string_3 == "drei");
        assert(string_r =="dreisieben");
      }

      {
        bool bool_2=false, bool_3, bool_r;
        bool_r = basicType->f9(true, bool_2, bool_3);
        assert(bool_2 == true);
        assert(bool_3 == false);
        assert(bool_r == false && true);
      }

      {
        unsigned char octet_2=3, octet_3, octet_r;
        octet_r = basicType->f10(7,octet_2, octet_3);
        assert(octet_2 == 7);
        assert(octet_3 == 3);
        assert(octet_r == 3+7);
      }

      cout << " OK" << endl;
    }


    // ------------------------------------------------------------------
    // User Types Check
    // ------------------------------------------------------------------
    {
      cout << "User Types Check ...";

      {
        // enum Color {red, green, blue, black, orange}

        Color Color_2,Color_3, Color_r;
        Color_2 = world::europe::austria::ccm::local::blue;

        Color_r = userType->f1(world::europe::austria::ccm::local::red,Color_2, Color_3);

        assert(Color_2 == world::europe::austria::ccm::local::red);
        assert(Color_3 == world::europe::austria::ccm::local::blue);
        assert(Color_r == world::europe::austria::ccm::local::orange);
      }
      
      {
        // struct Person { long id; string name; }   
        Person p1, p2, p3, result;
        
        p1.name = "Egon";   
        p1.id = 3;
        
        p2.name = "Andrea"; 
        p2.id = 23;
        
        result = userType->f2(p1,p2,p3);
        
        assert(p3.name == "Andrea");
        assert(p2.name == "Egon");
        assert(result.name ==  "EgonAndrea");
      }


      {
        // struct Address { string street; long number; Person resident; }
        Address p1, p2, p3, result;
        Person person;

        p1.street = "Waltendorf";   
        p1.number = 7;
        person.name = "Egon";   
        person.id   = 3;
        p1.resident = person;
        
        p2.street   = "Petersgasse"; 
        p2.number   =17;
        person.name = "Andrea";   
        person.id   = 23;
        p2.resident = person;
        
        result = userType->f3(p1,p2,p3);
      
        assert(p3.street == "Petersgasse");
        assert(p3.number == 17);
        assert(p3.resident.name == "Andrea");
        assert(p3.resident.id == 23);
        
        assert(p2.street == "Waltendorf");
        assert(p2.number == 7);
        assert(p2.resident.name == "Egon");
        assert(p2.resident.id == 3);
        
        assert(result.street == "WaltendorfPetersgasse");
        assert(result.number == 24);
        assert(result.resident.name == "EgonAndrea");
        assert(result.resident.id == 26);
      }

      {
        // typedef sequence<long> LongList
        LongList list_1, list_2, list_3, list_r; 

        for(int i=0;i<5;i++) {
          list_1.push_back(i);
          list_2.push_back(i+i);
        }
        
        list_r = userType->f4(list_1,list_2,list_3);
        
        for(unsigned long i=0; i < list_r.size(); i++) {
          assert(list_r.at(i) == (long)i);
        }
        for(unsigned long i=0; i < list_2.size(); i++) {
          assert(list_2.at(i) == (long)i);
        }
        for(unsigned long i=0; i < list_3.size(); i++) {
          assert(list_3.at(i) == (long)(i+i));
        }
      }

      {
        // typedef sequence<string> StringList
        StringList list_1, list_2, list_3, list_r; 

        for(int i=0;i<5;i++) {
          list_1.push_back("Egon");
          list_2.push_back("Andrea");
        }
        
        list_r = userType->f5(list_1,list_2,list_3);
        
        for(unsigned long i=0;i<list_r.size();i++) {
          assert(list_r.at(i) == "Test");
        }
        for(unsigned long i=0;i<list_2.size();i++) {
          assert(list_2.at(i) == "Egon");
        }
        for(unsigned long i=0;i<list_3.size();i++) {
          assert(list_3.at(i) == "Andrea");
        }
      }

      {
        // typedef sequence<Person> PersonList
        PersonList list_1, list_2, list_3, list_r; 

        for(int i=0;i<5;i++) {
	  Person a;
	  a.name = "Andrea";
	  a.id = i;
          list_1.push_back(a);

	  Person e;
	  e.name = "Egon";
	  e.id = i+i;
	  list_2.push_back(e);
        }
        
        list_r = userType->f6(list_1,list_2,list_3);
        
        for(unsigned long i=0; i < list_r.size(); i++) {
          assert(list_r.at(i).name == "Test");
          assert(list_r.at(i).id == (long)i);
        }
        for(unsigned long i=0; i < list_2.size(); i++) {
          assert(list_2.at(i).name == "Andrea");
          assert(list_2.at(i).id == (long)i);
        }
        for(unsigned long i=0; i < list_3.size(); i++) {
          assert(list_3.at(i).name == "Egon");
          assert(list_3.at(i).id == (long)(i+i));
        }
      }

      {
        // typedef long time_t
        world::europe::austria::ccm::local::time_t time_2 =3, time_3, time_r;
        time_r = userType->f7(7,time_2, time_3);
        assert(time_2 == 7);
        assert(time_3 == 3);
        assert(time_r == 3+7);
      }

      cout << " OK" << endl;
    }


    cout << "==== End Test Case =====================================" << endl;

        myTest->remove();
    } 
    catch(Components::HomeNotFound ) 
    {
        cout << "DEPLOYMENT ERROR: can't find a home!" << endl;
        return -1;
    } 
    catch(Components::NotImplemented& e ) 
    {
        cout << "DEPLOYMENT ERROR: function not implemented: " 
	     << e.what (  ) << endl;
        return -1;
    }  
    catch(Components::InvalidName& e ) 
    {
        cout << "DEPLOYMENT ERROR: invalid name during connection: " 
             << e.what (  ) << endl;
        return -1;
    }
    catch ( ... )  
    {
        cout << "DEPLOYMENT ERROR: there is something wrong!" << endl;
        return -1;
    }

    error += undeploy_world_europe_austria_TestHome("TestHome");
    if(error) 
    {
        cerr << "TEARDOWN ERROR: Can't undeploy component homes!" << endl;
        return error;
    }
        
    // Clean up HomeFinder singleton
    Components::HomeFinder::destroy();
    
    cout << ">>>> Stop Test Client: " << __FILE__ << endl;
}
