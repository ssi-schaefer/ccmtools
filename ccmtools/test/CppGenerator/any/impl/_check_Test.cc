/***
 * CCM Tools Test Client 
 *
 * This file was automatically generated by CCM Tools 
 *         <http://ccmtools.sourceforge.net/>
 *
 * This test client is part of the mirror component test concept. For each
 * component a corresponding mirror component will be instantiated. 
 * All component ports will be connected to the mirror component's ports. 
 * Additionally, developers can add some testing code to validate supported
 * interfaces as well as component attribute access.
 ***/

#include <cassert>
#include <iostream>

#include <wamas/platform/utils/smartptr.h>
#include <wamas/platform/utils/Value.h>
#include <wamas/platform/utils/value_simple.h>

#include <Components/ccm/local/CCM.h>
#include <ccm/local/HomeFinder.h>

#include <TestHome_gen.h>

using namespace std;
using namespace wamas::platform::utils;

int main(int argc, char *argv[])
{
    cout << ">>>> Start Test Client: " << __FILE__ << endl;

    int error = 0;
    error  = deploy_TestHome("TestHome");             
    if(error) 
    {
        cerr << "BOOTSTRAP ERROR: Can't deploy component homes!" << endl;
        return(error);
    }

    try 
    {
		Components::ccm::local::HomeFinder* homeFinder = ccm::local::HomeFinder::Instance();
	    SmartPtr<Test> myTest;
    		SmartPtr<AnyTest> test;
    		
        SmartPtr<TestHome> myTestHome(dynamic_cast<TestHome*>
            (homeFinder->find_home_by_name("TestHome").ptr()));

        myTest = myTestHome->create();
        test = myTest->provide_test();
        myTest->configuration_complete();
        
		{	// any op1(in any p1, inout any p2, out any p3);		
			SmartPtr<Value> p1(new ShortValue(11));
			SmartPtr<Value> p2(new ShortValue(22));
			SmartPtr<Value> p3;
			SmartPtr<Value> result = test->op1(p1, p2, p3);
			
			ShortValue* p2Value = dynamic_cast<ShortValue*>(p2.ptr());
			assert(p2Value->value() == 11);

			ShortValue* p3Value = dynamic_cast<ShortValue*>(p3.ptr());
			assert(p3Value->value() == 22);

			ShortValue* resultValue = dynamic_cast<ShortValue*>(result.ptr());
			assert(resultValue->value() == 11);
		}

		{	// anyList op2(in anyList p1, inout anyList p2, out anyList p3);
				
      		AnyList p1;
      		AnyList p2;
      		AnyList p3;
      		AnyList result;
      		for(int i = 0; i < 5; i++) 
      		{
        			SmartPtr<Value> p1Value(new ShortValue(i));
        			SmartPtr<Value> p2Value(new ShortValue(i+i));
        			p1.push_back(p1Value);
        			p2.push_back(p2Value);
      		}
      		result = result = test->op2(p1, p2, p3);
      		for(int i = 0; i < 5; i++) 
      		{
        			ShortValue* p2Value = dynamic_cast<ShortValue*>(p2.at(i).ptr());
        			assert(p2Value->value() == i);

        			ShortValue* p3Value = dynamic_cast<ShortValue*>(p3.at(i).ptr());
				assert(p3Value->value() == i+i);

        			ShortValue* resultValue = dynamic_cast<ShortValue*>(result.at(i).ptr());
				assert(resultValue->value() == i);
      		}
		}
		
      	{	// pair op3(in pair p1, inout pair  p2, out pair p3);
        		Pair p1;
        		p1.name = "key1";
        		SmartPtr<Value> v1(new LongValue(1));
        		p1.value = v1;

        		Pair p2;
        		p2.name = "key2";
        		SmartPtr<Value> v2(new LongValue(2));
        		p2.value = v2;

        		Pair p3;
        		Pair result;

        		result = test->op3(p1, p2, p3);
	
			assert(p2.name == "key1");
			LongValue* p2Value = dynamic_cast<LongValue*>(p2.value.ptr());
			assert(p2Value->value() == 1);

			assert(p3.name == "key2");
			LongValue* p3Value = dynamic_cast<LongValue*>(p3.value.ptr());
			assert(p3Value->value() == 2);
	
			assert(result.name == "key1");
			LongValue* resultValue = dynamic_cast<LongValue*>(result.value.ptr());
			assert(resultValue->value() == 1);
      	}

        myTest->remove();
    } 
    catch(::Components::ccm::local::HomeNotFound ) 
    {
        cout << "DEPLOYMENT ERROR: can't find a home!" << endl;
        return -1;
    } 
    catch(::Components::ccm::local::NotImplemented& e ) 
    {
        cout << "DEPLOYMENT ERROR: function not implemented: " 
	     << e.what (  ) << endl;
        return -1;
    }  
    catch(::Components::ccm::local::InvalidName& e ) 
    {
        cout << "DEPLOYMENT ERROR: invalid name during connection: " 
             << e.what (  ) << endl;
        return -1;
    }
    catch ( ... )  
    {
        cout << "DEPLOYMENT ERROR: there is something wrong!" << endl;
        return -1;
    }

    error += undeploy_TestHome("TestHome");
    if(error) 
    {
        cerr << "TEARDOWN ERROR: Can't undeploy component homes!" << endl;
        return error;
    }
        
    // Clean up HomeFinder singleton
    ccm::local::HomeFinder::destroy();
    
    cout << ">>>> Stop Test Client: " << __FILE__ << endl;
}
