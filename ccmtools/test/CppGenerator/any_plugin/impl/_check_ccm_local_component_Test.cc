/***
 * CCM Tools Test Client 
 *
 * This file was automatically generated by CCM Tools version 0.5.3-pre2.
 *         <http://ccmtools.sourceforge.net/>
 *
 * This test client is part of the mirror component test concept. For each
 * component a corresponding mirror component will be instantiated. 
 * All component ports will be connected to the mirror component's ports. 
 * Additionally, developers can add some testing code to validate supported
 * interfaces as well as component attribute access.
 *
 * To enable debug output use -DWXDEBUG compiler flag and set the
 * WX_DEBUG_LEVELS environment variable to "CCM_LOCAL"
 * (e.g. export WX_DEBUG_LEVELS="CCM_LOCAL").
 *
 * To enable DbC adapter use -DCCM_USE_DBC compiler flag.
 ***/

#include <cassert>
#include <iostream>

#include <WX/Utils/debug.h>
#include <WX/Utils/smartptr.h>

#include <ccm/local/Components/CCM.h>
#include <ccm/local/HomeFinder.h>


#ifdef CCM_USE_DBC
#include <ccm/local/component/Test/Test_dbc.h>
#include <ccm/local/component/Test/TestHome_dbc.h>
#else
#include <ccm/local/component/Test/Test_gen.h>
#include <ccm/local/component/Test/TestHome_gen.h>
#endif

using namespace std;
using namespace WX::Utils;
using namespace ccm::local;

int main(int argc, char *argv[])
{
    cout << ">>>> Start Test Client: " << __FILE__ << endl;

    SmartPtr< ccm::local::component::Test::Test> myTest;
    SmartPtr< ccm::local::IFace> facet;

    // Component bootstrap:
    // We get an instance of the local HomeFinder and register the deployed
    // component- and mirror component home.
    // Here we can also decide to use a Design by Contract component.  	
    int error = 0;
    Components::HomeFinder* homeFinder = 
        HomeFinder::Instance();
#ifdef CCM_USE_DBC
    error  = deploy_dbc_ccm_local_component_Test_TestHome("TestHome", false);
#else
    error  = deploy_ccm_local_component_Test_TestHome("TestHome");
#endif
             
    if(error) {
        cerr << "BOOTSTRAP ERROR: Can't deploy component homes!" << endl;
        return(error);
    }

    // Component deployment:
    // We use the HomeFinder method find_home_by_name() to get a smart pointer 
    // to a component home. From a component home, we get a smart pointer to a 
    // component instance using the create() method.
    // Component and mirror component are connected via provide_facet() and 
    // connect() methods.
    // The last step of deployment is to call configuration_complete() that 
    // forces components to run the ccm_set_session_context() and ccm_activate() 
    // callback methods.
    try {
        SmartPtr< ccm::local::component::Test::TestHome> myTestHome(
            dynamic_cast< ccm::local::component::Test::TestHome*>
            (homeFinder->find_home_by_name("TestHome").ptr()));

        myTest = myTestHome->create();

        facet = myTest->provide_facet();

        myTest->configuration_complete();
    } 
    catch(Components::HomeNotFound ) {
        cout << "DEPLOYMENT ERROR: can't find a home!" << endl;
        error = -1;
    } 
    catch(Components::NotImplemented& e ) {
        cout << "DEPLOYMENT ERROR: function not implemented: " 
	     << e.what (  ) << endl;
        error = -1;
    }  
    catch(Components::InvalidName& e ) {
        cout << "DEPLOYMENT ERROR: invalid name during connection: " 
             << e.what (  ) << endl;
        error = -1;
    }
#ifdef CCM_USE_DBC
    catch(ccm::OCL::OclException& e)
    {
        cout << "DEPLOYMENT ERROR: 'design by contract' error:" 
             << endl << e.what();
        error = -1;
    }
#endif
    catch ( ... )  {
        cout << "DEPLOYMENT ERROR: there is something wrong!" << endl;
        error = -1;
    }
    if (error < 0) {
        return error;
    }

    // Component test:
    // After component deployment, we can access components and their facets.
    // Usually, the test cases for facets and receptacles are implemened in the
    // mirror component. But for supported interfaces and component attributes, 
    // we can realize test cases in the following section.
    try {
      	::Person person1;
	person1.id = 277;
	person1.firstName = "Egon";
	person1.lastName = "Teiniker";

	::Person person2;
	person2.id = 290;
        person2.firstName = "Jörg";
        person2.lastName = "Faschingbauer";

	::DTO dto1;
	dto1.id = 111;
	dto1.person = person1;

	::DTO dto2;
	dto2.id = 222;
	dto2.person = person2;
	
      {
	// Note: we use the global structures (not the ccm::local
	// structures generated by the ccmtools).

	::Person p1;
	p1.id = person1.id;
	p1.firstName = person1.firstName;
	p1.lastName = person1.lastName;

	// Note: we mix global and ccm::local structures and use them
	// as parameter for a facet method call.
	ccm::local::Person p2;
	p2.id = person2.id;
        p2.firstName = person2.firstName;
        p2.lastName = person2.lastName;

	::Person p3,result;

	result = facet->op1(p1,p2,p3);

	assert(p2.id == person1.id);
	assert(p2.firstName == person1.firstName);
	assert(p2.lastName == person1.lastName);
	
	assert(p3.id == person2.id);
	assert(p3.firstName == person2.firstName);
	assert(p3.lastName == person2.lastName);

	assert(result.id == person1.id);
	assert(result.firstName == person1.firstName);
	assert(result.lastName == person1.lastName);
      }

      {
	::DTO p1;
	p1.id = dto1.id;
	p1.person = dto1.person;

	::DTO p2;
	p2.id = dto2.id;
	p2.person = dto2.person;
	
	::DTO p3, result;

	result = facet->op2(p1,p2,p3);

	assert(p2.id == dto1.id);
	assert(p2.person.id == dto1.person.id);
	assert(p2.person.firstName == dto1.person.firstName);
	assert(p2.person.lastName == dto1.person.lastName);

	assert(p3.id == dto2.id);
	assert(p3.person.id == dto2.person.id);
	assert(p3.person.firstName == dto2.person.firstName);
	assert(p3.person.lastName == dto2.person.lastName);

	assert(result.id == dto1.id);
	assert(result.person.id == dto1.person.id);
	assert(result.person.firstName == dto1.person.firstName);
	assert(result.person.lastName == dto1.person.lastName);
      }
    } 
    catch(Components::NotImplemented& e ) {
        cout << "TEST: function not implemented: " << e.what (  ) << endl;
        error = -1;
    }
#ifdef CCM_USE_DBC
    catch(ccm::OCL::OclException& e)
    {
        cout << "TEST: 'design by contract' error:" << endl << e.what();
        error = -1;
    }
#endif
    catch(...) {
        cout << "TEST: there is something wrong!" << endl;
        error = -1;
    }
    if(error < 0) {
	return error;
    }
  

    // Component tear down:
    // Finally, the component and mirror component instances are disconnected 
    // and removed. Thus component homes can be undeployed.
    try {
        myTest->remove();
    } 
    catch(Components::HomeNotFound ) {
        cout << "TEARDOWN ERROR: can't find a home!" << endl;
        error = -1;
    } 
    catch(Components::NotImplemented& e ) {
        cout << "TEARDOWN ERROR: function not implemented: " 
	     << e.what (  ) << endl;
        error = -1;
    } 
    catch(...) {
        cout << "TEARDOWN ERROR: there is something wrong!" << endl;
        error = -1;
    }
    error += undeploy_ccm_local_component_Test_TestHome("TestHome");
    if(error) {
        cerr << "TEARDOWN ERROR: Can't undeploy component homes!" << endl;
        return error;
    }
    cout << ">>>> Stop Test Client: " << __FILE__ << endl;
}
