\documentclass [a4paper,12pt] {scrartcl}
\usepackage[austrian]{babel}
\usepackage{graphicx}
\author{Robert Lechner}
\title{Java-Codegenerator f{\"u}r DTDs}
\date{2. April 2004}

\newcommand{\DTD}{{\sffamily\small DTD}}
\newcommand{\XML}{{\sffamily\small XML}}

\begin{document}
\maketitle
\section{Einleitung}
Um die Struktur einer \XML-Datei zu beschreiben wird ein \DTD\ (Document Type Definition)
verwendet. Zur weiteren Bearbeitung der Daten aus der \XML-Datei ist es sinnvoll,
dass der \XML-Parser eine Datenstruktur liefert, die der Beschreibung im \DTD\ entspricht.
Das Programm \texttt{dtd2java} liest nun ein \DTD\ und erzeugt daraus eine einfache
Datenstruktur, sowie den entsprechenden \XML-Parser.\\
~\\
Das erzeugte Modell orientiert sich ausschlie{\ss}lich am \DTD; es ist also kein Ersatz
f{\"u}r ein von Hand optimiertes Metamodell. Da das Erstellen eines solchen Modells aber
sehr aufwendig ist, stellt \texttt{dtd2java} eine M{\"o}glichkeit dar ohne gro{\ss}en
Zeitaufwand einen \XML-Parser (mit Datenstruktur) zu erhalten.

\section{{\"U}bersicht}
Das Paket \texttt{dtd2java} besteht aus zwei Teilen:
einem Parser f{\"u}r das \DTD\ und einem Codegenerator,
der aus dem \DTD\ einen \XML-Parser mit einem einfachen Modell erzeugt.
In Abbildung \ref{fig:dtd2java-classes} sind die verwendeten Klassen dargestellt.
\begin{figure}[ht!]
\centerline{\includegraphics[width=1.1 \linewidth]{classes.eps}}
\caption{{\"U}bersicht {\"u}ber das Paket \texttt{dtd2java}}
\label{fig:dtd2java-classes}
\end{figure}

\subsection{DTD-Parser}
F{\"u}r den \DTD-Parser wird der Parsergenerator \textsf{ANTLR}
\footnote{ANTLR Translator Generator (http://www.antlr.org)}
ben{\"o}tigt.\\
Zum Lesen eines \DTD\ ruft man die statische Methode \texttt{DtdParser.parseFile} auf.
Man erh{\"a}lt eine Instanz von \texttt{DtdFile}, welche alle Elemente des \DTD\ enth{\"a}lt.
Entities werden automatisch expandiert; Attributlisten werden zusammengefasst.

\subsection{Codegenerator}
\subsubsection{Aufruf}
Es gibt zwei M{\"o}glichkeiten den Generator zu starten:
\begin{itemize}
\item Erzeugen einer Instanz von \texttt{DtdGenerator} und Aufruf der Methode \texttt{run}.
    Man ben{\"o}tigt dazu aber eine Instanz von \texttt{DtdFile} (siehe oben).
\item Man startet den Generator als Programm:\\
    \texttt{java dtd2java.Main \DTD-file Java-package [root-directory]}
\end{itemize}
Der Parameter \texttt{Java-package}, den man in beiden F{\"a}llen ben{\"o}tigt, ist der Name
jenes package, in welchem der erzeugte Code liegen soll. Das Paket wird im aktuellen
oder im angegebenen (\texttt{root-directory})
Verzeichnis angelegt.
\subsubsection{Eigenschaften}
Der generierte Code hat die folgenden Eigenschaften:
\begin{itemize}
\item F{\"u}r jedes Element im \DTD\ (\texttt{<!ELEMENT name content >})
    wird eine eigene Klasse generiert. Alle Attribute sind als {\"o}ffentliche Variablen
    direkt zug{\"a}nglich. Der Inhalt des Elements wird in einem allgemeinen Container gespeichert.
\item \DTD-Namespaces werden als Java-Packages dargestellt.
\item Der gesamte generierte Code ist \texttt{javadoc}-kompatibel dokumentiert.
\item Es werden alle ben{\"o}tigten Klassen im angegebenen Paket generiert
    $\Rightarrow$ man ben{\"o}tigt zum Ausf{\"u}hren des erzeugten Codes keine
    weiteren Packages (ausgenommen der Java 1.4 Library).
\end{itemize}
Zus{\"a}tzlich werden Dateien f{\"u}r das Tool \textsf{dot}
\footnote{Graphviz (http://www.graphviz.org)}
erzeugt.

\subsubsection{erzeugter Code}
Alle Klassen sind von \texttt{DTD\_Container} abgeleitet. {\"U}ber die Methoden \texttt{size}
und \texttt{get} ist der direkte Zugriff auf den Inhalt m{\"o}glich. Mit der {\"o}ffentlichen
Variable \texttt{parent\_\_} kann auf den Vorg{\"a}nger im Baum zugegriffen werden.\\
~\\
In den Unterklassen wird f{\"u}r jedes Attribut des \XML-Elements eine {\"o}ffentliche Variable
erzeugt. In der statischen Variable \texttt{xmlName\_\_} steht der vollst{\"a}ndige \XML-Name
des Elements. Mit der Methode \texttt{xmlCode} kann der \XML-Code erzeugt werden.\\
~\\
Alle Elemente, welche nicht im \DTD\ deklariert wurden, werden als Instanz von
\texttt{DTD\_Generic} gespeichert. Dadurch ist eine Rekonstruktion des \XML-Codes
auch bei unbekannten Elementen m{\"o}glich.\\
~\\
Um die Erweiterbarkeit des erzeugten Modells zu gew{\"a}hrleisten, werden alle Instanzen
{\"u}ber eine Factory (\texttt{DTD\_Creator}) erzeugt. Zur Demonstration dient das folgende Beispiel:\\
\begin{figure}[ht!]
\centerline{\includegraphics[height=10cm]{dtd1.eps}}
\caption{Erweiterung des generierten Modells}
\label{fig:dtd2java-dtd1}
\end{figure}
~\\
\begin{minipage}{\linewidth}
\textbf{XML-Element:}
\begin{verbatim}
package test_model;
import org.xml.sax.*;

public class E9 extends DTD_Container
{
    ...
}
\end{verbatim}
\end{minipage}
~\\[4ex]
\begin{minipage}{\linewidth}
\textbf{Factory:}
\begin{verbatim}
package test_model;
import org.xml.sax.*;

public class DTD_Creator
{
  public DTD_Container create( String qName, Attributes attrs )
  {
    ...
    if(qName.equals("E9"))  return new E9(attrs);
    ...
    return new DTD_Generic(qName, attrs);
  }
}
\end{verbatim}
\end{minipage}
~\\[4ex]
\begin{minipage}{\linewidth}
\textbf{eigenes Element:}
\begin{verbatim}
package test_application;
import test_model.*;
import org.xml.sax.*;

public class MyE9 extends E9
{
    public MyE9( Attributes attrs )
    {
        super(attrs);
    }

    ...
}
\end{verbatim}
\end{minipage}
~\\[4ex]
\begin{minipage}{\linewidth}
\textbf{eigene Factory:}
\begin{verbatim}
package test_application;
import test_model.*;
import org.xml.sax.*;

public class MyFactory extends DTD_Creator
{
    public DTD_Container create( String qName, Attributes attrs )
    {
        if( qName.equals(E9.xmlName__) )
        {
            return new MyE9(attrs);
        }
        return super.create(qName, attrs);
    }
}
\end{verbatim}
\end{minipage}
~\\[4ex]
Der erzeugte Parser wird mit der statischen Methode \texttt{DTD\_Root.parse} aufgerufen.
Dabei kann optional auch eine eigene Factory {\"u}bergeben werden. Im obigen Beispiel
w{\"u}rde der Aufruf wie folgt lauten:
\begin{verbatim}
java.io.File xmlFile = new java.io.File( ... );
DTD_Container root = DTD_Root.parse( xmlFile, new MyFactory() );
\end{verbatim}

\newpage
\section{Klassen}
Es folgt eine {\"U}bersicht {\"u}ber alle automatisch erzeugten Klassen
(ohne die Klassen der \DTD-Elemente). Die Klassen der \DTD-Elemente
sind von \texttt{DTD\_Container} abgeleitet.
\begin{figure}[ht!]
\centerline{\includegraphics[width=1.1 \linewidth]{dtd2.eps}}
\caption{alle automatisch erzeugten Klassen}
\label{fig:dtd2java-dtd2}
\end{figure}

\end{document}
