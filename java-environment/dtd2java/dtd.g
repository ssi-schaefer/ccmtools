/*
 * DTD grammar
 *
 * 2003 by Robert Lechner (rlechner@gmx.at)
 *
 */


header {
/*
 * This file was automatically generated by
 * 'ANTLR Translator Generator' (http://www.antlr.org).
 *
 * DO NOT EDIT!
 */


/* DTD parser
 *
 * 2003 by Robert Lechner (rlechner@gmx.at)
 *
 * $Id$
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

package ccmtools.dtd2java;
}


class DtdParser extends Parser;

options {
  k=2;
  exportVocab=DTD;
}


{
	/**
	 * Reads a DTD-file and creates the parse tree.
	 * Writes the preprocessed DTD to "fileName.PP.dtd".
	 *
	 * @param fileName  the name of the DTD-file
	 * @return the parse tree
	 *
	 * @throws java.io.IOException  file I/O error
	 * @throws antlr.ANTLRException  parser error
	 */
	public static DtdFile parseFile( String fileName )
	 throws antlr.ANTLRException, java.io.IOException
	{
		DtdPreprocessor p = new DtdPreprocessor();
		p.read(fileName);
		fileName = fileName+".PP.dtd";
		p.write(fileName);
		java.io.BufferedInputStream stream = new java.io.BufferedInputStream(
			new java.io.FileInputStream(fileName) );
		DtdLexer lexer = new DtdLexer( stream );
		DtdParser parser = new DtdParser( lexer );
		return parser.dtdFile();
	}


	private DtdContent parseContent( String code ) throws RecognitionException, TokenStreamException
	{
		java.io.ByteArrayInputStream stream = new java.io.ByteArrayInputStream(code.getBytes());
		DtdLexer lexer = new DtdLexer( stream );
		DtdParser parser = new DtdParser( lexer );
		parser.entities_.putAll(entities_);
		return parser.eCommaExpr();
	}


	private java.util.Vector parseAttribute( String code ) throws RecognitionException, TokenStreamException
	{
		code = code.trim();
		java.io.ByteArrayInputStream stream = new java.io.ByteArrayInputStream(code.getBytes());
		DtdLexer lexer = new DtdLexer( stream );
		DtdParser parser = new DtdParser( lexer );
		parser.entities_.putAll(entities_);
		java.util.Vector buffer = new java.util.Vector();
		while( parser.LA(1)!=EOF )
		{
			DtdAttribute attr = parser.attributeDecl();
			buffer.add(attr);
		}
		return buffer;
	}


	/**
	 * Stores names and values of entities.
	 */
	private java.util.HashMap entities_ = new java.util.HashMap();
}


dtdFile returns [DtdFile p_file]
{
	entities_.put("amp",  "&" );
	entities_.put("lt",   "<" );
	entities_.put("gt",   ">" );
	entities_.put("quot", "\"");
	entities_.put("apos", "\'");
	//
	p_file=new DtdFile();
	DtdElement p_element=null;
	DtdAttributes p_attributes=null;
	DtdEntity p_entity=null;
	DtdNotation p_notation=null;
}
  : ( p_element=element {p_file.addElement(p_element);}
    | p_attributes=attlist {p_file.addAttributes(p_attributes);}
    | p_entity=entity
      {
      	if( p_entity!=null )
      	{
			String p_name = p_entity.getName();
			if( entities_.containsKey(p_name) )
			{
				throw new RecognitionException("entity redefinition: "+p_name);
			}
			entities_.put(p_name,p_entity.getValue());
			p_file.addEntity(p_entity);
		}
	  }
    | p_notation=notation {p_file.addNotation(p_notation);}
    )*
  ;


element returns [DtdElement p_element=null]
{
	String p_name=null;
	DtdContent p_content=null;
}
  : ELEMENT_TOKEN p_name=eName p_content=eContent END_TOKEN
    {p_element=new DtdElement(p_name,p_content);}
  ;


eName returns [String p_name=null]
: n1:NAME {p_name=n1.getText();} (COLON n2:NAME {p_name+=":"+n2.getText();})*
;


eContent returns [DtdContent p_content=null]
: "ANY" {p_content=DtdConstant.ANY;}
| "EMPTY" {p_content=DtdConstant.EMPTY;}
| p_content=eRule
| p_content=entityContentRef
;


eRule returns [DtdContent p_content=null]
{
	String p_Opt=null;
}
  : LPAREN p_content=eCommaExpr RPAREN (p_Opt=eOpt)?
    {p_content.mergeOptionally(p_Opt);}
  ;


eCommaExpr returns [DtdContent p_content=null]
{
	DtdContent p_expr=null;
}
  : p_content=eBarExpr (COMMA p_expr=eCommaExpr {p_content=new DtdComma(p_content,p_expr);})*
  ;


eBarExpr returns [DtdContent p_content=null]
{
	DtdContent p_expr=null;
}
  : p_content=eSimpleExpr (BAR p_expr=eBarExpr {p_content=new DtdBar(p_content,p_expr);})*
  ;


eSimpleExpr returns [DtdContent p_content=null]
{
	String p_name=null, p_Opt=null;
}
  : PCDATA_TOKEN {p_content=DtdConstant.getPCDATA();}
  | p_name=eName (p_Opt=eOpt)? {p_content=new DtdName(p_name); p_content.mergeOptionally(p_Opt);}
  | p_content=eRule
  | p_content=entityContentRef
  ;


entityContentRef returns [DtdContent p_content=null]
{
	String p_name=null;
}
  : (AND|PERC) p_name=eName SEMICOL
    {
    	String p_value=(String)entities_.get(p_name);
    	if( p_value==null )
    	{
    		throw new RecognitionException("unknown entity: "+p_name);
    	}
    	p_content = parseContent(p_value);
    }
  ;


entityAttributeRef returns [java.util.Vector p_attr=null]
{
	String p_name=null;
}
  : (AND|PERC) p_name=eName SEMICOL
    {
    	String p_value=(String)entities_.get(p_name);
    	if( p_value==null )
    	{
    		throw new RecognitionException("unknown entity: "+p_name);
    	}
    	p_attr = parseAttribute(p_value);
    }
  ;


eOpt returns [String p_opt=null]
: QUEST {p_opt="?";}
| PLUS  {p_opt="+";}
| STAR  {p_opt="*";}
;


entity returns [DtdEntity p_entity=null]
{
	boolean p_parameter=false, p_system=false;
	String p_ndata=null, p_name=null;
}
  : ENTITY_TOKEN (PERC {p_parameter=true;})? p_name=eName ("SYSTEM" {p_system=true;})? n2:STRING
    ("NDATA" p_ndata=eName)? END_TOKEN
    {p_entity=new DtdEntity(p_name,n2.getText(),p_parameter,p_system,p_ndata);}
  ;


notation returns [DtdNotation p_notation=null]
{
	String p_name=null;
}
: NOTATION_TOKEN p_name=eName "SYSTEM" n2:STRING END_TOKEN
  {p_notation=new DtdNotation(p_name,n2.getText());}
;


attlist returns [DtdAttributes p_attributes=null]
{
	String p_name=null;
	java.util.Vector p_buffer=new java.util.Vector(), p_result=null;
	DtdAttribute p_attr=null;
}
  : ATTLIST_TOKEN p_name=eName
    (  p_attr=attributeDecl {p_buffer.add(p_attr);}
    |  p_result=entityAttributeRef {p_buffer.addAll(p_result);}
    )+
    END_TOKEN
    {p_attributes=new DtdAttributes(p_name,p_buffer);}
  ;


attributeDecl returns [DtdAttribute p_attr=null]
{
	DtdAttributeType p_type=null;
	DtdAttributeDefault p_default=null;
	String p_name=null;
}
  : (p_name=eName p_type=typeDecl p_default=defaultDecl)
    {p_attr=new DtdAttribute(p_name,p_type,p_default);}
  ;


typeDecl returns [DtdAttributeType p_type=null]
{
	boolean p_notation=false;
	DtdEnumeration p_enum=null;
}
  : "CDATA" {p_type=DtdAttributeType.CDATA;}
  | "ENTITY" {p_type=DtdAttributeType.ENTITY;}
  | "ENTITIES" {p_type=DtdAttributeType.ENTITIES;}
  | "ID" {p_type=DtdAttributeType.ID;}
  | "IDREF" {p_type=DtdAttributeType.IDREF;}
  | "IDREFS" {p_type=DtdAttributeType.IDREFS;}
  | "NMTOKEN" {p_type=DtdAttributeType.NMTOKEN;}
  | "NMTOKENS" {p_type=DtdAttributeType.NMTOKENS;}
  | ("NOTATION" {p_notation=true;})? p_enum=enumDecl {p_type=new DtdAttributeTypeEnumeration(p_enum,p_notation);}
  ;


enumDecl returns [DtdEnumeration p_enum=null]
{
	java.util.Vector p_buffer = new java.util.Vector();
}
: LPAREN n1:NAME {p_buffer.add(n1.getText());}
  (BAR n2:NAME {p_buffer.add(n2.getText());})*
  RPAREN
  {p_enum=new DtdEnumeration(p_buffer);}
;


defaultDecl returns [DtdAttributeDefault p_default=null]
{
	boolean p_fixed=false;
}
: REQUIRED_TOKEN {p_default=DtdAttributeDefault.REQUIRED;}
| IMPLIED_TOKEN {p_default=DtdAttributeDefault.IMPLIED;}
| (FIXED_TOKEN {p_fixed=true;})? n1:STRING
  {p_default=p_fixed ? DtdAttributeDefault.createFixed(n1.getText()) : DtdAttributeDefault.createDefault(n1.getText());}
;


//////////////////////////////////////////////////////////////////////////////


class DtdLexer extends Lexer;

options {
  exportVocab=DTD;
  charVocabulary = '\3'..'\377';
  caseSensitive=true;
  testLiterals=false;
  k = 4;
}


WS:
    ( ' '
    | '\t'
    | '\f'
    | ( "\r\n" | '\r' | '\n' )
      { newline (); }
    )
    { $setType(Token.SKIP); }
;


COLON			: ':';
LPAREN			: '(';
RPAREN			: ')';
COMMA			: ',';
BAR				: '|';
AND				: '&';
PERC			: '%';
SEMICOL			: ';';
QUEST			: '?';
PLUS			: '+';
STAR			: '*';
ELEMENT_TOKEN	: "<!ELEMENT";
ATTLIST_TOKEN	: "<!ATTLIST";
NOTATION_TOKEN	: "<!NOTATION";
ENTITY_TOKEN	: "<!ENTITY";
END_TOKEN		: '>';
PCDATA_TOKEN	: "#PCDATA";
REQUIRED_TOKEN	: "#REQUIRED";
IMPLIED_TOKEN	: "#IMPLIED";
FIXED_TOKEN		: "#FIXED";


protected NAME_CHAR
	: ('a'..'z') | ('A'..'Z') | ('0'..'9') | ('.') | ('-') | ('_')
	;

NAME
options {
  testLiterals = true;
}
	: (('a'..'z') | ('A'..'Z')) (NAME_CHAR)*
	;


protected NewlineProcessing
: ( options {generateAmbigWarnings=false;}
	:	'\r' '\n'		{newline(); $setText(" ");}
	|	'\r'			{newline(); $setText(" ");}
	|	'\n'			{newline(); $setText(" ");}
  );

protected String1
	:	'\"'!
		(
			NewlineProcessing
		|	~('\"'|'\n'|'\r')
		)*
		'\"'!
	;

protected String2
	:	'\''!
		(
			NewlineProcessing
		|	~('\''|'\n'|'\r')
		)*
		'\''!
	;

STRING : (String1|String2);


// multiple-line comments
protected COMMENT_DATA
	:	(	/*	'\r' '\n' can be matched in one alternative or by matching
				'\r' in one iteration and '\n' in another.  I am trying to
				handle any flavor of newline that comes in, but the language
				that allows both "\r\n" and "\r" and "\n" to all be valid
				newline is ambiguous.  Consequently, the resulting grammar
				must be ambiguous.  I'm shutting this warning off.
			 */
			options {
				generateAmbigWarnings=false;
			}
		:
		{ LA(2)!='-' && LA(3)!='>' }? '-' // allow '-' if not "-->"
		|	'\r' '\n'		{newline();}
		|	'\r'			{newline();}
		|	'\n'			{newline();}
		|	~('-'|'\n'|'\r')
		)*;

COMMENT :	(("<!--") (COMMENT_DATA) ("-->"))	{ $setType(Token.SKIP); } ;

